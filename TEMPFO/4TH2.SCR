\ SCRATCH SCREEN                                                131                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (  START SCREEN ON BOOT )                                                                                                       \ 258 260 VSWAP  ( STANDART  - NO PREFETCH )                                                                                    ( FORGET 'INIT    ( CLEAR DP - H  AFTER TURNKEY)                  3 LOAD        ( MACROSES)                                       2  ATTR C!                                                    \ 47 ATTR C!                                                    \ PAGE            ( CLEAR SCREEN)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \  START SCREEN ON COMPILE )                                                                                                    \ 258 260 VSWAP  ( STANDART  - NO PREFETCH )                    \ 63 LOAD    ( OBJECT TEST )                                    \   3  LOAD  ( MACROSES )                                         141  LOAD  ( OBJECTS  )                                          87  LOAD  ( MARKER   )                                         170  LOAD  ( EDITOR   )                                          89  LOAD  ( HACK + ASSEMBLER )                                 318  LOAD  ( TARGET COMPILER EXTENSIOS)                            F83                                                        ( 47) 2  ATTR C!  ( 2)                                          \   90 104 THRU ( ASEMBLER )                                                                                                     111111111111                                                                                                                   \ MACRO DEFINITIONS & TESTING                                   \ : MACRO? 128 [AT] MAC: 6 - C>N DROP TO XOR ;                  \ MACRO? FORGET MACRO?                                                                                                                                                                          \ HERE TO CSP                                                   \ 48 55 THRU      ( MACRO DEFINITIONS)                          \ [  CSP forget  ( CAREFUL !!!)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (  REDO SCREEN                                                ) : LISTER 1+ SWAP DO I LIST LOOP ;                                                                                                                                                               EXIT                                                            : S! TO AR DUP TO !+ FOR COUNT TO !+ NEXT DROP ;                                                                                                                                                ( 12345678901234567890123456789012                          )   : çÖèêéíàÇéäéçëíàíìñàéçëíÇìÇÄíÖãë ( íÇìÇÄâíÖ) ;                 \  1 LOAD   \ DISASM   \ 65 LOAD                                : DISNF2 0 BLOCK PAD 1K CMOVE [ DISASM ] PAD TO IP                155 ND ;                                                                                                                                                                                                                                                      \ : COPYBLK ARGS( FROMBLK ENDBLK TOBLK / DISP CNT )             \    TOBLK 1+ FROMBLK - TO CNT  FROMBLK TOBLK - TO DISP         \    DISP 0< IF CNT FOR FROMBLK I' + TOBLK I' + COPY NEXT       \      ELSE CNT 0 DO FROMBLK I + TOBLK I + COPY LOOP THEN /ARGS \ : COPYBLOCKS -ROT 1+ SWAP DO I OVER COPY 1+ LOOP DROP ;       \ : COPYBL FOR 2DUP COPY 1+ SWAP 1+ SWAP NEXT 2DROP ;     EXIT  : 7DAY CASE 1   OF ." MON"   ENDOF   2   OF ." TUES"  ENDOF                 3   OF ." WEDNES"  ENDOF 4   OF ." THURS"  ENDOF                5   OF ." FRI"  ENDOF    6   OF ." SATUR"  ENDOF                7   OF ." SUN"  ENDOF   C" ? EMIT ENDCASE              ." DAY" ;                                                                                                                                                                                                                                                                                                                                                                                    ( DEBUF LW LAST WORD  LA - LAST ADR  FA - FIRST ADR           ) 0 QUAN ADR : VALUES FOR 0 VALUE NEXT ; : BADR AT ADR @1+! C@ ;  8 VALUES LW CA LA EF IDX FA NA PASS     : WADR AT ADR @2+! @ ;  : ?ADR STR ROT TO SCAN 1+ ;     : +ADR DUP 1+! STR 1- 2* + ! ;  : ?+ADR 2DUP ?ADR -IF +ADR THEN ;                               : ??ADR DUP HERE ?ADR IF DROP EXIT THEN PAD ?ADR ;              : !ADR ADR 1- NA U< IF NA PAD +ADR EXIT THEN NA HERE +ADR ;     : XSC CREATE C, DOES> COUNT 2DUP 2* + >R  LW TO SCAN 1+ ?DUP                     -IF RDROP EXIT THEN TO IDX ; \ BRANCHES        9 XSC BRANC  ] (BR TO (BR AT (BR (DO TO (DO (LP TO (LP (FOR (OF    WADR TO NA  LA NA U< IF NA TO LA THEN  NA !ADR                   PASS IF NA H. CR THEN NA !ADR ;M  \ BRANCHES COMPILE ?      3 XSC STRG ] (" (". TO ABORT          \ STRINGS COMPILE ?        PASS IF ADR ". 34 EMIT SPACE THEN BADR ADR + TO ADR ;M                     -->                                                                                                                                                                                 2 XSC COMP ] COMPILE  LIT             \ WORD COMPILE ?              WADR PASS IF IDX 1- IF . EXIT THEN ?ID. EXIT THEN DROP ;M   2 XSC BCOM ] BCOMPILE BLIT            \ BYTE COMPILE ?              BADR PASS IF H. EXIT THEN DROP ;M                           3 XSC ENDS ] EXIT ;code AT NOOP       \ SOME KIND OF EXIT ?         LA ADR U< IF 1 TO EF THEN ;M                                : 1I ADR TO CA  WADR TO LW                                         PASS IF CA ??ADR IF CR 58 EMIT CA H. THEN  LW ?ID. THEN                                      BRANC COMP STRG BCOM ENDS ;                                                                     : PAS TO PASS FA TO ADR 0 DUP TO LA TO EF BEGIN 1I EF UNTIL ;   : 'HACK CR TO FA  HERE TO 0  PAD TO 0   0 PAS  1 PAS ;          : HACK  ' 2+ 'HACK ;                                                                                                                                                                            ( DEBUF LW LAST WORD  LA - LAST ADR  FA - FIRST ADR           ) MARKER -HACK                                                    0 QUAN ADR    -HEADERS                                                     : VALUES FOR 0 VALUE NEXT ;  : BADR AT ADR @1+! C@ ; 9 VALUES LW EF IX 1A NA LA PS HW TAB    0 QUAN SCP              0 <STACK FSTK 0 , 0 <STACK BSTK 0 , : /1PAS PS -IF RDROP THEN ; : WADR AT ADR @2+! @ ; : SADR AT SCP @2+! @ ADR = ;             : !ADR ADR 1- OVER U< IF TO FSTK EXIT THEN TO BSTK ;            : ?ID 0 -ROT CNTDO DO I C@ 33 127 WITHIN -IF 1+ THEN LOOP ;     FUNC: ID.OK ( ADDR / ID FLG )   ADDR C>N TO ID                  ID IF COUNT #LEN AND DUP TO ID ?ID TO FLG THEN  ID               -IF 1 TO FLG THEN ADDR FLG IF C" : EMIT H. RETURN THEN  ?ID. ; : @BRAN  WADR TO NA  LA NA U< IF NA TO LA THEN ;                : XSC CREATE C, DOES> COUNT 2DUP 2* + TO NA LW TO SCAN 1+ ?DUP     IF 1- TO IX RDROP NA PUSH THEN ;                             : #. BASE PUSH DECIMAL . POP TO BASE ;       -->                ( DEBUF LW LAST WORD  LA - LAST ADR  1A - FIRST ADR           ) : NEWLN CR TAB SPACES ;   : NEWLN? OUTC + 1L < -IF NEWLN THEN ; : #NAME CREATE DOES> PS IF DUP IX SCIND DUP C@  NEWLN?                ". SPACE THEN DROP ;   : TAB+ TAB + TO TAB ;              : BWADR IX -IF BADR ;THEN WADR ;   : 1-, HERE 2- @ 1- , ;       : WDADR IX 2- -IF WADR ;THEN S>D ; : '@,  ' @ , ;               #NAME LUP. ," DO ," ?DO ," LOOP ," +LOOP ," FOR    \ LOOP NAMES 5 XSC LOOPS  ] (DO TO (DO (LP TO (LP (FOR  @BRAN LUP. ;M        #NAME STRG. ," " ," ."  ," A"        \ STRINGS COMPILE ?        : DOES? DUP C@ 232 = IF 1+ STR + [ ' STRG. @ 1+ STR + ]            LITERAL - THEN ;                                             : /END LA ADR U< IF 1 TO EF THEN ;                              3 XSC STRG ] (" (". TO ABORT ADR TO HW  BADR ADR + TO ADR /1PAS   HW C@ NEWLN? STRG. HW ". 34 EMIT SPACE ;M    -->                                                                                                                                                                                                              : IX? BEGIN SCP HW - WHILE SADR IF 1 ;THEN  REPEAT 0 ;          #NAME FWD. ," SKIP  ," IF  ," -IF  ," OF                        #NAME BWD. ," AGAIN ," UNTIL ," -UNTIL                                     ," REPEAT ," ELSE ," BEGIN ," THEN                   4 XSC BRANC  ] (BR TO (BR AT (BR  (OF                             @BRAN PS -IF NA  !ADR ;THEN  LW LIT (BR - 0;                    ADR 1- NA U< IF NEWLN FWD. 2 TAB+ ;THEN -2 TAB+ BWD. NEWLN ;M : TBS! 2@ TO SCP TO HW ;                                        : TBS? TO IX 0 BEGIN TO CSP IX? WHILE  BWD. CSP 2+ REPEAT ;     : THENS.  /1PAS  AT FSTK TBS! IX? 0; 6 -2  LW LIT (BR =          IF 2DROP 3 -4 ADR 1- NA U< IF 2DROP 4 0 THEN THEN                      TAB+ NEWLN TO IX BWD. 6 TBS? CSP NEGATE TAB+ ;          : BEGINS.  /1PAS  AT BSTK TBS!  5 TBS? CSP TAB+ ; -->                                                                                                                                                                                                           : BEG?  ADR 2- 1A - ; : BEG. 1A ID.OK ;                         : SPEC  LIT ;code LW = IF ADR DOES?                                  -IF 3 AT ADR +! /1PAS ." DOES> " ;THEN /END THEN              LIT [ '@, QUIT ] LW @ = IF /END THEN                             PS 0; LW ID.OK 7  NEWLN? ;                                  #NAME OTHER. ," NEXT ," ". ," 2DUP ," 2DROP ," CNTDO             ," 1+! ," 2+! ," 1-!  ," 2-! ," 1-!@  ," 2-!@ ," @1+! ," @2+!   ," -ROT ," RDROP ," +! ," COMPILE                              17 XSC OTHER ] TO (FOR AT (" TO DUP TO DROP AT (DO        \ 5    TO 1+  TO 2+  TO 1-  TO 2-   AT 1-  AT 2-  AT 1+  AT 2+ \ 13     TO ROT  AT DROP  AT +  TO ,                            \ 17         OTHER. ;M              -->                                                                                                                                                                                                                                                                                                #NAME COMP. ," BCOMPILE                                         1 XSC COMP ] BCOMPILE  \ COMPILE        \ WORD COMPILE ?          BWADR TO NA  /1PAS COMP.                                        IX IF NA ID.OK EXIT THEN ." [ " NA #. ."  C, ] "  ;M          \ #NAME NLIT. ," BLIT ," LIT ," DLIT                            3 XSC NLIT ]  BLIT LIT DLIT      \ BYTE COMPILE ?                 BWADR  WDADR TO HW TO NA  /1PAS                                 NA HW D. IX 1- 0= 256 NA U< AND IF                                       ." ( " NA ID.OK ." ) "  THEN ;M                      #NAME STARTS. ," FUNC: ," ->: ," :TR-  ," :                                   ," :1 ," :2  ," :3 ," :4                          8 XSC STARTS  '@, ID.OK '@, QUIT '@, ?? '@, XSC 1-, 1-, 1-, 1-,  ]  BEG? 5 U< -IF /END THEN                                         /1PAS  STARTS.  BEG? -IF BEG. THEN ;M  -->                                                                                  ( PROBA ID.OK                                                 ) #NAME /END. ," EXIT ," RETURN ," ?TR;                           3 XSC ENDS ] EXIT  RETURN  AT NOOP   \  EXIT ?                      /END  /1PAS  EF IF ." ; " ;THEN /END. ;M                    : 1I THENS. BEGINS. WADR TO LW  STARTS OTHER                           COMP STRG NLIT LOOPS ENDS BRANC  SPEC ;                   |  ( -HEADERS OFF )                                            : PAS TO PS 1A TO ADR  0 TO EF  -1 TO LW  BEGIN 1I EF UNTIL ;   : @HACK DECIMAL CR TO 1A  0 TO TAB  0 TO LA  PAD 1K 2* +             DUP 1K + DUP AT BSTK 2! DUP AT FSTK 2!                          1A @ DOES? -IF 1A ID.OK ;THEN       0 PAS 1 PAS ;          | : @@@ CREATE C, DOES> C@ ' + @HACK ;   0 @@@ HACK               2 @@@ 'HACK   4 @@@ "HACK   : >ADR  ADR @HACK ;               | : @@ CREATE C, DOES> C@ ' + STR PUSH 1H DUMP POP 3+ @HACK ;   0 @@ >>   2 @@ TO>  4 @@ AT>                                    PRUNE                                                           ( PRUNED DICTIONARY ???????  % SWITCH  <%  %>              )                                                                        -HEADERS                                                                 VARIABLE %!%                                       ' HEADER 6 + CONSTANT %?%                                       :  #% @ IF %!% %?% VSWAP THEN TO VSWAP ;                             HEADERS                                                    : <%  0 %!% ! %?% #% ;    ( START HI - CODE WITH NAMES)         : %>  %!% #% ;            ( END HI - CODE)                      | : >BASE CREATE C, IMMEDIATE DOES> BASE PUSH C@ TO BASE                  BLWORD  NUM ?? ?LITERAL POP TO BASE ; IMMEDIATE         16  >BASE $    10  >BASE #   2 >BASE %                           PRUNE           EXIT                                                                       0 QUAN ADDR                       : PATTERN TO ADDR 256 0 DO I 6 FOR DUP                              AT ADDR @1+! C! NEXT DROP   LOOP ;                          ( INDEX                                                      )  : INDEX SCR + SCR DO CR I BLOCK I .LINE I 1+ TO SCR LOOP ;      : LISTS 1+ SWAP DO I LIST LOOP ;                                EXIT : STK>MEM SWAP TO AR  FOR !+ NEXT ;                        : MEM>STK SWAP TO AR  FOR @+ NEXT ;                             : MEM>STK2 TUCK 2* + SWAP FOR 2- TO AR @+ AR 2- NEXT DROP ;     : CMOVE0 ROT TO AR FOR PUSH TO @+ TO !R+ POP NEXT 2DROP ;       : CMOVE3 ROT PUSH TO AR BEGIN WHILE 1- TO A@ TO !R+ REPEAT         RDROP ; : L@ TO AR @+ @+ ;  : C!+ DUP 1+ -ROT C! ;           : P>MOVE -ROT POP 2>R TO AR ;                                   : MOVE2 P>MOVE BEGIN ?DUP WHILE @+ !R+ 1- REPEAT RDROP ;        : CMOVE4 P>MOVE BEGIN ?DUP WHILE TO @+ TO !R+ 1- REPEAT RDROP ; : MYSCAN2 TO CSP FOR COUNTW CSP = IF 2- LEAVE THEN               NEXT DUP - ; : CMOVE1 SWAP TO AR FOR COUNT TO !+ NEXT DROP ;   : CMOVE2  FOR PUSH COUNT POP C!+ NEXT 2DROP ;                                                                                   ( DEM - DOMAIN EMPTY  EMP - EMPTY ELEMENT  ELM - ELEMENT      ) : 0# 0. ; : -1# -1. ;  : >NUM S>D SWAP ;  : >ADR ?CS: SWAP ;    : NN>AA SWAP >ADR ROT >ADR 0 ;     : 2VARIABLE VARIABLE 0 , ;   : D+! DUP PUSH D@ D+ POP D! ;      : M+! SWAP S>D ROT D+! ;     : 0#>< 0# 2SWAP ;  : 0>< 0 SWAP ;  : >DSC 0#>< 0>< 0 ;               0 VALUE BRKF : ?BRK BRKF IF BREAK. THEN ;  : ?D D@ D. ;    | : A-F: PUSH : POP C, DOES>  COUNT PUSH EXECUTE POP ?BRK FUNA ; 5. 4. 3. 2 1 CLASS: DESCR  F: OFFS ;F AT FA  F: ELEM ;F AT FA    F: DOMN ;F AT FA F: APPE ;F ,   F: APPL ;F ,    ;CLASS        : AOPEN ( "A N N ) ROT >ADR 2SWAP 218 ?BRK FUNA ;               : ?ARCH  ( N N ) 0# 0# 22  ?BRK  FUNA TO ARES 2 XOR ;           : SYS" =" "PUSH ">'  0# AOPEN ;                                 : ?NEL   ( -- F ) ARES AND 1+ 0= ;                              : ACLOSE ( N N ) 2>R 0 SP 2R> AOPEN DROP ;                      : ?-AUTO ( N N ) 0= SWAP 0= OR ;  1 5 +THRU    PRUNE                                                                            ( ARM OBJECT   A - ADDRESS  A' - DSC ADDRESS  N,D - NUMBER   )  METHOD: DESCR    : DSC>A ?CS: APPL ; : <DSC DSC>A 2SWAP ;     : SHOW APPL ? APPE ? DOMN ?D ELEM ?D OFFS ?D ; : OFFS! OFFS D! ;   : DSC!  APPL 2! DOMN D!  ELEM D!  OFFS! ;                      | : A-U CREATE 200 + C, DOES> C@ DSC>A ROT ?BRK FUNA ;             0 A-U PREVDEM   1 A-U PREVDOM  2 A-U NEXTDEM  3 A-U NEXTDOM     4 A-U PREVEMP   5 A-U PREVELM  6 A-U NEXTEMP  7 A-U NEXTELM  : >RD PUSH APPL SWAP NN>AA POP ; : >WR PUSH APPL NN>AA POP ;     5 A-F: READEL ( A' A  N) >RD ; 6 A-F: OWRITE ( A  A' N) >WR ;  18 A-F: ARCHI ( A) DUP >RD ;                                    12 A-F: IWRITE ( A A'N) >WR ; 15 A-F: SETLEN ( A'D) <DSC 0#>< ;  14  A-F: FULNAM ( A A   N ) PUSH NN>AA POP ;                    10  A-F: DEFDOM ( A A'  N ) PUSH 0# DSC>A POP >NUM ;            20  A-F: MOVELM ( A' D 0. ) SWAP <DSC 0# ;                     ;METHOD  \ : SB>W DUP >< S>D NIP PACK ;                                                                                         ( ARM STRUCTURES   "A C-STRING ADDR   RESULT IN ARES          ) : DESCR. [SEND] DESCR SHOW ;      RELINK  SYS" SOMEHOW.DAT"      0. 0. 0.  0  1  DESCR  DSC2    DSC2  SELF                       0. 0. 0.  0  0  DESCR  DSC1    DSC1                              TO FORTH  SELF CONSTANT SRC    CONSTANT DST                   METHOD: DESCR      : !CREATE  CREATE C, , DOES> OFFS D@ 2>R       COUNT B>D  OFFS!  PERFORM  2R> OFFS! ;                         ' IWRITE -1 !CREATE !INSEL   ' IWRITE -2 !CREATE APENDEL               : GETLEN -1# SETLEN ;   : DELEM   0# SETLEN ;                   : DELDOM  0  DEFDOM ;   : GETDOM -1  DEFDOM ;           : +ARCH 2DUP 2>R ?-AUTO A" AUTO?"       ( ÄÇíéåÄíàóÖç ãà Ö?)            2R@ ?ARCH IF 2R@ ACLOSE THEN    ( áÄíÇÄêüçÖ ?)                  2R> 0 >DSC DSC! ( ëöáÑÄÇÄçÖ ë èêÖÑÇÄêàíÖãçé àáíêàÇÄçÖ)          COUNT PAD SWAP  FULNAM       ( èöãçé àåÖ)                       PAD    TO ARES  !INSEL ; ( ëöáÑÄÇÄçÖ çÄ ÖãÖåÖçí)        ;METHOD                                                                                                                         F83                                                             : PAD. PAD STR TYPE ;                                           2VARIABLE ADOMAINS   2VARIABLE   ELEMENTS                           1 VALUE SFLAG    2VARIABLE  AELEMENTS                       : TOTAL CR ." DOMAINS = " ADOMAINS D@ D.                                ."   ELEMENTS = " AELEMENTS D@ D. ;                                                                                     ( : !DSC TO AR SWAP 4 FOR SWAP !+ !+ NEXT ;)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( READSTR                                                     ) METHOD: DESCR                                                   : SREAD PAD DUP 2+ 1L READEL  TO ARES SWAP! ;                   : SEVAL SREAD PAD STR "EVAL ;                                   : SWRITE =" !INSEL ; : SHOWIT SHOW SREAD PAD. ;                 | : <-> CREATE C, , DOES> COUNT B>D ROT PERFORM D+! SHOWIT ;       ' DOMN  DUP 1 <-> +D    -1 <-> -D                               ' ELEM  DUP 1 <-> +E    -1 <-> -E                            : DOM. -1# ELEM D!  0# ELEMENTS D! BEGIN NEXTELM ?NEL             -WHILE SFLAG IF CR SHOWIT THEN 1 ELEMENTS M+! REPEAT ;        : ARCH. -1# DOMN D!  0# AELEMENTS D!  0# ADOMAINS D!              BEGIN NEXTDOM ?NEL -WHILE DOM.  ELEMENTS D@ AELEMENTS D+!          1 ADOMAINS M+! REPEAT ;                                    ;METHOD                                                                                                                                                                                                                                                         METHOD: DESCR                                                    13 A-F: COPYELI ( A A' N) >WR ; ' COPYELI -1 !CREATE !ELCOPY     7 A-F: COPYELO ( A A' N) >WR ;                                 16 A-F: COPYDOM ( A A' A) >WR NIP >ADR ;                        17 A-F: COPYARC ( A A' A) >WR NIP >ADR ;                       ' COPYDOM -1 !CREATE !DOMCOPY   ' COPYARC -1 !CREATE !ARCOPY     : !>TMP T.NAME 0 1 AOPEN SREAD ;                                : #CL PAD STR OWRITE 0 1 ACLOSE ;                              ;METHOD                                                         F83   : ##1 [SEND] DESCR !>TMP ;   : ##2 [SEND] DESCR #CL ;          : >TMP SRC ##1  DST ##2 ;                                       : TMP> DST ##1 SRC ##2 ;                                                                                                                                                                                                                                   ( 8 QUINS PROBLEM                                            )  8 CONSTANT Q8  -HEADERS : 1! 1 SWAP C! ;  : 0! 0 SWAP C! ;                 Q8 DUP + DUP BARY DIAG1   BARY DIAG2                  Q8 BARY ROW   Q8 BARY FROW   VARIABLE CNT                      : ZPRINT  CNT @ 8 MOD -IF  CR ELSE SPACE SPACE THEN                          0 DO DUP I + C@ ALPHA EMIT LOOP DROP ;             | : PRINT  1 CNT +! 0 ROW Q8 ZPRINT ;                           FUNC: QUINS ( X )                                                 X Q8 = IF PRINT RETURN THEN      Q8 0                           DO    I FROW C@  X I + DIAG1 C@  Q8 I - X + DIAG2 C@   OR OR      -IF I FROW 1!  X I + DIAG1 1!  Q8 I - X + DIAG2 1!                    I 1+ X ROW C!    X 1+ RECURCE  X ROW 0!                       I FROW 0!  X I + DIAG1 0!  Q8 I - X + DIAG2 0!              THEN                                                          LOOP ;                                                          PRUNE                                                         ( 8 QUINS PROBLEM                                            )  8 CONSTANT Q8  : 1! 1 SWAP C! ;  : 0! 0 SWAP C! ;                          Q8 DUP + DUP BARY DIAG1   BARY DIAG2                  Q8 BARY ROW   Q8 BARY FROW   VARIABLE CNT  0 VECTOR TSR        : ZPRINT  CNT @ 8 MOD -IF  CR ELSE SPACE SPACE THEN                          0 DO DUP I + C@ ALPHA EMIT LOOP DROP ;             : PRINT  1 CNT +! 0 ROW Q8 ZPRINT ;                             FUNC: QUINS ( X / RA CM ) ( TEST SET RESET  RET ADR/COMMAND)    SKIP [  USE:  POP STR TO CM TO RA I FROW CM EXEC  X I + DIAG1    CM EXEC Q8 I - X + DIAG2 CM EXEC  RA PUSH ;M   TO TSR ] THEN     X Q8 = IF PRINT RETURN THEN      Q8 0                           DO    TSR C@   OR OR  -IF TSR 1!                                I 1+ X ROW C!    X 1+ RECURCE  X ROW 0!   TSR 0!  THEN LOOP ;                                                                                                                                                                                                 ( 8 QUINS PROBLEM                                            )  8 CONSTANT Q8  : 1! 1 SWAP C! ;  : 0! 0 SWAP C! ;                          Q8 DUP + DUP BARY DIAG1   BARY DIAG2                  Q8 BARY ROW   Q8 BARY FROW   VARIABLE CNT  0 VECTOR TSR        : ZPRINT  CNT @ 8 MOD -IF  CR ELSE SPACE SPACE THEN                          0 DO DUP I + C@ ALPHA EMIT LOOP DROP ;             : PRINT  1 CNT +! 0 ROW Q8 ZPRINT ;                             FUNC: QUINS ( X / IDX ) ( TEST SET RESET  RET ADR/COMMAND)      SKIP [ USE: POP STR TO TSR PUSH IDX FROW TSR  X IDX + DIAG1 TSR Q8 IDX - X + DIAG2 TSR ;M  ' ALIAS >MAC DO-TSR ] THEN             X Q8 = IF PRINT RETURN THEN      Q8 0                           DO  I TO IDX   DO-TSR C@   OR OR  -IF DO-TSR 1!                 I 1+ X ROW C!    X 1+ RECURCE  X ROW 0!   DO-TSR 0!            THEN LOOP ;                                                                                                                                                                                    ( 8 QUINS PROBLEM                                            )  8 CONSTANT Q8 -HEADERS  Q8 DUP + DUP BARY DIAG1   BARY DIAG2     Q8 BARY ROW   Q8 BARY FROW   0 VALUE CNT                       : TSR: : DOES> SKIP THEN ; RECOVER HERE 2- TO CNT               TSR: TEST C@ OR ;  TSR: SET 1 SWAP C! ; TSR: RESET 0 SWAP C! ;  | : PRINT  CNT 1+ TO CNT 0 ROW Q8  CNT                          [ 80 Q8 2+ / ] LITERAL MOD IF SPACE SPACE ELSE CR THEN                             0 DO DUP I + C@ ALPHA EMIT LOOP DROP ;       FUNC: QUINS ( X / IDX ) ( TEST SET RESET  RET ADR/COMMAND)      SKIP [ HERE CNT ! ]   PUSH X ROW C! IDX FROW R@ XCALL             X IDX + DIAG1 R@ XCALL Q8 IDX - X + DIAG2 POP XCALL ;M ] THEN                                                                   X Q8 = IF PRINT RETURN THEN  BEGIN  0 0 TEST                     -IF IDX 1+  SET  X 1+ RECURCE  0 RESET  THEN                   IDX 1+ DUP TO IDX Q8 = UNTIL ; 0 TO CNT    PRUNE                                                                              ( 8 QUINS PROBLEM                                            )  FUNC: QUINS ( X / IDX ) SKIP [ -HEADERS                         8 CONSTANT Q8 Q8 DUP + DUP BARY DIAG1  BARY DIAG2  Q8 BARY ROW  Q8 BARY FROW ( TEST SET RESET ) 0 NM: PUSH IDX FROW R@ EXECUTE    X IDX + DIAG1 R@ EXECUTE Q8 IDX - X + DIAG2 POP EXECUTE ;M          HEADER    TEST , ] C@ OR ;M                                 ' TEST LIKE   SET_   ] 1 SWAP C! ;M                           | ' SET_ LIKE   RESET  ] 0 SWAP C! ;M                           MAC: SET IDX 1+ X ROW C! SET_  ;                                MAC: END? IDX 1+ DUP TO IDX Q8 = ;                              MAC: TRY  0 TEST -IF  SET X 1+ RECURCE RESET THEN ;             MAC: TAB? Q8 78 OUTC - U< IF SPACE SPACE ELSE CR THEN ;         MAC: PRN? IDX 1+ Q8 = IF TAB? THEN ;                            MAC: PRINT IDX ROW C@ ALPHA EMIT PRN? ; ] THEN                  BEGIN X Q8 = IF PRINT ELSE TRY THEN END? UNTIL [ PRUNE ] ;                                                                      ( MACRO DEFINITIONS ENABLED                                  )  TO FORTH                                                        : COPY C" | EMIT SWAP . . ; 1024 CONSTANT 1K                    : MLOAD ARGS( ADDR ) 1+ SWAP  ( STARTBLK ENDBLK ADDRESS )         DO I BLOCK 1K AT ADDR @+! 1K CMOVE LOOP /ARGS ;               : MSAVE ARGS( ADDR ) 1+ SWAP                                      DO 1K AT ADDR @+! I BLOCK 1K CMOVE UPDATE LOOP /ARGS ;        : COPYBLK ARGS( FROMBLK ENDBLK TOBLK / DISP CNT )                  TOBLK 1+ FROMBLK - TO CNT  FROMBLK TOBLK - TO DISP              DISP 0< IF CNT FOR FROMBLK I' + TOBLK I' + COPY NEXT              ELSE CNT 0 DO FROMBLK I + TOBLK I + COPY LOOP THEN           /ARGS ;                                                       ( ATTRR                                                       ) : TEST ATTR C@ PUSH  128 0 DO I ATTR C! PAGE I . KEY B>W CTRL          ] = IF LEAVE THEN LOOP POP  ATTR C! ;                                                                                    ( TEST MACRO LOCALS                                           )                                                                 : TESTM 3 2 PACK LOCALS/                                             CR CR L1@ . L2@ . L3@ . L4@ . L5@ .                                                                                             1 L1! 2 L2! 3 L3! 4 L4! 5 L5!                                   CR CR L1@ . L2@ . L3@ . L4@ . L5@ .                                                                                             10 L1 !  20 L2 ! 30 L3 ! 40 L4 ! 50 L5 !                        CR CR L1@  .  L2@ .  L3@ .  L4@ .  L5@ .                        CR CR L1 @ . L2 @ . L3 @ . L4 @ . L5 @ .                            /LOCALS                                                ;                                                                                                                                                                                                                                                               ( TEST LOCALS( PROC                                          )  FUNC: FAC ( N )  N 2 < IF 1 RETURN THEN N N 1- RECURCE * ;      FUNC: FIB ( N ) N 2 < IF N RETURN THEN N 2- RECURCE                  N 1- RECURCE + ;                                           FUNC: HANOJ ( P1 P2 P3 N ) AT N 1-!@ IF                               P1 P3 P2 N RECURCE   P1 P2 P3 1 RECURCE                         P2 P1 P3 N RECURCE ELSE CR ." FROM "                        P1 .  ." PILON TO " P3 . ." PILON" THEN  ;                                                                                    : HANOJ2  (  S_PILON 0..2   D_PILON 0..2    DISKS 1..20 )         1- ?DUP IF TO RS  TO DUP OVER OR 3 XOR AT RS  RECURCE                          TO DUP 1                  RECURCE                          SWAP OVER OR 3 XOR SWAP  RS    RECURCE                        ELSE CR ." Move Disk From Pilon  " SWAP 1+ .                            ."   To Pilon  " 1+ .   THEN   ;                                                                              ( TASKS TEST                                                  ) : MULTI ['] (PAUSE TO PAUSE ; : SINGLE ['] NOOP TO PAUSE ;      : WAIT FOR PAUSE NEXT ; : WAIT2 FOR R@ WAIT NEXT ;              FUNC: FTASK ( XX YY NN SS )  BEGIN  XX YY GOTOXY NN DUP H. SS +  TO NN  700 WAIT  AGAIN ;   RECOVER ( NEVER EXITS HERE )           ' (PAUSE  2+  LIKE WAKE     31 LOAD                             OPER TSTART                                                  : .TASK DUP OPER = IF DROP ." OPER " EXIT THEN 2- ?ID. ;        : .TE DUP H. DUP .TASK WCOUNT ?ID. WCOUNT .TASK @ .TASK ;       : TLIST 0 OPER DUP LOCALS( CNT TS TP )  BEGIN CR                  CNT 5 .R SPACE TP .TE TP 2+ @ DUP TO TP TS =  AT CNT 1+!        UNTIL CR CNT  5 .R ."  TASKS" /LOCALS ;                       80 180 TASK T1       70 03 1000 1 ' FTASK 5 T1 TINIT            80 180 TASK T2       70 05 -1  -1 ' FTASK 5 T2 TINIT            CR T1 +TASK  TLIST  CR T2 +TASK  TLIST                              T1 TSTART  T2 TSTART                                        ( CATCH THROW POINT                                           )  U0 CONSTANT OPER  ' (BR LIKE STOPPED                           ( CATCH SP >R  HDR >R  RP TO HDR  EXEC                                  HDR TO RP  R> TO HDR RDROP      0 ;                     : THROW ?DUP IF  HDR >R  RS TO HDR  RS  SWAP  TO RS                 TO SP DROP RS THEN ; ) : 2+D 2+ SWAP 2+ SWAP ;              : TSTART LIT WAKE SWAP! ;  : TSTOP LIT STOPPED SWAP! ;          : TINS ( T2 T1 T3 ) OVER 2+D 2+D VSWAP 2+D VSWAP ;              : TASK CREATE >MARK DUP TSTOP DUP , , >MARK >MARK DROP >MARK     LOCALS( RN DN ^1 ^2 ) 1K 16 * NEGATE , 10 , 8 ORIGIN+             -1 ORIGIN+  @ 2/  8 - NW,                                      DN CLARY HERE DUP ^1 2! RN CLARY HERE ^2 ! /LOCALS ;          FUNC: ?TASK ( T / TP )                                            OPER  BEGIN 2+ @ DUP TO TP OPER - WHILE                           TP T = IF T RETURN THEN TP REPEAT 0 ;  -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (  LOAD  THRU  +TRUE EQU  ?LOAD                               ) : LOAD BLK >R >IN >R 0 TO >IN TO BLK                                 INTERPRET  R> TO >IN  R> TO BLK ;                          : THRU  1+ SWAP DO I LOAD LOOP ;                                : +THRU 1+ BLK + SWAP BLK + DO I LOAD LOOP ;                                                                                    : EQU >IN >R -FIND 0= IF                                             R> TO >IN CREATE , [ HERE 2+ TO CSP ] DOES> @ EXIT              ELSE AT DROP  AT , [ CSP , ]                                  OVER @ - A" !=EQU" 2+ ! THEN ;                               (  conditional compilation)                                     : ?LOAD ( scr flg -) IF LOAD ;THEN DROP ; ( conditional)        : MATCH? ( a a - f)  ( end of input stream counts as a match)     OVER C@ IF DUP C@ 1+ -TEXT 0= ELSE DROP THEN  ;                                                                                                                                               ( ARM STRUCTURES                                              ) CLASS: DESCR        5. 4. 3. 2 1                                  F: OFFS ;F AT FA  F: ELEM ;F AT FA  F: DOMN ;F AT FA            F: APPE ;F ,     F: APPL ;F ,                                 ;CLASS                                                          METHOD: DESCR   : 2? FA D. ;                                     : SHOW APPL ? APPE ? DOMN 2?  ELEM 2? OFFS 2? ;                 : OFFS! OFFS TO FA ; : ELEM! ELEM TO FA ; : DOMN! DOMN TO FA ;  : OFFS@ OFFS FA ;  : ELEM@ ELEM FA ; : DOMN@ DOMN FA ;                                                                         ;METHOD                                                         : DESCR. [SEND] DESCR SHOW ;                                                                                                                                                                                                                                                                                                    ( ÉÄãü      ÑàåàíêéÇÄ     ÇÄëàãÖÇÄ      6507277249088334033147) ( ÇÄëàã     ÑéÅêéåàêéÇ    ÇÄëàãÖÇ       6106227249088334033147) ( ÑÖüç      ÇÄëàãÖÇ       ÑéÅêéåàêéÇ    8805197088088333872423) ( çàäéãÄâ   ÇÄëàãÖÇ       ÑéÅêéåàêéÇ    9001158686787688968768) CLASS: PERSON  2 10 10 14 14 10  \ SIZES OF THE FIELDS            F: AGE    ;F ALLOT   F: MOBILE ;F ALLOT    F: EGN  ;F ALLOT     F: FAMILY ;F ALLOT   F: SNAME  ;F ALLOT    F: NAME ;F ALLOT   ;CLASS  METHOD: PERSON  -HEADERS  : >F. CREATE C, , ," DOES>     COUNT PUSH  WCOUNT PUSH 8 OVER                                     C@ - TO MAX SPACES ". ."  : " POP EXEC POP TYPE ;            ' NAME   10 >F. NAME.   àåÖ    ' SNAME 14 >F. SNAME. èêÖáàåÖ    ' FAMILY 14 >F. FAM. îÄåàãàü   ' EGN   10 >F. EGN. ÖÉç          ' MOBILE 10 >F. MOB. åéÅàãÖç | ' AGE    2 >F. AGE. ÇöáêÄëí      : SHOW  CR NAME. CR SNAME. CR FAM. CR EGN. CR MOB. CR AGE. ;   ;METHOD  : PERS 1H /MOD  [ BLK ] LITERAL +  BLOCK  SWAP              1L * 2+  + [SEND] PERSON SHOW ;  PRUNE                     ( REUSE 'DROP  ?EXIST POSTPONE                              )   : POSTPONE -FIND DUP 0= ?? 1+ IF COMPILE COMPILE THEN , ;          IMMEDIATE    EXIT                                            : REUSE >IN TO RS BLWORD RS TO >IN ;  : 'DROP WORD DROP ;       : ?EXIST REUSE FIND NIP ;                                                                                                       F83     (  ROOTLINK-ADR WITH-ADR)                                                                                               \ : FIX-LINX BEGIN OVER TO >< ?DUP 0= UNTIL DROP ;              \ : NODE+ ( WITH-ADR ROOTLINK-ADR) TO >< , ;                    \ 0 NM: AT CURRENT N>C OVER FIX-LINX TO 0 ;M                    \ 1 NM: HERE NODE+ ;M HEADER RECURCE , , 0 , IMMEDIATE          : FAC DUP 2 < IF DROP 1 EXIT THEN DUP 1- RECURCE * ;                                                                                                                                                                                                            ( MYSELF HANOJ-II )                                             : ALIGN 1- SWAP 1- OR 1+ ;                                      EXIT                                                            : Z?STK PUSH BEGIN ?DUP WHILE R@ EXEC REPEAT RDROP ;            : P>MOVE -ROT POP 2>R TO AR ;                                   : MOVE2 P>MOVE BEGIN ?DUP WHILE @+ !R+ 1- REPEAT RDROP ;        : CMOVE4 P>MOVE BEGIN ?DUP WHILE TO @+ TO !R+ 1- REPEAT RDROP ;                                                                 : GET-ORDER ORDER# WCOUNT 2* CNTDO ?DO I @ 2 +LOOP                          CONTEXT ORDER# @ 1+ ;                               : SET-ORDER 1- DUP ORDER# ! SWAP TO CONTEXT                              FOR R@ 2* ORDER# + ! NEXT ;                            : SEARCH-WORDLIST >R "MAKE -1 SWAP R> FIND                         NEGATE DUP 0= IF NIP THEN ;                                                                                                                                                                  ( VECTOR MYSELF)                                                : \\ [',] \ ; IMMEDIATE                                         FUNC: HANOJ ( S_PILON T_PILON D_PILON DISKS )                   \  ( S_PILON .  T_PILON . D_PILON . DISKS .    )                \\ PROBA COMENTAR LI E ILI SHE GRAMNE                               AT DISKS AT 1-  (  DISKS--)                                     IF                                                                   S_PILON D_PILON T_PILON DISKS  RECURCE                          S_PILON T_PILON D_PILON 1      RECURCE                          T_PILON S_PILON D_PILON DISKS  RECURCE                     ELSE                                                                 CR ." Move Disk From Pilon  " S_PILON .                                  ."   To Pilon  "     D_PILON .                    THEN  ;  ( ' HANOJ TO MYSELF  )                                                                                                                                                             : BLONK BLOCK DUP 1K + SWAP DO I C@                                bl < IF bl I C! THEN LOOP UPDATE ;                            : BLONKS 1+ SWAP DO I BLONK UPDATE LOOP FLUSH ;                EXIT                                                            \ NAMIRA MIN I MAX NA 2 CHISLA                                  \ CHREZ FUNKCIA                                                 \ : MAX 2DUP - ABS + + 2 / ;  : MIN 2DUP - ABS - + 2 / ;        \ : MAX' 2DUP  -ABS + +2/ ;   : MIN' 2DUP  -ABS - +2/ ;         \ STRING SUM                                                    : S+  "TOP + S@ PAD S! "TOP S!+ "DROP "DROP PAD S@ "PUSH ;      : S" C" " WORD COUNT "PUSH ;                                    : [S" ;                                                                                                                                                                                                                                                                                                                         ( HANOJ-II )                                                    FUNC: HANOJ ( S_PILON T_PILON D_PILON DISKS )                       AT DISKS AT 1-  (  DISKS--)                                     IF   S_PILON D_PILON T_PILON DISKS  RECURCE                          S_PILON T_PILON D_PILON 1      RECURCE                          T_PILON S_PILON D_PILON DISKS  RECURCE                     ELSE CR ." Move Disk From Pilon  " S_PILON .                        ."   To Pilon  "     D_PILON .          THEN  ;         EXIT                                                            : FACT  ARGS( ARG )                                                 ARG 0<= IF  1  ELSE  ARG DUP 1- MYSELF * THEN /ARGS ;       : FACT2 ARGS( ARG )  1 ARG 0<= IF EXIT THEN                        ARG 1+ 1 DO I * LOOP /ARGS ;                                 : FACT3 DUP 0<= IF DROP 1 EXIT THEN DUP 1- RECURCE * ;          : FACT4 DUP 0<= IF 1 NIP EXIT THEN 1 SWAP 1+ 1 DO I * LOOP ;    : FACT5 1 SWAP DUP 0<= IF DROP EXIT THEN FOR R@ 1+ * NEXT ;     (  CELL SIZE LEN STRING  WORDS                                ) TO HIDDEN  : "T SPTR STR ; ( -- A N )   : "N SPTR STR + STR ;   : "DROP "T + TO SPTR ; : "POP ( A --) "T ROT SWAP CMOVE "DROP ; : "ALLOT DUP 2+ AT SPTR TO @+! ; ( N -- N A )                   : "BUFF ( C N -- ) "ALLOT ! "T ROT FILL ;                       : "PUSH ( A N -- ) "ALLOT OVER PUSH 2+ SWAP MOVE POP SPTR ! ;   : "INS  ( A N -- ) "T PUSH TO SPTR "PUSH POP SPTR +! ;          : C"INS SP 1 "INS DROP ;                                        : "CUT ( N --) "T ROT 2DUP 0 WITHIN -IF DROP DUP THEN ( A N N)     -ROT PUSH 2DUP + 2- TO SPTR SWAP "PUSH POP SPTR @ - "T + ! ; : "SWAP [ MAC: RVR TO /STR DUP PUSH REVERCE ; ] "N RVR  "T RVR     SPTR  POP POP + REVERCE ;   : "+ "SWAP "T "DROP "INS ;       : "EVAL 0 1 "BUFF "INS "T DROP EVAL "DROP ;    0. "PUSH           0.  "PUSH    ( EMPTY STACK ELEMENT )     TO FORTH             CREATE T.NAME ," TEMP.TXT   : ">OS bl +C' SWAP +' SHELL ;       : FED " EDT"  ">OS ;        : REMOVE " DEL" ">OS ;              (  EDITOR POSXY WIPE RELOAD SAVEBLK LB N B ARROW)                VOCABULARY EDITOR                                              ONLY FORTH ALSO  EDITOR  ALSO DEFINITIONS   0 VALUE XY           -HEADERS   0 VALUE CHG     0 VALUE INS   0 VALUE OLD_RP        : ~CHANGE 0 TO CHG ;     :  CHANGE 1 TO CHG ;                   : ?XY 1L U/MOD 4 2 TO + ; : POSXY XY ?XY GOTOXY ;               : /L 1L 1- OR ; ( LINE END) : L/ 1L NEGATE AND ;  ( LBEGIN)     : RDR HOME PAD .BLOCK ;   : LINE/ PAD XY L/ + ;                 : LDRAW POSXY LINE/ cr EMIT XY 1L / .LINE ;                     : WIPE PAD 1K BLANK CHANGE RDR ;                                : RLD SCR BLOCK PAD 1K CMOVE ~CHANGE RDR ;                      : SAVEBLK CHG IF PAD SCR BLOCK 1K CMOVE UPDATE ~CHANGE THEN ;   : LB SAVEBLK SCR + TO MAX TO SCR ;                              : L2 1K  XY - 1L - TO MAX ;      : POS^ PAD XY + ;              : /LINE PAD XY /L + ;         : LL /LINE POS^ - ;               : P2 POS^ DUP DUP 1L + ;                                        ( COPY POS^ LINE/ /LINE LDRAW EL INSC DELC OVTC INSL DELL LL  ) : LRUD: : DOES> XY SWAP EXECUTE 1K 1- AND TO XY ;               LRUD: L_UP   1L - ;     ( LINE UP)                              LRUD: L_DN   1L + ;     ( LINE DOWN)                            LRUD: L_END  /L ;       ( LINE END)                             LRUD: L_BEG  L/ ;       ( LINE BEGIN)                           LRUD: ->     1+ ;       ( MOVE 1 CHAR RIGHT)                    LRUD: <-     1- ;       ( MOVE 1 CHAR LEFT)                     LRUD: TAB>   7 OR 1+ ;  ( NEXT TABULATION )                     LRUD: <TAB 1- -8 AND ;  ( PREVIOUS TABULATION)                  LRUD: <_|    BLKNL ;    ( CARRIGE RETURN L_DN L_BEG )           LRUD: APOS   0 AND ;    ( HOME POSITION OF CURSOR)                                                                                                                                                                                                                                                                                                                                              : >EL 1K L2 - 1L MIN ; : EL >EL BLANK ; : RDRC RDR CHANGE ;     : DELL P2 SWAP L2 CMOVE L2 +  EL RDRC ; : OVTC POS^ C! CHANGE ; : >INSL P2 L2 TO CMOVE EL ; : INSL >INSL RDRC ;                 : POSC POS^ DUP 1+ ; : INSC INS IF POSC LL TO CMOVE THEN OVTC ; : DELC POSC SWAP LL CMOVE bl /LINE C! LDRAW CHANGE ;            : _INS [ 75 2 PACK ]  LITERAL UNPACK GOTOXY                        INS 0= DUP TO INS IF ." INS" ELSE ." OVT" THEN  ;            | : BS <- DELC ;   : /EDIT SAVEBLK FLUSH ;                      | : X-POS 0 18 GOTOXY OLD_RP TO RP ;                            | : Q/ED  /EDIT  X-POS ;                                        : L 959 XY U< IF 1 LB 0 TO XY THEN                                  XY 1L < IF WIPE THEN <_|                                        0 WORD COUNT 1L MIN LINE/   SWAP CMOVE ;                    | CREATE CTRLS 30 C,                                                                                                            ( ESC  ^S ^E ^H ^D ^N ^B ^L ^I ^M ^J ^K ^W ^X ^Y ^C ^V ^Q )     CTRL [ C,  CTRL S C,  CTRL E C,  bs C,      CTRL D C,           CTRL N C,  CTRL B C,  CTRL L C,  CTRL I C,  CTRL M C,           CTRL J C,  CTRL K C,  CTRL W C,  CTRL X C,  CTRL Y C,           CTRL C C,  CTRL V C,  CTRL Q C,  CTRL Z C,                          80 C,      77 C,      75 C,      72 C,      83 C,               79 C,      71 C,      73 C,      81 C,      82 C,               15 C,                                                       \  G  -  àáíêàÇÄ êÖÑ  à Éé èêÄôÄ Ç ëíêàçÉéÇàü ëíÖä              \  P  -  PASTE ÇåöäÇÄ êÖÑ çÄ åüëíéíé çÄ äìêëéêÄ                 \  C  -  äéèàêÄçÖ çÄ êÖÑ åÖëíà äìêëéêÄ ??  íÖäëíöí Ö Ç ëíê ëíä  : P "T NIP 0; >INSL POS^ "POP RDRC ;                            : C POS^ >EL L_DN "PUSH ;                                       : G C L_UP DELL ;  : N 1 LB RLD ;  : B -1 LB RLD ;                                                                                                                                              ( ESC  ^S ^E ^H ^D ^N ^B ^L ^I ^M ^J ^K ^W ^X ^Y ^C ^V ^Q )                                                                     | : ESQ/E EMPTY-BUFFERS X-POS ;                                                                                                 | CREATE OPER1 ]                                                Q/ED    INSL    DELL    BS      DELC  ( CONTROLS)               N       B       RLD     TAB>    <_|                             <-      ->      WIPE    G       _INS                            C       P       ESQ/E   APOS                                                                                                    L_DN    ->      <-      L_UP    DELC  ( FUNCTION KEYS)          L_END   L_BEG   B       N       _INS                            <TAB    [                                                                                                                                                                                                                                                                                                                                                                                       | : XKBD >R  CTRLS COUNT R> SCAN 1+ ?DUP                              IF 1- 2* OPER1 + AT EXEC THEN  ;                          TO FORTH                                                        : E [ HERE 2- @ , ] TO SCR RLD _INS _INS  RP TO OLD_RP              BEGIN POSXY KEY DUP B>W                                            IF B>W DUP 32 U<                                                    -IF  INSC  LDRAW ->  ELSE  XKBD THEN                        ELSE TO B>W XKBD THEN                                        AGAIN   ;  -2 ' E +!                                        : EDIT PAGE TO E ;                                              : HELP SCR PUSH TO E  POP  TO E ;                                                                                               | : HELPER CONSTANT DOES> @ HELP ;   110 HELPER HARM                                     PREVIOUS F83  PRUNE                                                                                    -MAC F83      ]                                                 MAC: RECOVER AT ALLOT;                                          MAC: >RESOLVE TO >MARK;                                         MAC: WCOUNT TO COUNT;                                           MAC: DABS TO ABS;                                               MAC: SCIND TO SCLST;                                            MAC: SCANW TO SCAN ;                                            MAC: WBLK TO NBLK;                                              MAC: VBLK AT NBLK;                                              MAC: OPEN TO FOPEN;                                             MAC: FCLOSE TO CLOSE;                                           MAC: ?EXEC TO EXEC;                                             MAC: PERFORM AT EXEC;                                           MAC: BLWORD TO WORD;                                                                                                                                                                            MAC: C@W TO C@;                                                 MAC: HOLD TO HLD;                                               MAC: BRANCH (BR;                                                MAC: ?BRANCH TO (BR;                                            MAC: DLIT TO D,;                                                MAC: COMPILE TO ,;                                              MAC: LIT AT ,;                                                  MAC: BCOMPILE TO C,;                                            MAC: BLIT AT C,;                                                MAC: RP! TO RP;                                                 MAC: CNTDO AT (DO;                                              MAC: 4TH> TO LEAVE;                                             MAC: BREAK. AT LEAVE;                                                                                                                                                                                                                                           MAC: CMOVE> TO CMOVE;                                           MAC: MOVE AT CMOVE;                                             MAC: DNEGATE TO NEGATE;                                         MAC: 2DROP TO DROP;                                             MAC: RDROP AT DROP;                                             MAC: 2DUP TO DUP;                                               MAC: TUCK AT DUP;                                               MAC: ?KEY TO EMIT;                                              MAC: HI TO B>W;                                                 MAC: 2OVER TO OVER;                                             MAC: PICK AT OVER;                                              MAC: D+ TO +;                                                   MAC: +! AT +;                                                                                                                                                                                                                                                   MAC: -ROT TO ROT;                                               MAC: ROLL AT ROT;                                               MAC: 2! TO !;                                                   MAC: 2@ TO @;                                                   MAC: 2SWAP TO SWAP;                                             MAC: FLIP ><;                                                   MAC: 1-! TO 1-;                                                 MAC: 1-!@ AT 1-;                                                MAC: 2-! TO 2-;                                                 MAC: 2-!@ AT 2-;                                                MAC: 1+! TO 1+;                                                 MAC: @1+! AT 1+;                                                MAC: 2+! TO 2+;                                                                                                                                                                                                                                                 MAC: @2+! AT 2+;                                                MAC: PC2+ TO PC1+;                                              \ MAC: (" AT PC1+;                                              MAC: XOR! TO XOR;                                               MAC: 0MIN TO MIN;                                               MAC: PACK TO UNPACK;                                            MAC: @UNPACK AT UNPACK;                                         MAC: D- TO -;                                                   MAC: CBAX TUCK * ROT + * +;                                     MAC: ROL4 4 ROLL;                                               MAC: ABCX ROL4 OVER * ROL4 + * +;                               \ MAC: HEAD HEADER;                                             MAC: 2^ TO SHIFT;                                               MAC: BASE. BASE 10 DECIMAL . TO BASE;                                                                                                                                                           MAC: | 1 TO HEADER;                                             MAC: HEADERS 0 TO HEADER;                                       MAC: -HEADERS -1 TO HEADER;                                     MAC: ON TO -1;                                                  MAC: OFF TO 0;                                                  MAC: AT-XY GOTOXY;                                              \ MAC: NOT, 1 XOR;                                              MAC: R>M AT 2/ ;                                                MAC: NOT -1 XOR;                                                MAC: FLD! TO C!;                                                MAC: FLD@ AT C!;                                                MAC: 0. 0 0;                                                    MAC: -1. -1 -1;                                                 MAC: LATEST AT CURRENT N>C;                                     MAC: RUN LATEST EXEC;                                                                                                           MAC: SMUDGE AT IMMEDIATE;                                       ( MAC: | NOOP;                                                  ( MAC: -HEADERS NOOP;                                           MAC: N>LINK N>C 2-;                                             MAC: V>LINK 2-;                                                 MAC: PUSH >R;                                                   MAC: 2>R TO >R;                                                 MAC: POP R>;                                                    MAC: 2R> TO R>;                                                 MAC: 2R@ TO R@;                                                 MAC: U/ U/MOD NIP;                                              MAC: UMOD U/MOD DROP;                                           MAC: -ABS AT ABS;                                               MAC: /STRING AT COUNT;                                                                                                                                                                          MAC: C. C@ EMIT;                                                MAC: REVERCE AT ><;                                             MAC: D! TO FA;                                                  MAC: D@ FA;                                                     MAC: 2, AT FA;                                                  MAC: B>D TO S>D;                                                [                                                               TO MAC: ! ;THEN EXIT THEN !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( DO A CALL  CALL A DOS FUNCTION   PERFORM INTERRUPT  #       ) 0 VALUE RAX  0 VALUE RBX  0 VALUE RCX  0 VALUE RDX  0 VALUE RFL                                                                 CREATE _INT HEX   ASM  21 #, INT, RET,   END-CODE               CODE _CALL BX DI MOV, ' RFL 4 + /// PUSH, POPF,                 ' RAX 4 + /// AX MOV, ' RBX 4 + /// BX MOV, ' RCX 4 + /// CX    MOV,  ' RDX 4 + /// DX MOV,  DI CALL,  AX ' RAX 4 + /// MOV,    BX ' RBX 4 + /// MOV,  CX ' RCX 4 + /// MOV,   DX ' RDX 4 + /// MOV,  PUSHF,  ' RFL 4 + /// POP,    BX POP, NEXT,   END-CODE    : DO_INT [ _INT 1+ ] LITERAL C! _INT _CALL ;                    : DO_DOS 21 DO_INT ;                                            : FSIZE 0 TO RCX  0 TO RDX 4202 TO RAX  SCRH TO RBX DO_DOS ;                                                                    : FCUT ( SCR) 1K M* TO RCX TO RDX  4200 TO RAX SCRH TO RBX         DO_DOS 0 TO RCX 4000 TO RAX DO_DOS ;         DECIMAL                                                                         (  BLOCKS TO FILE   297 314                              )                                                                      : C!ADR   PUSH COUNT R@ C! POP 1+ ;                             : !LINE   1L FOR C!ADR NEXT PUSH cr R@ C! POP 1+ ;              : !BLOCK  SWAP PUSH BLOCK POP 1H FOR !LINE NEXT NIP ;           : !BLOCKS 1+ SWAP DO I !BLOCK LOOP PAD 2- ! ;                                                                                   : FWRITE FLUSH SCRH TO HANDLES FOPEN TO SCRH                       PAD 2- STR OVER -  1K /MOD SWAP IF 1+ THEN                      FOR DUP DUP PAD -  1K / BLOCK                                       1K CMOVE UPDATE 1K FLUSH +                                  NEXT AT HANDLES TO SCRH ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    1 2 3 4 54                                                                                                                                                                                                                                                      1 2 3 4 54                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( DISASM   ADDR OF NAMES BYTEOP       NAME      TYPE  START  )                                                                                                                                                             0 VALUE REGO                         : REG! CREATE C, DOES> C@ TO REGO ;                             : WARY CREATE DOES> SWAP 2* + ;                                  WARY REGNAMES                                                   =' ALCLDLBLAHCHDHBHAXCXDXBXSPBPSIDIESCSSSDSGSFSS?S?"           COUNT STR,                                                      : N-AND CREATE C, DOES> C@ AND ; 199 N-AND 199AND                7  N-AND 7AND   1 N-AND 1AND   2 N-AND 2AND   8 N-AND 8AND     : .REG 7AND REGO + REGNAMES 2 TYPE ;                            0 REG! BREG!    8 REG! WREG!   16 REG! SREG!                                                                                                                                                                                                                    ( DISASM TABLE SCR 1                                   HEX    ) \ : CONST CREATE , IMMEDIATE DOES> @ STATE 0;  COMPILE LIT , ;  <%   \ CAREFUL   !!!                                            : ENUM 0 DO OVER EXEC DUP CONSTANT LOOP 2DROP ;                  ( A,MEM A,DX AL,R  AX,R BR,I8   WR,I16 BR S16 A,I8 STRG)       ' 1+  -1 22    ENUM                                                N,RMB   RM8,I8  RM,R                                         R16,M   M,I     RM,I16  RM,I8   RM16,I8 RM,S    RM              B1      A,I     R,I     A,M     WR      I16,I8                  BJ      LJ      WJ      I8      I16     SEG                                                                                     : ARITH, >IN PUSH 4 RM,R OPS, POP TO >IN 2 A,I OPS, ;           %>   ( END <%)                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( COMPLEX                                                     ) HERE 0 0  CLASS: COMPLEX   F: RE ;F ,   F: IM ;F ,  ;CLASS      METHOD: COMPLEX                                                  : @ RE @ IM @ ; : ! IM ! RE ! ; | : _MUL ROT * PUSH * POP + ;   : * 2OVER 2OVER ROT _MUL PUSH NEGATE _MUL POP ;                 : NEGATE PUSH NEGATE POP NEGATE ; : +  ROT + PUSH + POP ;       : - NEGATE + ;   : . SWAP . ." i" . ;  : ? @ . ;               ;METHOD    PRUNE  CR HERE SWAP - . .( BYTES LENGTH) CR          1 2 COMPLEX C1   C1 ?  0 0 COMPLEX C3                           3 2 COMPLEX C2   C2 ?  CR                                       CR    C1 @  C2 @ +  C3 !     C3 ?                               CR    C1 @  C2 @ -  C3 !     C3 ?                               CR    C1 @  C2 @ *  C3 !     C3 ?                               : ROT360 0 1 1 0 4 FOR CR 2DUP .  2OVER * NEXT 2DROP 2DROP ;    FORTH                                                                                                                           ( 286 MNEM  0-A1 1-A2 234-SH 5-G1 6-G2 7-G3)                                                                                    ," 0 ," 1 ," 2 ," 3 ," 4 ," 5 ," 6 ," 7                         ," ROL  ," ROR  ," RCL  ," RCR  ," RAR  ," SHL ," SHR           ," ADD  ," ADC  ," AND  ," XOR  ," OR   ," SUB  ," SBB  ," CMP  ," NOT  ," NEG  ," MUL  ," IMUL ," DIV  ," IDIV ," INC  ," DEC  ," LES  ," LDS  ," LEA  ," ESC  ," MOVMS                        ," CALL ," CALLF ," JMP ," JMPF   ," ARPL ," BOUND              ," XCHG ," PUSH ," POP  ," TEST ," MOV                                                 ," MOVMI  ," IMULMI  ," PUSHI            ," ADDI ," ADCI ," ANDI ," XORI ," ORI  ," SUBI ," SBBI ," CMPI           ," MOVRI                                              ," MOVA  ," TESTA                                               ," PUSHR ," POPR  ," INCR ," DECR ," XCHGR                      ," PUSHS  ," POPS                               -->                                                                             ( MNEMONICS 2) ," AL ," CL ," DL ," BL ," AH ," CH ," DH ," BH  ," AX ," CX ," DX ," BX ," SP ," BP ," SI ," DI                 ," ES  ," CS ," SS ," DS ," GS ," FS                            ," OFS  ," ADR  ," LOCK ," REP  ," REPZ ," PROT ," SAHF         ," <POP> ," <PUSH> ," POPF  ," PUSHF ," RET  ," RETF  ," IRET   ," CBW  ," CWD  ," INTO ," INT3  ," XLAT  ," LEAVE    ," NOP    ," CLI  ," STI  ," CLD  ," STD  ," CMC  ," CLC  ," STC          ," AAA  ," DAA  ," DAS  ," AAS  ," HALT ," WAIT ," LAHF         ," INT ," AAM ," AAD ," DFB ," INP ," OUTP ," IN ," OUT         ," MOVS ," CMPS ," SCAS ," LODS ," STOS ," INS  ," OUTS         ," JO   ," JNO  ," JB   ," JNB  ," JE   ," JNE  ," JBE  ," JNBE ," JS   ," JNS  ," JP   ," JNP  ," JL   ," JNL  ," JLE  ," JNLE ," JMPS ," JCXZ ," LOOP ," LOOPE ," LOOPNE ," CALLI ," JMPI     ," RETI ," RETFI  ," ENTER ," CALLFI ," JMPFI  ," ???                                                                                                                                           ( DISASM MAIN SCREEN                                          )  VOCABULARY DISASM   TO DISASM   ALSO DISASM                     0 QUAN IP                                                              \    -HEADERS                                                                                                           CREATE OPNAMES  -1 C,    ( SPECIAL 255 COUNT OF WORDS FIRST)      64 LOAD  ( OPNAMES)      <%                                   : IND? OPNAMES COUNT ROT SCLST ;                                : OP, TO WORD IND? 1+ ?DUP IF 1- C, ;THEN 1 ?? ;                : MO,  OP, 1- FOR  HERE 1- C@ C, NEXT ;                         : ROW,  8 FOR OP, NEXT ;                                        : [OP,] COMPILE BLIT OP, ; IMMEDIATE                            : VALUES FOR 0 VALUE NEXT ;                                     %>         =' ???" IND?  1+ OPNAMES C!                                                                   -->                                                                                    ( DISASM TABLE SCR 1                                   HEX   )  0 BARY OPTBL                                                    <% : ?OP CR BLK . HERE 0 OPTBL - DUP . H. ;  %>                  4 MO, ADD   2 MO, ADDI   OP, PUSHS    OP, POPS  ( 08)           4 MO, OR    2 MO, ORI    OP, PUSHS    OP, PROT  ( 10)           4 MO, ADC   2 MO, ADCI   OP, PUSHS    OP, POPS  ( 18)           4 MO, SBB   2 MO, SBBI   OP, PUSHS    OP, POPS  ( 20)           4 MO, AND   2 MO, ANDI   OP, ES       OP, DAA   ( 28)           4 MO, SUB   2 MO, SUBI   OP, CS       OP, DAS   ( 30)           4 MO, XOR   2 MO, XORI   OP, SS       OP, AAA   ( 38)           4 MO, CMP   2 MO, CMPI   OP, DS       OP, AAS   ( 40)          \ ?OP                                                            8 MO, INCR  8 MO, DECR   8 MO, PUSHR 8 MO, POPR ( 60) -->                                                                                                                                                                                                      ( DISASM TABLE SCR 2                                   HEX   )  ROW,  <PUSH>  <POP>  BOUND  ARPL   FS  GS  OFS  ADR      ( 68)  ROW,  PUSHI  IMULMI  PUSHI  IMULMI  INS  INS  OUTS  OUTS ( 70)  ROW,   JO    JNO   JB   JNB     JE  JNE   JBE  JNBE      ( 78)  ROW,   JS    JNS   JP   JNP     JL  JNL   JLE  JNLE      ( 80)  ROW,  0    0    1    1   TEST   TEST    XCHG    XCHG   ( 88)    ROW,  MOV   MOV   MOV  MOV   MOVMS   LEA   MOVMS   POP ( 90)      OP, NOP   7 MO, XCHGR                                ( 98)    ROW, CBW  CWD  CALLFI WAIT   PUSHF  POPF  SAHF  LAHF   ( A0)    4 MO, MOVA    2 MO, MOVS   2 MO, CMPS                  ( A8)    2 MO, TESTA   2 MO, STOS   2 MO, LODS   2 MO, SCAS     ( B0)                  16 MO, MOVRI                             ( C0)    ROW,  2  2  RETI  RET      LES  LDS  MOVMI  MOVMI      ( C8)    ROW, ENTER  LEAVE  RETFI  RETF  INT3  INT  INTO  IRET  ( D0)                                                              -->                                                                           ( NN = ESC 6)                                           ROW,   3   3   4   4   AAM   AAD  ???  XLAT          ( D8)      ROW,   ESC  ESC  ESC  ESC  ESC  ESC   ESC   ESC      ( E0)      ROW, LOOPNE LOOPE LOOP JCXZ  INP  INP  OUTP  OUTP    ( E8)      ROW, CALLI  JMPI JMPFI JMPS  IN   IN   OUT   OUT     ( F0)      ROW,  LOCK   ???   REP    REPZ   HALT   CMC   5   5  ( F8)      ROW,  CLC    STC    CLI   STI    CLD    STD   6   7  ( 100)      ?OP                                                            ROW,   ADD  OR   ADC  SBB  AND  SUB  XOR  CMP                   ROW,   ADD  ???  ADC  SBB  ???  SUB  ???  CMP                   ROW,   ROL  ROR  RCL  RCR  SHL  SHR  ???  RAR                   ROW,   TEST ???  NOT  NEG  MUL  IMUL DIV  IDIV                  ROW,   INC  DEC CALL CALLF JMP  JMPF PUSH ???                   ROW,   INC  DEC CALL CALLF JMP  JMPF PUSH ???                          0 C, 1 C, 2 C, 2 C, 2 C, 3 C, 4 C, 5 C,                                                            -->                   ( OPERATION GROUPS )                                            0 BARY GROUPS ( SECONDARY BYTE OPCODE GROUPS)                     OP, 0       ( GROUP OF GROUPS 0)                                OP, ROL     ( MEM/R,R    1 )                                    OP, LES     ( R,MEM      2 )                                    OP, MOVMS   ( MEM/R,IMM  3 )                                    OP, MOVMI   ( MEM/R,IMM  3 )                                    OP, ADDI    ( A,IMM      4 )                                    OP, MOVRI   ( R,IMM      5 )                                    OP, MOVA    ( A,MEMORY ADDRESS  6 )                             OP, PUSHR   ( WORD REGISTER OPERATION ONLY  7 )                 OP, PUSHS   ( SEGMENT REGISTER OPERATION ONLY  8 )                                                      -->                                                                                                                                                                                                                   ( GROUPS   SECOND )                                             OP, AL OP, ES ( ONE BYTE OPCODES PREFIX  9 10)                    OP, SAHF    ( ONE BYTE OPCODES ONLY    11)                      OP, INT     ( ONE BYTE IMMEDIATE       12 )                     OP, INP     ( AREG ONEBYTE IMMEDIATE   13 )                     OP, IN      ( AREG STRING OPERATIONS   14)                      OP, JO         ( ONE BYTE RELATIVE BRANCH  15 )                 OP, CALLI      ( TWO BYTES RELATIVE BRANCH 16 )                 OP, RETI       ( IMMEDIATE  16             17 )                 OP, ENTER      ( IMM 16 , IMM 8            18 )                 OP, CALLFI     ( IMM 16 , IMM 16 SWAPPED   19 )                  -1 C,  ( NO OPERATION ASSIGNED - DEFINE BYTE / END)                0 QUAN FLAGS                                                                                          -->                                                                                                                                                 ( OP PROCS                                                    ) 10 VALUES OPC  OPI  DISP  IMMED  RMF  MF  RF IP1  GNI  GADR     : _OP. OPNAMES 1+ SWAP TO SCLST ". ;  : @BYTE AT IP  AT 1+ C@ ; : @WORD AT IP AT 2+ @ ;            : @SBYTE AT IP AT 1+ TO C@ ; : F-SET FLAGS OR TO FLAGS ; : F-CLR -1 XOR FLAGS AND TO FLAGS ; : F-GET FLAGS AND ;         : F-FLIP FLAGS XOR TO FLAGS ;       : XREG CREATE DOES> C@ SWAP [OP,] 7 AND + [OP,] AL + _OP. ;       XREG BREG. 0 C,  XREG WREG. 8 C,  XREG SREG. 16 C,            0 NM: @ F-SET ;M 1 NM: @ F-GET ;M  2 MAKER XSET ,                1 XSET XW   2 XSET XD   64 XSET XM                             256 XSET XO   512 XSET XWO  4 XSET XIS  16 XSET XA              128 XSET XR   32  XSET XI   8 XSET XG                           ( VARIABLE DISP   VARIABLE FLAGS  ( xxxxcc#ORMIAGSDW )          ( M=r/m; cc=reg count; I=immediate; A=accumulator; G=seg;)      ( S=imm.size; D=direction;  W=word or byte; R= REGISTER )       ( #=DISP.SIZE O=ONLY.DISP)                      -->             ( MOD R/M FIELD PERFORM)  : OFFS! TO XO TO XM TO DISP ;         : #D16 @WORD OFFS! TO XWO ;   : #D8 @SBYTE OFFS! ;              0 BARY ATBL  30 C, 31 C, 46 C, 47 C, 6 C, 7 C, 5 C, 3 C,        : R/R MF ATBL C@ 8 U/MOD ?DUP IF WREG. THEN C" / EMIT WREG. ;   : _IMM TO XI XIS -IF @WORD ;THEN @SBYTE ;   : ;SPC CO SPACE ;   : REL? _IMM IP + TO IMMED ; : IMM? _IMM TO IMMED ;              : IM8  TO XIS IMM? ;    : RELB TO XIS REL? ;                    : IM1 TO XIS TO XI 1 TO IMMED ; : IM? XW -IF TO XIS THEN IMM? ; : MEM?  @BYTE 1L /MOD TO RMF  8 /MOD TO RF TO MF   RMF CASE          0 OF  MF 6 = IF #D16 THEN  ENDOF                                1 OF  #D8   ENDOF      2 OF  #D16  ENDOF ENDCASE ;         : -SEG.  XW IF WREG. ;THEN BREG. ;                              : OPR? -IF IP1 TO IP [OP,] DFB TO OPI 12 TO GADR IM8                   RDROP THEN  ;  -->                                                                                                                                                                                                                                       : ?WB. IF 1W. ;THEN 1B. ;                                       : ;DISP CO ;SPC "  +/" XWO IF DROP "  //" THEN ". ;             : ;IMM CO  ;SPC "  B#" XIS -IF DROP "  W#" THEN ". ;            : IMM.  XI 0;   ;IMM    IMMED  XIS 0= ?WB. ;                    : DISP. XO 0;   ;DISP   DISP XWO ?WB. ;                         : ?REG. XG -IF -SEG. ;THEN SREG. ;    : RG. ;SPC RF ?REG. ;     : MR. ;SPC XM -IF -SEG. ;THEN                                    DISP. RMF -IF MF 6 - -IF ;THEN THEN R/R ;                       : MR/R. ['] RG. ['] MR.  XD IF SWAP THEN EXEC  EXEC ;          : XGTBL CREATE DOES> OVER + + PERFORM ;                         : _ROP 7 AND TO RF ;   : SEGOP TO XG OPC AT 2/ _ROP ;           : ROP TO XW OPC _ROP ; : AREG  0 TO RF 6 TO MF 0 TO RMF ;       : REL. IMMED 1W. SPACE ;  : FARI. REL. DISP 1W. SPACE ;         : AR,M AREG #D16 ;          : A,I AREG IM? ;                -->                                                                                                                                 : R,I ROP 8 OPC AND -IF 1 F-CLR THEN IM? ;                      : D,I8 #D16 IM8 ;                                               : D,I16 #D16 IMM? ;                                             : D,I. DISP. REL. ;                                             : R,I. REL.  RG. ;                                              : MR,I. MR. IMM. ;                                              : MR,CL. MR. 1 BREG. SPACE ;                                    : R16,M XM OPR? TO XD TO XW ;                                   : SEG,M XM OPR? TO XG ;                                         : AR. ;SPC 0 ?REG. ;                                            : PREF. POP CO C" : EMIT PUSH ;                                 : A,IM8 AREG IM8 ;                                                                                                                                                                     -->                                                                      \              0     1     2     3     4      5    6    7       XGTBL G2B@OP ] IM?   IM8   IM8   IM1   NOOP   NOOP NOOP NOOP [  XGTBL G2B.OP ] MR,I. MR,I. MR,I. MR,I. MR,CL. MR.  MR.  MR.  [  : XG2B  GNI G2B@OP ;   : XG2B. GNI G2B.OP ;                     XGTBL G@OP  ]                                                   \ O1    0       ROL     LES     MOVMS   MOVMI   ADDI    MOVRI           XG2B    NOOP    R16,M   SEG,M   IM?     A,I     R,I     \ O2    MOVA    PUSHR   PUSHS   AL      ES      SAHF    INT             AR,M    ROP     SEGOP   NOOP    NOOP    NOOP    IM8     \ O3    INP     IN      JO      CALLI   RETI    ENTER   CALLFI          A,IM8 NOOP    RELB    REL?    IMM?    D,I8    D,I16  [                                                                  XGTBL G.OP  ]  XG2B.  MR/R.  MR/R.  MR/R. MR,I. R,I.  R,I.        MR/R.  RG.    RG.   NOOP   PREF.  NOOP  IMM.  R,I.              AR.    REL.   REL.  IMM.   D,I.   FARI. [         -->                                                                         ( @OP .OP  GNI-GROUP.NAME.INDEX OPI-OPERATION.NI              ) : @OP IP TO IP1 @BYTE DUP  3 AND TO FLAGS  DUP TO OPC OPTBL C@     DUP DUP TO OPI TO GNI     [OP,] PUSHI <  IF MEM? THEN          0 BEGIN 1+ GNI OVER  GROUPS C@ < UNTIL 1- DUP  TO GADR         -IF 256 OPTBL DUP GNI + 48 + C@ 8 * + RF + C@ TO OPI THEN       OPI [OP,] ??? - OPR?  GADR G@OP ;                              : .OP CR @OP IP1 DUP 1W. BEGIN SPACE COUNT 1B. IP OVER =          UNTIL DROP  BEGIN SPACE OUTC 24 = UNTIL GADR G.OP OPI _OP. ;  : ND FOR .OP NEXT ;  : 'DIS TO IP 10 ND ;                       : DIS ' @ 'DIS ;     : L 20 ND ;                                                                                                \  PAD PATTERN  PAD 'DIS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( DISASEMBLE ONE INSTRUCTION                                  ) : ND FOR 1DIS NEXT ;                                            : 'DIS TO IP 10 ND ;                                            : DIS ' @ 'DIS ;                                                0 VALUE TST                                                     : 1T TST DUP 1+ TO TST PAD 1+ C! PAD TO IP 1DIS ;               : NT FOR 1T NEXT ;                                                                     PRUNE 1 LOAD                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( ASET                                                        ) : INSET CREATE DOES> OVER R>M + C@ SWAP 7 AND 2^ AND ;          INSET OPSET   BINARY                                        \ 00111100001111 , 111100001111 , 111100001111 , 111100001111 , \ 40           0 ,            0 , 101000001100 ,            0 , \ 80          -1 ,            0 ,            0 ,            0 , \ C0    11110011 ,         1111 ,      0 ,   1100000011000000 ,     DECIMAL                                                         : [[ POP >IN PUSH SWAP DUP IF 1- THEN PUSH PUSH ;               : ]] POP POP ?DUP IF 1- R@ TO >IN PUSH PUSH ;THEN RDROP PUSH ;  : ?CR -IF CR THEN ;                                                                                                              256 [[ 255 R@ - 15 AND ?CR 255 R@ - OPSET 4 .R ]]                                                                                                                                                                                                              ( GET OPERATION CODE & R/M )                                    0 QUAN ADR               0 VALUE NA    0 VALUE IMMED            0 VALUE OP  0 VALUE OPN  0 VALUE OPS   0 VALUE RMF              : @BYTE AT ADR AT 1+ C@ ;   : @WORD AT ADR AT 2+ @ ;            : @SBYTE AT ADR AT 1+ TO C@ ;   0 VALUE OLD_SP                  : INSET CREATE DOES> ADR TO OPS @BYTE DUP TO OP  R>M + C@           OP 7 AND 2^ AND  0 TO OPN IF @BYTE TO RMF  64 F-SET THEN ;  INSET @OP   BINARY                                        \ 0   111100001111 , 111100001111 , 111100001111 , 111100001111 , \ 40           0 ,            0 , 101000001100 ,            0 , \ 80          -1 ,            0 ,            0 ,            0 , \ C0    11110011 ,         1111 ,      0 ,   1100000011000000 ,     DECIMAL                                                                                                 -->                                                                                                                                                     ( VARIABLE DISP   VARIABLE FLAGS  ( xxxxxxccOMIAGSDW )          ( M=r/m; cc=reg count; I=immediate; A=accumulator; G=seg;)      ( S=imm.size; D=direction;  W=word or byte; O=disp only  )                                                                      : .REG 9 * 'REGS + ". ;                                         : .R/M 10 * 100 - 'REGS + ". ;                                      FORTH  ' SP   TO ASSEMBLER   ALIAS  MY_SP                                                                                   : NAME? 1K F-GET    ( DISASEMBLING ? )                               IF  MY_SP                                                             OLD_SP - POP 2- SWAP  ( AFTER DOES> ? )                      IF DROP THEN 2-                                                 C>N DROP TO OPN                                              THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ MARKER                                                        \ : DO_CONST @R RDROP ;  : DO_VAR POP ;                         \ : DO_NEST POP IP PUSH                                         \ <INTRO  DI POP                                                \ BEGIN, 0 /DI CALL,   DI INC,  DI INC, AGAIN,                  \                                                               \                                                               \                                                                                                                               : ?IN POP DUP 2+ PUSH >IN PUSH PERFORM POP TO >IN ;                                                                             : ?EXIST ?IN -FIND NIP ;                                        : MARKER ?EXIST IF ?IN FORGET THEN CREATE                           DOES> 2- C>N DROP forget ;                                  : ORDER. ORDER# STR FOR STR 6 - ?ID. NEXT DROP ;                                                                                \ LIST OF  LOADERS                                                                                                              \ : -ASM AT ASSEMBLER TO 0 LIT RECURCE 2- @ forget ;                                                                                                                                            DECIMAL        8 LOAD      \ DEFORTHER                          DECIMAL   90 104 THRU      \ ASSEMBLER                          \ DECIMAL      297 LOAD      \ TARGET STUFF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \  ASSEMBLER  LOADER  ( 89 LOAD)  &  UNLOADER (-ASM)            TO FORTH ( ASSEMBLER)  MARKER -ASM  0 VECTOR ASM                : CODE HEADER HERE 2+ , ASM ;                                   : ;CODE  COMPILE ;code [',] [ ASM ; IMMEDIATE                                                                                      CSP!   88 LOAD  ?CSP  PRUNE                                                                   EXIT                           : 'PRUNE VOCLINK AT ASSEMBLER 2+ DUP -ROT !  TO VOCLINK             PRUNE AT FORTH 2+ TO VOCLINK ;                              DECIMAL   CSP!    HERE TO XK                                     88 LOAD  ?CSP    HERE XK - TO XK  XK .                         'PRUNE  AT ASSEMBLER TO 0              -HEAD  DECIMAL           <% HERE  200 ALLOT %> XK - TO HERE                               88 LOAD      'PRUNE    FORGET IT      -HEAD  F83                                                                                                                                               ( assembler    -16528 = -HEAD    control words   )               ASSEMBLER  ALSO DEFINITIONS    \ VOCABULARY  ASSEMBLER         HEX 0 VALUE DISP 0 QUAN FLAGS   ( xxxxxxccOMIAGSDW )            | : SHORT? ( n - f)  -80 80 WITHIN ; : DB, C, ; : DW, , ;       : BEGIN, ( - a) HERE ; | : ?A DUP SHORT? 0= A" SH-ADR?" ;       : ASM-RESET 2 TO FLAGS  0 TO DISP ;  : IF, , BEGIN, ;           : WHILE, IF, SWAP ; : THEN, BEGIN, OVER - ?A SWAP 1- C!  ;      : UNTIL, ( a opc -) C, BEGIN, 1+ - ?A C, ;  1L | WARY BRANCHES  | : ^BRANCH [',] # DUP 1L U< 0= A"  BR#? "  BRANCHES ;          : FB, ^BRANCH DUP @ A" REDEF! " HERE 2+ SWAP! , ;               | : ^< ^BRANCH 0 TO >< ;  : L,F HERE 2+ FB, ;                   : JMP,F E9 C, L,F ;   : CALL,F E8 C, L,F ;  : FB! ^< THEN, ;    : FL! ^< DUP 2- @ OVER - A" LBL? "  HERE OVER - SWAP 2- ! ;     : FBI 1L 0 DO I BRANCHES 0 TO >< IF I . 7 EMIT THEN LOOP ;      : ELSE, EB WHILE, THEN, ; : END-CODE PREVIOUS FBI ?CSP ;        | : 'ASM ASM-RESET ALSO ASSEMBLER CSP! ;   ' 'ASM TO ASM        HEX  ( relative jumps   )                                       | : opc ( opcode -) ( - opcode) CREATE C, DOES> C@ ;            | : ?OPC ( opcode -) ( - opcode) CREATE C, DOES> C@ UNTIL, ;                                                                    73 opc CS,  75 opc 0=,  79 opc 0<,  73 opc U<,  E3 opc CXNZ,    7D opc <,   7E opc >,   76 opc U>,  71 opc OV, : NOT, 1 XOR ;   EB opc -?,                                                      ( the rest can be made by following above with NOT, )           E2 ?OPC   LOOP,           E1   ?OPC LOOPZ,                      E0 ?OPC   LOOPNZ,         EB   ?OPC SJMP,                       0<, NOT,  ?OPC JM,   U<, NOT,  ?OPC JB,    ' JB, ALIAS JC,      0<,       ?OPC JNM,       U<,  ?OPC JNB,  ' JNB, ALIAS JNC,     0=, NOT,  ?OPC JZ,      CXNZ,  ?OPC JCXZ,  ' JZ, ALIAS JE,         0=,    ?OPC JNZ,                       ' JNZ, ALIAS JNE,     0 VALUE ?NEXT                                                                                                                   HEX  ( bit-flags and reg seg & r/m defining words )             ( VARIABLE DISP   VARIABLE FLAGS  ( xxxxxxccOMIAGSDW )          ( M=r/m; cc=reg count; I=immediate; A=accumulator; G=seg;)      ( S=imm.size; D=direction;  W=word or byte; O=disp only  )      | : F-SET ( mask -) FLAGS OR TO FLAGS ;                         | : F-CLR ( mask -) -1 XOR FLAGS AND TO FLAGS ;                 | : F-GET ( mask -) FLAGS AND ;                                 | : F-FLIP ( mask - ) FLAGS XOR TO FLAGS ;                      | : <reg> ( a -n) DUP 1+ C@ DUP 1 AND 1 XOR 2* 2* OR F-SET C@ ; | : reg ( 000a000w00rrr000 -) ( - 0000000000rrr000)  CREATE ,         DOES> <reg> 100 AT FLAGS +! ( count regs)  2 F-FLIP  ;    | : seg ( n -) ( -n) CREATE ,  DOES> <reg> 2 F-SET ;            | : r/m ( n -) ( disp - n) CREATE ,                                   DOES> <reg>  2 F-CLR ( D) SWAP TO DISP ;                                                                                                                                                  ( default D is on, r/m clears it, reg flips it, seg sets it)    ( D=0 when r/m field is destination )                           HEX ( R/M & REG are 16bit constants, but reg keeps count )      4000 r/m X/S    4001 r/m X/D    4002 r/m P/S                    4003 r/m P/D    4004 r/m /SI    4005 r/m /DI                    4006 r/m /BP    4007 r/m /BX    C006 r/m ///   ( chg this?)     ( bits 3-5=reg, bit 8=W, bit 9=D flg, bit 12=ACC flg )          CREATE 'REGS                                                    1000 reg AL  0008 reg CL  0010 reg DL  0018 reg BL              0020 reg AH  0028 reg CH  0030 reg DH  0038 reg BH              1100 reg AX  0108 reg CX  0110 reg DX  0118 reg BX              0120 reg SP  0128 reg BP  0130 reg SI  0138 reg DI              0900 seg ES  0908 seg CS  0910 seg SS  0918 seg DS              | CREATE F$  4457 , 4753 , 4941 , 4F4D ,                        : .F ( -) FLAGS 8 FOR 20 R@ 2^ F-GET IF DROP F$ R@ + C@ THEN       EMIT NEXT  100 / 3 U.R ."  regs " ;                          HEX ( REG>R/M  #,  orW  11mod  01mod  10mod  ,DISP BYTE )       ( | : R>M ( reg -r/m( 2/ 2/ 2/ ;)   | : 1REG? 100 F-GET ;         : #, ( n1 - n1) 20 OVER SHORT? 04 AND OR F-SET  ;               : B#,  24 F-SET ; : W#, B#, 4 F-CLR ;                         | : orW ( --opc---   -  --opc--w)  1 F-GET  OR ;                | : orDW ( --opc---  -  --opc-dw)  3 F-GET  OR ;                | : modDISP, ( 2nd - ) 40 F-GET ( ie M)                           IF 80 F-GET ( ie Only) IF C, DISP ,                               ELSE 8 F-GET ( ie G) DISP OR  OVER 7 AND 6 = OR ( ie[BP])       IF DISP SWAP OVER SHORT?                                          IF 40 OR C, C, ELSE 80 OR C,  , THEN                          ELSE ( zero & not seg) C, THEN  THEN ELSE C0 OR C,  THEN ;                                                                  \   DECIMAL  84 LOAD                                            | : NAME? ; IMMEDIATE                                                                                                           ( one byte opcodes with no variables )                          HEX                                                             | : IMM? ( -f) 20 F-GET  ;  | : ACC? ( -f) 10 F-GET ;           | : ,IMM  ( n -) 5 F-GET 4 = IF ( S,-W)  C, ELSE  , THEN ;        : W/ ( -)  1 F-SET  ; ( WORD PTR - the default is byte )      | : 2REGS? ( -f) 308 F-GET DUP 200 = SWAP 108 = OR ;                                                                            HEX                                                             | : M1 ( n -) ( -)  CREATE C, DOES> NAME? C@ C, ASM-RESET ;     98 M1 CBW,  F8 M1 CLC,  FC M1 CLD,  FA M1 CLI,  F5 M1 CMC,      99 M1 CWD,  CF M1 IRET, 90 M1 NOP,  C3 M1 RET,  CB M1 RETF,     F9 M1 STC,  FD M1 STD,  FB M1 STI,  D7 M1 XLAT, 9E M1 SAHF,     F3 M1 REP,  F3 M1 REPZ, F2 M1 REPNZ, AF M1 SCASW, 9F M1 LAHF,   B9 M1 SKIP2,   B1 M1 SKIP1,  AB M1 STOSW,  AD M1 LODSW,         9C M1 PUSHF,   9D M1 POPF,                                      26 M1 ES:   2E M1 CS:   36 M1 SS:   3E M1 DS:                   ( 2 operand instructions such as ADD,  )                        HEX                                                             | : M2 ( n -) ( various - ) CREATE ,                              DOES> NAME? @ PUSH  IMM?                                         IF ACC? IF     DROP  POP orW 4 OR C,                                    ELSE   1REG? IF R>M THEN  80 orW C,                                    POP 38 AND OR  modDISP,                                  THEN  ,IMM                                              ELSE  2REGS?  IF SWAP R>M THEN                                        POP orDW C, OR modDISP,                                   THEN  ASM-RESET  ;                                                                                                           HEX  ( use M2 to define ADD, like instructions )                                                                                10 M2 ADC,  00 M2 ADD,  20 M2 AND,  38 M2 CMP,   08 M2 OR,      18 M2 SBB,  28 M2 SUB,  30 M2 XOR,                              HEX ( MOV,) ( one byte instr w/ W  - the string instructions )  : MOV, NAME? IMM?                                                 IF  1REG?  IF   R>M B0 OR 1 F-GET AT 2*  OR C,                             ELSE C6 orW C, modDISP,    THEN  ,IMM                ELSE 90 F-GET 90 =                                              IF   2DROP A0 2 F-FLIP orDW C, DISP ,                           ELSE  2REGS? IF   2 F-GET ( ie D) IF SWAP THEN  R>M  THEN        8 F-GET ( ie G) IF 1 F-CLR 8C ELSE 88 THEN  orDW C,             OR  modDISP,                                                   THEN THEN  ASM-RESET ;                                                                                                        HEX  | : M3 ( n -) ( reg -) CREATE C, DOES> NAME? C@                   orW C, DROP ASM-RESET   ;                                                                                                A6 M3 CMPS,  AC M3 LODS,    A4 M3 MOVS,                         AE M3 SCAS,  AA M3 STOS,    6C M3  INS,   6E M3 OUTS,           ( mul, div, xxxxxxxW  mdNNNr/m ) ( M5 for LDS, LEA, & LES, )    HEX  | : M4 ( n -) ( -) CREATE C,                                DOES> NAME? C@ F6 orW C, SWAP 1REG? IF R>M THEN OR  modDISP,         ASM-RESET  ;                                                                                                              30 M4 DIV,  38 M4 IDIV,  28 M4 IMUL,                            20 M4 MUL,  18 M4 NEG,   10 M4 COM,                                                                                              (  NOT,  is the the Intel name for my  COM,  but it     )       (  would conflict w/ my flag inverter which I call  NOT,)       (  ** be careful ** )                                                                                                          | : M5 ( n -) ( -) CREATE C,                                                  DOES> NAME? C@ C, OR modDISP, ASM-RESET  ;                                                                        C5 M5 LDS,  8D M5 LEA,  C4 M5 LES,                              ( M6 for the rotate & shift instructions )                      HEX                                                             | : M6 ( n -) ( n# r/m | r/m    - ) CREATE C,                    DOES> NAME? C@ IMM? 10 U/  2 XOR  1 F-GET ( ie W) OR D0 OR C,      1REG? IF SWAP R>M THEN OR modDISP,  IMM? IF DROP THEN                 ASM-RESET  ;                                                                                                          10 M6 RCL,   0 M6 ROL,   20 M6 SHL,   18 M6 RCR,                08 M6 ROR,  38 M6 SAR,   28 M6 SHR,                                                                                             ( examples to shift right 1 bit )                               ( 1 #, SI SHR,   1 #,  W-PTR  17 [BX] SHR,   1 #, AL SHR,  )                                                                    ( examples to shift right the # of bits in CL )                 ( SI SHR,  AL SHR,  1300 rt-par SHR,  3752 W-PTR rt-par SHR, )                                                                  HEX ( INC, & DEC, instructions )   ( IN, OUT, instr )           | : M7 ( n -) ( r1 | r/m  -) CREATE C,                             DOES> NAME? C@ SWAP  1REG? IF  ( opc r1) R>M THEN                     1REG? 100 =  1 F-GET AND  ( ie it's a 2-byte register)          IF  ( opc rX)  OR 40 OR C,                                      ELSE  ( opc mem | opc rH | opc rL )                                FE orW C,  OR modDISP,                                       THEN  ASM-RESET  ;                                     08 M7 DEC,   00 M7 INC,                                                                                                         | : M9 ( n -) ( n# r1 | r1  -) CREATE C,                          DOES> NAME? C@  orW NIP                                            IMM? IF ( n# opc)  C, ( n#) ELSE ( opc) 8 OR THEN C,            ASM-RESET ;                                                E4 M9 IN,   E6 M9 OUT,                                                                                                          ( PUSH, & POP, instructions )                                                                                                   HEX                                                             | : M8 ( n -) ( reg | seg | r/m  -)  CREATE ,                      DOES> NAME? @  8 F-GET                                            IF  ( seg opc ) 16/ 1 AND 1 XOR 6 OR OR C,                      ELSE 1REG?                                                      IF  ( reg opc ) 2/ 8 AND 8 XOR 50 OR SWAP R>M OR C,             ELSE ( r/m opc) DUP 100 U/ FF AND C,  OR modDISP,               THEN  THEN  ASM-RESET ;                                                                                                    FF30 M8 PUSH,  8F00 M8 POP,                                                                                                     ( use   port #, AL IN,  or  port #, AX IN,  for 8 bit ports )   ( or    AL IN,  or  AX IN,   for port in the DX register  )     ( do not use AL DX IN, - the DX is implied                )     ( XCHG )  ( TEST, instruction  - almost like ADD, etc. )        HEX                                                             : TEST,  ( various - ) NAME?                                       IMM?                                                            IF ACC? IF     DROP  A8 orW ( 4 OR) C,                                  ELSE   1REG? IF R>M THEN  F6 orW C, ( OR)  modDISP,             THEN  ,IMM                                              ELSE  2REGS?  IF SWAP R>M THEN                                        84 orW C, OR modDISP,                                     THEN  ASM-RESET  ;                                                                                                           : XCHG,  ( reg mem | mem reg | reg1 reg2   -)   NAME?             211 F-GET 211 = ( 2 regs & one is AX)                           IF  ?DUP IF NIP THEN ( r1 ) R>M  90 OR C,                       ELSE  2REGS? IF  R>M  THEN  OR  86 orW C, modDISP,              THEN  ASM-RESET ;                                             ( CALL, instr  ) ( INT,  & segment override instructions )      HEX                                                             : CALL, ( various -) NAME?  IMM?   ( intra-seg direct )           IF  ( n#)  HERE 3 + - ( make it relative)                           E8 C, , ( eg 2389 #, CALL, calls addr $2389)                ELSE                                                                ( mem | reg  -)  1REG?  IF R>M  THEN                            FF C,  10 OR modDISP, ( eg 0 [BX] CALL, or DX CALL, )       THEN  ASM-RESET ;         ( this is intra-seg indirect )                                                                      ( I am not implementing the inter-seg direct)                   ( or indirect versions )                                                                                                        : INT, ( #n -) NAME? $ CD C, C, ASM-RESET ; ( eg 21 #, INT, )                                                                                                                                   ( JMP, instr  &  NXT, )    HEX                                  : JMP, NAME?                                                           ( various -) 140 F-GET ( ie R or M  intra-seg indirect )    IF ( mem | reg  -)  1REG?  IF R>M  THEN                            FF C,  20 OR modDISP, ( eg 0 [BX] JMP, DX JMP, )                                      ( or 3759 rt-paren JMP,  )             ELSE  ( a) HERE 3+ -                                             ( relative) DUP SHORT? IF 1+ EB C, C, ELSE  E9 C,  ,  THEN      ( disp is added to IP, so this is a relative jump )          THEN  ASM-RESET ;                                              : LJMP, ( a -)  E9 C,  HERE 2+ - ,  ;  ( lay down 3byte jump)    ' ORIGIN+ 2+ 2+ @   TO ?NEXT                                   ( I am not implementing the inter-seg direct or indir. versions): NEXT, ( -) ?NEXT JMP, ;                                       PREVIOUS                                                        FORTH                     F83 ( 96 LOAD)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             £∞•∏™® §†§•≠† Æ≤ Ø∞Æ∂•§≥∞®≤• ß† ∑•≤•≠• ® ß†Ø®±             1   ≠•¢†´®§•≠ ≠Æ¨•∞ ≠† ¥≥≠™∂®ø ®´® ØÆ§¥≥≠™∂®ø                   2   Ø∫´•≠ ¢∫≤∞•∏•≠ ±≤•™                                         3   Ø∞Æ¨•≠•≠® ±† ¢•™≤Æ∞®≤• ≠† Ø∞•™∫±¢†≠• - INT 2F               4   £∞•∏™† ¢ §∫∞¢Æ≤Æ-®≠§•™±{ ? ≠Æ¨•∞ ≠† °´Æ™}                   5   ≤¢∫∞§• ¨≠Æ£Æ ≠•†¢≤Æ¨†≤®∑≠® ¥†©´Æ¢•                          6   ≤¢∫∞§• £Æ´ø¨Æ ∑®±´Æ   {≠•¢†´®§•≠ Ø†∞†¨•≤∫∞}                 7   ≠• ±† †¢≤Æ¨†≤®∑≠® †∞µ®¢®                                    8   ≠• • ArM- †∞µ®¢                                             9   ArM-∫≤ • ß†•≤ (ÆØ®≤ ß† ØÆ¢≤Æ∞≠Æ ¢´®ß†≠•)                    10  ≠ø¨† ±¢Æ°Æ§≠® °≥¥•∞® (£∞•∏™† ¢ Ø†¨•≤≤†)                     11  Ø∫≤ø≤ ≠• • Ø∫´•≠ §Æ †∞µ®¢                                   12  ÆØ®≤ ß† ∞†°Æ≤† Ø∞® §∞≥£® ™ÆÆ∞§®≠†≤®                         13  Æ°´†±≤≤† Ø∞®•¨≠®™ • ØÆ§¨≠Æ¶•±≤¢Æ ≠† ®±≤Æ∑≠®™†               14  ≠•Ø∫´•≠ ß†Ø®± ≠† °´Æ™  {Ø∫´•≠ §®±™ ¨Æ¶• °®?}                15  †∞µ®¢∫≤ • ∞†ß∞•∏•≠ ±†¨Æ ß† ∑•≤•≠•                           ¥≥≠™∂®®≤•   ; ≠Æ¨•∞   ®¨• ≠† ¥-∂®ø                                                                                               stk_full   ; -2      £∞•∏™† - Ø∫´•≠ ±≤•™                        ill_fun    ; -1      £∞•∏™† - ≠•ØÆß≠†≤† ¥-∂®ø                   present    ; 0       ≠†´®∑•≠ ArM ¢ Ø†¨•≤≤†                     self_instal ; 1       ±†¨Æ®≠±≤†´®∞†≠• ≠† ¢µÆ§≠® ≤Æ∑™®            self_quit  ; 2       Ø∞•¨†µ¢†≠• ≠† ArM Æ≤ Ø†¨•≤≤†               open       ; 3       ∞†°Æ≤† ± †∞µ®¢ - ®ß°Æ∞                     lmove      ; 4       ¨•±≤•≠• ≠† Ø†¨•≤                           read_file  ; 5       ∑•≤•≠• Æ≤ †∞µ®¢                            write_file ; 6       Ø®±†≠• ¢∫∞µ≥ †∞µ®¢                         copy_file  ; 7       ™ÆØ®∞†≠• ¢∫∞µ≥ †∞µ®¢                       rdblk      ; 8       ∑•≤•≠•    Æ≤ °´Æ™                          wrblk      ; 9       Ø®±†≠• ¢∫∞µ≥ °´Æ™                          defdom     ; 10      ¥-∂®® ß† ∞†°Æ≤† ± Æ°´†±≤®                  prevnext   ; 11      ¥-∂®® Ø∞•§®∏•≠-±´•§¢†π  •´•¨•≠≤-Æ°´†±≤     ins_mem    ; 12      Ø®±†≠• ¢ †∞µ®¢      insert                 ins_file   ; 13      ™ÆØ®∞†≠• ¢ †∞µ®¢          icopy            get_path   ; 14      Ø∫´•≠ Ø∫≤ §Æ †∞µ®¢                         setlen     ; 15      ±™∫±ø¢†≠• ≠† •´•¨•≠≤ - §†¢† §∫´¶®≠†≤†     copy_domain ; 16      ™ÆØ®∞†≠• ≠† Æ°´†±≤                         copy_arch  ; 17      ™ÆØ®∞†≠• ≠† †∞µ®¢                          info_arch  ; 18      ®≠¥Æ∞¨†∂®ø ß†  †∞µ®¢                       l4read     ; 19      ¢∫≤∞•°´Æ™Æ¢Æ ∑•≤•≠• ≠† 4 °†©≤†             movelement ; 20      ¨•±≤•≠• ≠† •´•¨•≠≤ ¢ ±∫π† Æ°´†±≤           arm_state  ; 21      ±∫±≤Æø≠®• ≠† ArM                          share_state ; 22      ±∫±≤Æø≠®• ≠† ≤Æ∑™†≤†-†µ®¢                  commit     ; 23      ®ßµ¢∫∞´ø≠• ≠† Ø∞Æ¨•≠•≠®≤• DOS °≥¥•∞®       read_mult  ; 24      ∑•≤•≠• ¢ Ø∞†¢Æ∫£∫´≠† Æ°´†±≤                write_mul  ; 25      Ø®±†≠• ¢ Ø∞†¢Æ∫£∫´≠† Æ°´†±≤                lock_dom   ; 26      ß†™´æ∑¢†≠• ≠† Æ°´†±≤                       lock_arch  ; 27      ß†™´æ∑¢†≠• ≠† †∞µ®¢                       ( REVERCE MEMORY BY BYTES       *****************************ˇ) \ REVERCE 2DUP + SWAP 2/ FOR 1- AT >< NEXT 2DROP ;              \ "SWAP [ MAC: RVR TO /STR DUP PUSH REVERCE ; ] "N RVR  "T RVR  \  SPTR  POP POP + REVERCE ;                                                                                                    \  : "+ "SWAP "T "DROP "INS ;                                   : "CUT ( N --) "T ROT 2DUP 0 WITHIN -IF DROP DUP THEN ( A N N)     -ROT PUSH 2DUP + 2- TO SPTR SWAP "PUSH POP SPTR @ - "T + ! ; \ : C"INS SP 1 "INS DROP ;                                      : "OVER "N "PUSH ;  : "NIP "SWAP "DROP ;                        : "DEL SWAP "CUT "SWAP "CUT "DROP "+ ;                          : "INSERT "CUT "SWAP "INS "+ ;                                                                                                                                                                                                                                                                                                  ( 2STACK                                                      ) FORGET IT  128 CONSTANT IT CREATE BUF  128 ALLOT                : IDUMP BUF IT DUMP ;  : ICLEAR BUF IT ERASE ; ICLEAR  IDUMP    ' IOV @   1 NM: 4 SWAP @+! 2! ;M   2 NM: -4 SWAP @+! 2@ ;M      3 MAKER 2STACK> ,     BUF 2STACK> BN>                                                                                           ' IOV @   1 NM: -4 SWAP @+! 2! ;M   2 NM: 4 SWAP @+! 2@ ;M      3 MAKER <2STACK ,     BUF IT + <2STACK <BN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ RELINK                                                                                                                       =' ..\ARM_R /M"          CREATE A7  DUP   ",  A7 COPY'          : RELINK  A-PRSNT TO ARES IF A-CONN ;THEN                         A7 SHELL TO ARES IF BYE ;THEN                                   A-PRSNT TO ARES IF A-CONN ;THEN  BYE ;                                                                                                                                                                                                                                                      AFASDFASDFASDFA ASDFS                                                                                                                                                                                                                                                                                                                                                                                                                  £∞•∏™® §†§•≠® Æ≤ Ø∞Æ∂•§≥∞®≤• ß† ∑•≤•≠• ® ß†Ø®±             1   ≠•¢†´®§•≠ ≠Æ¨•∞ ≠† ¥≥≠™∂®ø ®´® ØÆ§¥≥≠™∂®ø                   2   Ø∫´•≠ ¢∫≤∞•∏•≠ ±≤•™                                         3   Ø∞Æ¨•≠•≠® ±† ¢•™≤Æ∞®≤• ≠† Ø∞•™∫±¢†≠• - INT 2F               4   £∞•∏™† ¢ §∫∞¢Æ≤Æ-®≠§•™±{ ? ≠Æ¨•∞ ≠† °´Æ™}                   5   ≤¢∫∞§• ¨≠Æ£Æ ≠•†¢≤Æ¨†≤®∑≠® ¥†©´Æ¢•                          6   ≤¢∫∞§• £Æ´ø¨Æ ∑®±´Æ   {≠•¢†´®§•≠ Ø†∞†¨•≤∫∞}                 7   ≠• ±† †¢≤Æ¨†≤®∑≠® †∞µ®¢®                                    8   ≠• • ArM- †∞µ®¢                                             9   ArM-∫≤ • ß†•≤ (ÆØ®≤ ß† ØÆ¢≤Æ∞≠Æ ¢´®ß†≠•)                    10  ≠ø¨† ±¢Æ°Æ§≠® °≥¥•∞® (£∞•∏™† ¢ Ø†¨•≤≤†)                     11  Ø∫≤ø≤ ≠• • Ø∫´•≠ §Æ †∞µ®¢                                   12  ÆØ®≤ ß† ∞†°Æ≤† Ø∞® §∞≥£® ™ÆÆ∞§®≠†≤®                         13  Æ°´†±≤≤† Ø∞®•¨≠®™ • ØÆ§¨≠Æ¶•±≤¢Æ ≠† ®±≤Æ∑≠®™†               14  ≠•Ø∫´•≠ ß†Ø®± ≠† °´Æ™  {Ø∫´•≠ §®±™ ¨Æ¶• °®?}                15  †∞µ®¢∫≤ • ∞†ß∞•∏•≠ ±†¨Æ ß† ∑•≤•≠•                           \ ARM TEST SCREENS                                                                                                              \  37 LOAD ( ALIGN )                                              117 LOAD ( ARM FUNCS)                                              DSC1   =' SOMEHOW.DAT" A-OPEN                                    ?OPEN .                                                                                                                     125 LOAD ( ARM TEST)                                            DSC1 ARCH.                                                      DSC2 T.NAME A-OPEN                                              CR                                                              ?OPEN .                                                       \ PAD STR                                                                                                                                                                                                                                                                                                                        -HEAD  F83                                                       RELINK                                                         : 2VAR VARIABLE 0 , ;    2VAR ADOMAINS                            2VAR ELEMENTS          2VAR AELEMENTS                             0 VALUE BRKF                                                    1 VALUE SFLAG  \ : --> CR BLK . [',] --> ; IMMEDIATE                                                                          MAC ADOMAINS D!       ( !!!)                                                                                                                                                                                                                                  : TOTAL CR ." DOMAINS = " ADOMAINS D@ D.                                ."   ELEMENTS = " AELEMENTS D@ D. ;                                                             -->                                                                                    \ INVISIBLE                                                     \ : :: : RECOVER ['] INTERPRET 2 NW, DROP ;                      -HEADERS                                                        : ># CREATE C, DOES> C@ B>D ;                                   : ?BRK BRKF IF BREAK. THEN ;                                   FUNC: P-F ( / _P1 _P2 _P3 )  [ MAC ELEMENTS D! ]  ( !!!)                 EXECUTE ;              ELEMENTS D@ TO MAC ( !!!)         :  >_P3  TO _P3  TO _P2  TO _P1 ;                               :: >P23  _P2 _P3 ;                                              :: >0P3   ?CS: _P1  ?CS: _P2 0 _P3 ;                          | : A-F: PUSH : POP C, DOES>  COUNT PUSH P-F POP ?BRK FUNA ;                                                                      -1 ># -1#    0 ># 0#   -128 ># ##       -->                                                                                                                                                                                                                                                                                    : PAD. PAD STR TYPE ;                                          \ : C>ADR  <# HOLD HLD ;                                         : ?D D@ D. ;                                                    : ?-AUTO ( N N ) 0= SWAP 0= OR ;                                : ?NEL   ( -- F ) ARES AND 1+ 0= ;                             \ CREATE A ERASED CHUNK OF MEMORY ON RETURN STACK               :: ^MEM DUP POP RP ROT - DUP TO RP SWAP PUSH DUP ROT ERASE ;     : ^DSC 1H TO ^MEM ; RECOVER  \ CREATE A DESCRIPTOR                                                                                                                                             \ FUNC: PROBA ( A / B C ) [ MAC: VIEW CR A . B . C .; ] VIEW    \ CR RP A ^MEM TO C  ^DSC TO B  VIEW  B 1H DUMP  C A DUMP ;     ( EXIT)                                 -->                                                                                                                                                                                                                     CLASS: DESCR           5. 4. 3. 2 1                                F: OFFS ;F AT FA    F: ELEM ;F AT FA                            F: DOMN ;F AT FA    F: APPE ;F ,         F: APPL ;F ,        ;CLASS                                                                                                                           0. 0. 0.  0  1  DESCR  DSC2   0. 0. 0.  0  0  DESCR  DSC1                                                                       METHOD: DESCR                                                     218 A-F: A-OPEN ( "A N N) ?CS: SWAP APPE APPL ;                FUNC: SA-OPEN ( NAM )  SELF  ^DSC TO SELF                               NAM A-OPEN  TO SELF ;                                   FUNC: A-CLOSE ( / NAM ) ( N N ) AT NAM  A-OPEN ;                : ?OPEN  ( N N ) APPE APPL 0# 0# 22 FUNA TO ARES 2 XOR ;       ;METHOD   -->                                                                                                                   METHOD: DESCR  -HEADERS                                           :: DSC>A ?CS: APPL ;            MAC: OFFS! OFFS D! ;            :: >RW >_P3 TO >0P3 ; RECOVER   MAC: >R< APPL -ROT ;            :: >RD >R< TO >RW ; RECOVER     MAC: >W< APPL SWAP ;            :: >WR >W< TO >RW ; RECOVER                                   | :: >CP >W< >0P3 NIP ?CS: SWAP ;                                 : SHOW APPL ? APPE ? DOMN ?D ELEM ?D OFFS ?D ;                   200 A-F: <D-FREE TO DSC>A ; RECOVER   ( -- PREV_DOMAIN_F)       201 A-F: <D-DATA TO DSC>A ; RECOVER   ( -- PREV_DOMAIN  )       202 A-F: >D-FREE TO DSC>A ; RECOVER   ( -- NEXT_DOMAIN_F)       203 A-F: >D-DATA TO DSC>A ; RECOVER   ( -- NEXT_DOMAIN  )       204 A-F: <L-FREE TO DSC>A ; RECOVER   ( -- PREV_ELEMENT_F)      205 A-F: <L-DATA TO DSC>A ; RECOVER   ( -- PREV_ELEMENT  )      206 A-F: >L-FREE TO DSC>A ; RECOVER   ( -- NEXT_ELEMENT_F)      207 A-F: >L-DATA TO DSC>A ; RECOVER          -->                                                                                                                                               5  A-F: L-READ  ( ' A N) TO >RD ; RECOVER      ( READ EL)       6  A-F: L-WRIT  ( A ' N) TO >WR ; RECOVER      ( WRITE OVR)     7  A-F: L-COPY   ( A A' N) TO >WR ; RECOVER    ( COPY OVER)    10  A-F: DEFDOM  ( A ' N ) S>D TO _P2 TO _P3                                      0# DSC>A  TO >P23  ; RECOVER                  12  A-F: L^WRIT ( A A'N) TO >WR ; RECOVER       ( INSWRITE)     13  A-F: L^COPY ( A A' N) TO >WR ; RECOVER      ( INSCOPY)      14  A-F: A-NAME  ( A A N) TO >RW ; RECOVER      ( FULNAM )      15  A-F: L-SET   ( ' # D  -- SETLEN) OVER       ( SETLEN)                      >_P3 DSC>A 0# TO >P23 ; RECOVER                  16  A-F: D-COPY ( A A' A) TO >CP ; RECOVER      ( COPYDOM)      17  A-F: A-COPY ( A A' A) TO >CP ; RECOVER      ( COPYARCH)     18  A-F: A-INFO  ( ' A #) DUP TO >RD ; RECOVER  ( INFOARCH)     20  A-F: L-MOVE  ( A' D 0. ) OVER               ( MOVE ELEM)             >_P3 DSC>A >P23 0# ;     -->                                                                                                                                                           : !CREATE  CREATE C, , DOES> OFFS D@ 2>R                            COUNT B>D  OFFS!  PERFORM  2R> OFFS! ;                                                                                       ' L^WRIT  -1 !CREATE L/INS                                      ' L^WRIT  -2 !CREATE L-APP                                      ' L^COPY  -1 !CREATE L/COPY                                     ' D-COPY  -1 !CREATE D/COPY                                     ' A-COPY  -1 !CREATE A/COPY                                                                                                     : L-INFO  -1# L-SET ;                ( GETLEN)                  : L-FREE   0# L-SET ;                ( DELEMENT)                : D-FREE   0  DEFDOM ;               ( DELDOM)                  : D-INFO  -1  DEFDOM ;                           -->                                                                         \ +ARCH ( A N N )                                                  FUNC: +ARCH ( / _D1 ) SELF TO _D1   ^DSC TO SELF                      ?OPEN 0=  A" SYS?"  2DUP APPL 2!  ( SYSTEM ARCH OK?)            ?-AUTO    A" AUTO?"          ( ÄÇíéåÄíàóÖç ãà Ö?)               ?OPEN IF A-CLOSE THEN        ( áÄíÇÄêüçÖ ?)                     APPL DOMN VSWAP   APPE ELEM VSWAP                               COUNT PAD SWAP  A-NAME    ( èöãçé àåÖ )                         PAD    TO ARES  L/INS        ( ëöáÑÄÇÄçÖ çÄ ÖãÖåÖçí)            _D1 TO SELF ;                                                                                                           ;METHOD       PRUNE     ADOMAINS D@  TO MAC                                                                                                                                                                                                                                                                                                                                                                                                                    -HEADERS  LBL: >D+! R@ D@ D+ POP D! ;M                           : D+! PUSH >D+! ; RECOVER   | : M+! PUSH S>D >D+! ;  RECOVER    METHOD: DESCR                                                   : SREAD PAD DUP 2+ 1L L-READ  TO ARES SWAP! ;                   : SWRITE =" L/INS ;    : SHOWIT SHOW SREAD PAD. ;               : <-> CREATE C, , DOES> COUNT B>D ROT PERFORM D+! SHOWIT ;         ' DOMN  DUP 1 <-> +D    -1 <-> -D                               ' ELEM  DUP 1 <-> +E    -1 <-> -E                            : DOM. -1# ELEM D!  0# ELEMENTS D! BEGIN >L-DATA ?NEL             -WHILE SFLAG IF CR SHOWIT THEN 1 ELEMENTS M+! REPEAT ;        : ARCH. -1# DOMN D!  0# AELEMENTS D!  0# ADOMAINS D!              BEGIN >D-DATA ?NEL -WHILE DOM.  ELEMENTS D@ AELEMENTS D+!          1 ADOMAINS M+! REPEAT ;                                    ;METHOD                        PRUNE   -->                                                                                                                                                      METHOD: DESCR  ( ADR LEN   OLD NEW NEW_LEN _D2 DINAMIC DSC)       FUNC: L-EDIT ( _A1 _L1 / _D1 _D2 _L2 _OK )                        SELF TO _D1   ^DSC TO _D2   _L1  512 ALIGN TO _L2               _D2 TO SELF   1 APPL ! A-CLOSE  T.NAME REMOVE                   T.NAME A-OPEN  _A1 _L2 L^WRIT TO ARES _L2 = TO _OK              _L1 0 L-SET  A-CLOSE  T.NAME COUNT FED                          T.NAME A-OPEN L-INFO TO ARES PAD !  PAD STR L-READ              A-CLOSE   _D1 TO SELF  _OK ;                                ;METHOD        PRUNE    F83                                                                                                    : EL [SEND] DESCR L-EDIT ;                                                                                                                                                                                                                                                                                                      \ ?SAME                                                         : @== ( A1 A2 -- A1' A2' F)                                         SWAP  COUNT  ROT COUNT  ROT - ;                             : ?SAME ( A1 A2 CNT) FOR @== IF 2DROP 0.0 LEAVE THEN NEXT DROP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( 2STACK                                                      ) FORGET IT  128 CONSTANT IT CREATE BUF  128 ALLOT                : IDUMP BUF IT DUMP ;  : ICLEAR BUF IT ERASE ; ICLEAR  IDUMP    ' IOV @   1 NM: 4 SWAP @+! 2! ;M   2 NM: -4 SWAP @+! 2@ ;M      3 MAKER 2STACK> ,     BUF 2STACK> BN>                                                                                           ' IOV @   1 NM: -4 SWAP @+! 2! ;M   2 NM: 4 SWAP @+! 2@ ;M      3 MAKER <2STACK ,     BUF IT + <2STACK <BN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ INFIX                                                         VOCABULARY  INFIX   ALSO INFIX DEFINITIONS                         ' < LIKE > 0 C, 0 C, -1 C,                                     -HEADERS      : ??, 1 ?, ;                                    : ?COMPILE POP STR SWAP PUSH ??, ;                                                                                              0 STACK> OPRC HERE 2+ DUP , AT OPRC !  100 ALLOT                : >OPRC> PUSH BEGIN  OPRC DUP R@ < -WHILE DROP OPRC               ??, REPEAT TO OPRC RDROP ;                                    : 2-OP >IN PUSH ' POP TO >IN CREATE IMMEDIATE ,  ,                  DOES> 2@ PUSH PUSH R@ >OPRC> POP POP TO OPRC TO OPRC ;      : 1-OP 9 2-OP ;                                                  0 NM: ON ;M  1 NM: OFF ;M  2 NM: @ ;M                          |  3 MAKER ??ZN ,    0 ??ZN ?ZN                                 -->                                                                                                                                                                                               4 2-OP =       5 2-OP <      5 2-OP >                           2 2-OP OR      2 2-OP XOR    3 2-OP AND   7 2-OP MOD            6 2-OP +       6 2-OP -      7 2-OP *     7 2-OP /                1-OP ABS       1-OP NEGATE   1-OP NOT                                                                                       : ( 0 TO OPRC ; IMMEDIATE                                       : ) 1 >OPRC> OPRC DROP ; IMMEDIATE                              : VAR VARIABLE  DOES> ?ZN IF @ THEN ; IMMEDIATE                 : := [',] ( ?COMPILE AT ?ZN ; IMMEDIATE                         ' ; ALIAS ;; IMMEDIATE                                          : ; [',] ) ?COMPILE SWAP! ?COMPILE TO ?ZN ; IMMEDIATE                                                                           ;METHOD       PRUNE                                                                                                                                                                              \ FIBONACHI                                                    FUNC: FIBI  ( N / A B )  AT B  1+!  \ ( B ++)                             N  FOR (( ( A + B )  B =: A   =: B  )) NEXT    A  ;                                                                   : FIB 0 1 ROT FOR TUCK + NEXT DROP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \ INFIX                                                         VOCABULARY  INFIX   FORTH ALSO INFIX DEFINITIONS                   ' < LIKE > 0 C, 0 C, -1 C,                                     -HEADERS                                                      0 STACK> OPRC HERE 2+ DUP , AT OPRC !  100 ALLOT                : >OPRC> PUSH BEGIN  OPRC DUP R@ < -WHILE DROP OPRC               1 ?, REPEAT TO OPRC RDROP ;                                   : 2-OP RESCAN 0= ?? CREATE IMMEDIATE ,  ,                           DOES> 2@ PUSH PUSH R@ >OPRC> POP POP TO OPRC TO OPRC ;      |  : 1-OP 9 2-OP ;                                                                                                                                                                              -->                                                                                                                                                                                                                                                                                                                               4 2-OP =       5 2-OP <      5 2-OP >                           2 2-OP OR      2 2-OP XOR    3 2-OP AND   7 2-OP MOD            6 2-OP +       6 2-OP -      7 2-OP *     7 2-OP /                1-OP ABS       1-OP NEGATE   1-OP NOT                                                                                       : ( 0 TO OPRC ; IMMEDIATE                                       : ) 1 >OPRC> OPRC DROP ; IMMEDIATE                              ' TO ALIAS =:  IMMEDIATE                                        : )) [',] ) ;METHOD ; IMMEDIATE                                 TO FORTH                                                        : (( ALSO INFIX DEFINITIONS [',] ( ; IMMEDIATE                  ;METHOD       PRUNE                                                                                                                                                                                                                                             ( DEM - DOMAIN EMPTY  EMP - EMPTY ELEMENT  ELM - ELEMENT      ) :: ^MEM DUP POP RP ROT - DUP TO RP SWAP PUSH DUP ROT ERASE ;     : ?D D@ D. ; : ^DSC 1H TO ^MEM ; RECOVER  : ?NEL AND 1+ 0= ;   :: 0# 0 0 ; :: -1# -1 -1 ; :: FAR-ADR ?CS: SWAP ;                : A-F: PUSH : POP C, DOES>  COUNT PUSH EXECUTE POP FUNA ;       CLASS: DESCR  5. 4. 3. 2 1 F: OFFS ;F AT FA  F: ELEM ;F AT FA    F: DOMN ;F AT FA F: APPE ;F ,   F: APPL ;F ,    ;CLASS        METHOD: DESCR  :: ALABEL APPL 2@ ;  :: ADSC ?CS: APPL ;           218 A-F: AOPEN ( "A ) FAR-ADR TO ALABEL ;  RECOVER             FUNC: ACLOSE ( _NAME ) AT _NAME AOPEN ;                           22 A-F: ?OPEN  ALABEL 0# TO 0# ; RECOVER  ;METHOD             FUNC: ?ARCH ( _ND _NA ) AT _NA [SEND] DESCR ?OPEN                 TO ARES 2 XOR ;                                               FUNC: SYS" ( / _ND _NA ) ='  AT _NA  [SEND] DESCR AOPEN ;      : ?-AUTO ( N N ) 0= SWAP 0= OR ;  1 5 +THRU    PRUNE                                                                                                                                            METHOD: DESCR                                                    FUNC: ARWP ( _A1 _A2 _N ) ?CS: _A1   ?CS: _A2  0 _N ;          :: >RD APPL -ROT ARWP ;  :: >WR APPL SWAP ARWP ;                 : SHOW APPL ? APPE ? DOMN ?D ELEM ?D OFFS ?D ;                    200 A-F: PREVDEM TO ADSC ; RECOVER                              201 A-F: PREVDOM TO ADSC ; RECOVER                              202 A-F: NEXTDEM TO ADSC ; RECOVER                              203 A-F: NEXTDOM TO ADSC ; RECOVER                              204 A-F: PREVEMP TO ADSC ; RECOVER                              205 A-F: PREVELM TO ADSC ; RECOVER                              206 A-F: NEXTEMP TO ADSC ; RECOVER                              207 A-F: NEXTELM TO ADSC ; RECOVER                                                                                                                                                                                                                           ( ARM OBJECT   A - ADDRESS  A' - DSC ADDRESS  N,D - NUMBER   )      5  A-F: READEL ( A' A  N) TO >RD ; RECOVER                      6  A-F: OWRITE ( A  A' N) TO >WR ; RECOVER                      7  A-F: OCOPY  ( A  A' N) TO >WR ; RECOVER                     18  A-F: ARCHI ( A) DUP TO >RD ;    RECOVER                     12  A-F: IWRITE ( A A'N) TO >WR ; RECOVER                       13  A-F: ICOPY  ( A A'N) TO >WR ; RECOVER                                                                                       15  A-F: SETLEN ( A'D) <DSC 0#>< ;                              14  A-F: FULNAM ( A A   N ) PUSH NN>AA POP ;                    10  A-F: DEFDOM ( A A'  N ) PUSH 0# DSC>A POP >NUM ;            20  A-F: MOVELM ( A' D 0. ) SWAP <DSC 0# ;                   ;METHOD  \ : SB>W DUP >< S>D NIP PACK ;                                                                                                                                                                                                                         ( ARM STRUCTURES   "A C-STRING ADDR   RESULT IN ARES          ) : DESCR. [SEND] DESCR SHOW ;      RELINK  SYS" SOMEHOW.DAT"      0. 0. 0.  0  1  DESCR  DSC2      0. 0. 0.  0  0  DESCR  DSC1   METHOD: DESCR      : !CREATE  CREATE C, , DOES> OFFS D@ 2>R       COUNT B>D  OFFS!  PERFORM  2R> OFFS! ;                         ' IWRITE -1 !CREATE !INSEL   ' IWRITE -2 !CREATE APENDEL               : GETLEN -1# SETLEN ;   : DELEM   0# SETLEN ;                   : DELDOM  0  DEFDOM ;   : GETDOM -1  DEFDOM ;           : +ARCH 2DUP 2>R ?-AUTO A" AUTO?"       ( ÄÇíéåÄíàóÖç ãà Ö?)            2R@ ?ARCH IF 2R@ ACLOSE THEN    ( áÄíÇÄêüçÖ ?)                  2R> 0 >DSC DSC! ( ëöáÑÄÇÄçÖ ë èêÖÑÇÄêàíÖãçé àáíêàÇÄçÖ)          COUNT PAD SWAP  FULNAM       ( èöãçé àåÖ)                       PAD    TO ARES  !INSEL ; ( ëöáÑÄÇÄçÖ çÄ ÖãÖåÖçí)        ;METHOD                                                                                                                                                                                                                                                         F83                                                             : PAD. PAD STR TYPE ;                                           2VARIABLE ADOMAINS   2VARIABLE   ELEMENTS                           1 VALUE SFLAG    2VARIABLE  AELEMENTS                       : TOTAL CR ." DOMAINS = " ADOMAINS D@ D.                                ."   ELEMENTS = " AELEMENTS D@ D. ;                                                                                     ( : !DSC TO AR SWAP 4 FOR SWAP !+ !+ NEXT ;)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( READSTR                                                     ) METHOD: DESCR                                                   : SREAD PAD DUP 2+ 1L READEL  TO ARES SWAP! ;                   : SEVAL SREAD PAD STR "EVAL ;                                   : SWRITE =" !INSEL ; : SHOWIT SHOW SREAD PAD. ;                 | : <-> CREATE C, , DOES> COUNT B>D ROT PERFORM D+! SHOWIT ;       ' DOMN  DUP 1 <-> +D    -1 <-> -D                               ' ELEM  DUP 1 <-> +E    -1 <-> -E                            : DOM. -1# ELEM D!  0# ELEMENTS D! BEGIN NEXTELM ARES ?NEL        -WHILE SFLAG IF CR SHOWIT THEN 1 ELEMENTS M+! REPEAT ;        : ARCH. -1# DOMN D!  0# AELEMENTS D!  0# ADOMAINS D!              BEGIN NEXTDOM ARES ?NEL -WHILE DOM.  ELEMENTS D@                   AELEMENTS D+!  1 ADOMAINS M+! REPEAT ;                     ;METHOD                                                                                                                                                                                                                                                         METHOD: DESCR                                                    13 A-F: COPYELI ( A A' N) >WR ;                                       ' COPYELI -1 !CREATE !ELCOPY                               7 A-F: COPYELO ( A A' N) >WR ;                                 16 A-F: COPYDOM ( A A' A) >WR NIP >ADR ;                        17 A-F: COPYARC ( A A' A) >WR NIP >ADR ;                       ;METHOD                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( F: ;F  CLASS: ;CLASS : ?SIZE 0 SWAP FOR R@ 1+ PICK + NEXT ; ) : ;METHOD PREVIOUS      \ END DEFINING METHODS OF CLASS                   DEFINITIONS ; \ CONTINUE COMPILING WITH LAST CONTEXT  ' IOV @ 1-     2 NM: TO SELF ;M                                 2 NM: STR TO CONTEXT TO SELF ;M      3 MAKER INSTANCE ,         : '? 0 BEGIN ' DUP @            \ FIND WORD & IT'S BEHAVIOUR       [ ' AT @ ] LITERAL =         \ ? LIKE 'AT' OR 'TO'             WHILE 2+ C@ + REPEAT + ;      \ GET CORRESPONDING METHOD ADDR                                                                 : ;F [',] ;M '? TO ON;  \ ENDCOMPILE A FIELD                    ; IMMEDIATE             \ & REGISTRATE INITIALIZER              -HEADERS                                                          0 VALUE MHP            \ STATE OF MH BEFOR OPERATION          | 0 VALUE ADRI           \ INITIALIZER ADDR                     -->                                                                                                                             \ METHOD: INHERIT F:  VALUES MHP ADRI                           \ CLASS STRUCTURE 0. INSTANCER  1. INITIALIZER 2. CONTEXTER     \ 3. INVALID NAME 4. CONTEXT  5. VOCABULARY LINK                                                                                : METHOD: ALSO ' 2+ 2+  \ SAVE OLD CONTEXT                                DUP  @  LIT   \ ADDRESS & BEHAVIOUR OF A CLASS CONTEXT [ ' FORTH @ 1+ , ] =?  \ CHECK OK ?                                      EXEC          \ GET CONTEXT OF A CLASS                          DEFINITIONS ; \ USE IT                                : INHERIT METHOD: CONTEXT 2- DUP >R    \ SAVE OLD & GET CONTEXT     2- 2- 254 !                        \ SAVE INHERITED ADR INIT    ;METHOD  R> CONTEXT !              \ LINK WITH PARENT'S     ;                                                               : F: HEADER COMPILE [ 9 FRM @ , ]      \ FIELD NAME & OFFSET         USE: TO ON;  ;     -->            \ START, & REGISTER ADDR                                                                 : SEND NOOP SELF >R  SWAP TO SELF EXEC  R> TO SELF ;            ' SEND DUP @ 1- SWAP!  M: RP @2+! @ SEND ;M  ' SEND 2+ !        : [SEND] METHOD: ' COMPILE TO SEND , ;METHOD ;  IMMEDIATE       : ACTOR CREATE METHOD: ' , ;METHOD , DOES> 2@ SEND ;                                                                            0 NM: DUP PUSH 6 + INSTANCE POP EXEC ;M   TO MHP                                                                                : CLASS: HEADER  0 TO ON;               \ INHERITANCE FLAG          COMPILE [ MHP , ]                   \ INSTANCE CREATOR          >MARK  TO ADRI                      \ INITIALIZER ADDRESS SE    ALSO  HERE                          \ SAVE CURRENT CONTEXT      COMPILE [ ' FORTH @ 1+ , ]          \ VOCABULARY HEADER COM     COMPILE [ 1 C, bl C, ]      2Z,     \ CLASS_CONTEXT,            WORDLIST                            \ & WORDLIST LINK           EXEC DEFINITIONS                    \ CHANGE CONTEXT TO  CUR    MH TO ON;      ;   -->              \ MACROS DP STATE SAVE  : ;CLASS  M: ADRI ! 254         \ START COMPILE INITIALIZER OF A     @ ?DUP IF 254  TO ON;      \ SET ON CLASS BODY & TEST FOR O              TO ON;  THEN      \ IF INHERITANCE - GET INIT \ LI     BEGIN AT ON; @ 252 - WHILE \ MORE FIELDS ? TEST, COMPILE, F       ON; DUP ,                \ COMPILE FIELD INITIALIZER TO C       MH TO MHP                \ SET POINTER TO MHP  - TO CHECK       >MAC                     \ DO IT ON A MACROS DICTIONARY -       MH MHP = IF RECOVER THEN \ DISCARD INITIALIZER OF FIELD I       MHP 252 @ - ON; !        \ CALCULATE OFFSET & SET TO FIEL     REPEAT [',] ;M             \ END COMPILE INITIALIZER OF A C     ON; TO MH                  \ OLD STATE  TO  MACROS DICTIONA     ;METHOD                    \ PREVIOUS CONTEXT -> current        ON; DROP  ;                \ DROP FLAG                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ INHERITANCE                                                     0                                                            CLASS: NUMBER   F: R1 ;F ,  ;CLASS                              METHOD: NUMBER  : SHOW R1 ? ;   ;METHOD                          5 NUMBER FIVE                                                     0 0                                                          CLASS: COMPLEX INHERIT NUMBER   F: I1 ;F , ;CLASS               METHOD: COMPLEX  : SHOW I1 ? SHOW ;   ;METHOD                     1 2 COMPLEX HORSE                                                                                                                0 0 0 0                                                      CLASS: KVATER  INHERIT COMPLEX                                       F: K1 ;F ,    F: J1 ;F ,   ;CLASS                          METHOD: KVATER  : SHOW  K1 ? J1 ? SHOW ;   ;METHOD                9 7 5 3 KVATER QWERTY                                                                                                         \  SWITCH                                                        F83   0 VALUE XK       : WHAT? 7 EMIT ;                        : -: ?E  ' , C,  ON; 2+ DUP TO ON;  ( BYTES FOR MOVE UP 1 )              HERE OVER - DUP PUSH       ( START ADDRESS)                     DUP 1+ ROT                 ( PREPARE FOR MOVE)                  MOVE  HERE C@ POP C!       ( FIX CODE )                ;                                                               : SWITCH: CREATE HERE CSP! 1 TO ON; 0 -:   DOES>                   COUNT 2DUP 4 ROLL DUP TO XK SCAN 1+ 2* + + PERFORM ;         : ;SWITCH  ?CSP ON; 2/ 1- SWAP C! ;                                                                                             \ TEST SWITCH                                                   \ SWITCH: PROBA NOOP  1 -: 2  0 -: bs   2 -: CR                 \ ;SWITCH                                                                                                                                                                                       \ KBD   CONSTANTS                                               : BCONST CREATE C, DOES> C@ STATE IF COMPILE BLIT C, THEN ;        IMMEDIATE                                                    : CONST CONSTANT DOES> @ [',] LITERAL ; IMMEDIATE                72 BCONST kUP       80 BCONST kDOWN     77 BCONST kRIGHT        75 BCONST kLEFT    116 BCONST kcRIGHT  115 BCONST kcLEFT        82 BCONST kINS      83 BCONST kDEL      73 BCONST kPGUP         81 BCONST kPGDN     71 BCONST kHOME     79 BCONST kEND         119 BCONST kcHOME   117 BCONST kcEND     59 BCONST kF1           60 BCONST kF2       61 BCONST kF3       62 BCONST kF4           63 BCONST kF5       64 BCONST kF6       65 BCONST kF7           66 BCONST kF8       67 BCONST kF9       27 BCONST kESQ          68 BCONST kF10      84 BCONST ksF1      93 BCONST ksF10         94 BCONST kCF1     103 BCONST kcF10     15 BCONST ksTAB        104 BCONST kaF1     113 BCONST kaF10      9 BCONST kTAB         ' CTRL  ALIAS  ^  IMMEDIATE                                     0 QUAN XY  | 0 VALUE STEP  \ EDITOR OBJECT                      : |<>| 2DUP 0 SWAP WITHIN IF DROP ;THEN OVER 0< IF + ;THEN - ;  CLASS: EDO   -HEADERS                                               F: -XY ;F  2Z,  0 F: -EDGE  @ ;F  ,  F: -RP ;F  2Z,           0 F: -KEY  PERFORM ;F  ,    0 F: -INIT  PERFORM ;F  ,           0 F: -POS  PERFORM ;F  ,  | 0 F: -RLD   PERFORM ;F  ,         ;CLASS                                                          METHOD: EDO                                                     : XY! -EDGE |<>| TO XY ;  : +XY XY + XY! ;                      : ?+XY CREATE C, DOES> TO C@ DUP TO STEP +XY ;                  | : @KEY KEY UNPACK OVER IF DROP EXIT THEN SWAP ;               : @ED  XY PUSH -XY @ TO XY  RP  -RP !                                -INIT -RLD   BEGIN XY -XY ! -POS @KEY -KEY AGAIN ;         : @EX -RP @ TO RP   POP TO XY ;                                 ;METHOD   PRUNE                                                                                                                 \ SOKOBAN GAME                                                  \ F83  149 LOAD   \ EDITOR OBJECT DEFINITION                    \ F83  147 LOAD   \ SWITCH DEFINITION                           \ F83   14 LOAD   \ TEMPORARY USING DICTIONARY SPACE            VOCABULARY  SOKO ALSO  SOKO DEFINITIONS  0 VALUE LVL ALSO        -HEAD                                                           <%  148 LOAD  %> \ KEYS  DEFINITIONS                            <% 28 BCONST COLS     4 BCONST STENA       3 BCONST POSTAV        0 BCONST PRAZNO     1 BCONST MIASTO      2 BCONST KASHON      504 CONST  PSIZE    126 BCONST PACKSIZE  160 CONST  BLVL        ' XY 8 + ALIAS DIRXY %>   -HEADERS     0 QUAN PUSHES           0 QUAN MOVES   0 VALUE KLETKA   VARIABLE SBK \ WHAT STEP BACK   0 QUAN PTR    10 BARY  CNTRS  PSIZE BARY  POLE                  : CHISTO 0 POLE PSIZE ERASE ;                                   5 BARY PRECOD -4 ALLOT  1 C, 2 C, 4 C, 3 C,                      151 LOAD    ;METHOD   PRUNE SOKO  1 PLAY FORGET SOKO           \ S OKO                                                         : TO-RW 0 POLE TO PTR PACKSIZE CNTDO OVER ;                     : UNPAC  DUP POSTAV AND PRECOD C@ AT PTR  @1+!  C!  TO 2/ ;     : RD TO-RW @ PSIZE OVER U< IF DROP 240 THEN 0 TO PUSHES         0 TO MOVES  TO XY  DO I C@ UNPAC UNPAC UNPAC UNPAC DROP LOOP ;  : PAC AT PTR  @1+! C@ PRECOD C@ PACK TO 2/ ;                    : WR TO-RW XY SWAP! DO 0 PAC PAC PAC PAC I C! LOOP ;            : VIDEO CREATE C, C, DOES> @ UNPACK EMIT EMIT ;                 C" < C" > VIDEO VMIASTO   bl bl VIDEO VPRAZNO                   C" K C" ] VIDEO VKASHON   C" #  C" # VIDEO VSTENA               C" ( C" D VIDEO VBUTACH   C" K C" > VIDEO VPOSTAV                                                                               : DO-TBL CREATE DOES> SWAP 2* + PERFORM ;                        DO-TBL VKLETKA ] VPRAZNO VMIASTO VKASHON VPOSTAV VSTENA [      : VDO AT PTR @1+! C@ VKLETKA ;                                   -->                                                            : POS, CREATE C, DOES> C@ 19 GOTOXY ; 26 POS, >M                  41 POS, >P   49 POS, >P2    33 POS, >M2                       : P2. >P2 PUSHES 5 .R ; : M2. >M2 MOVES 5 .R ;                  : LADR  8 /MOD BLVL + BLOCK SWAP 128 * + ;                      : DO-POS COLS /MOD SWAP 2* SWAP 1+ GOTOXY ; \ XY TO MOVES  DIR  : POS-KLETKA XY DO-POS ; : VIEW1 DUP DO-POS POLE C@ VKLETKA ;   : VIEW PAGE PSIZE 0 DO I VIEW1 LOOP   P2.  M2.                      >M ." MOVES:"  >P ." PUSHES:" HOME ." LVL " LVL .   ;       : LIST DUP TO LVL LADR RD CR VIEW ;  : RLD LVL LIST ;           : E-UPD LVL LADR WR UPDATE ;   : +LVL LVL +  1L  |<>| LIST ;    : L-UP E-UPD 1 +LVL ;          : L-DN E-UPD -1 +LVL ;           : E-INIT 1L 1- AND TO LVL 0 TO DIRXY  0 TO KLETKA ;             : KLETKA! DUP PUSH POLE C! POP VIEW1 ; : ?KLETKA XY VIEW1 ;     : DO-KLETKA  KLETKA  XY  KLETKA! ;                              : TKLETKA XK kF1 - TO KLETKA DO-KLETKA 0 TO DIRXY ;             : E-CLEAR CHISTO LVL E-INIT VIEW ;    -->                       \ SOKOBAN 3      \ TYPE OF  KLETKA  F1 - F5                      AT EDO        \ ?+XY DEFINES NAMES IN DICTIONARY USING EDO     COLS NEGATE  ?+XY E-UP   COLS ?+XY E-DOWN                                -1  ?+XY <-        1 ?+XY ->                           : ENDPOS 1 19 GOTOXY @EX ;                                      : SAME DO-KLETKA  DIRXY +XY ;          ;METHOD                  : E-QUIT E-UPD FLUSH ENDPOS ;                                   : 1STEP DIRXY + ; : NEWXY XY 1STEP ; : WHERE NEWXY 1STEP ;      SWITCH: EF WHAT?   kF1 -: TKLETKA   kF2 -: TKLETKA                kF3 -: TKLETKA   kF5 -: TKLETKA kPGUP -: L-DN                 kPGDN -: L-UP      kUP -: E-UP    kDOWN -: E-DOWN                 kLEFT -: <-   kRIGHT -: ->  ;SWITCH                           SWITCH:  EK  WHAT?  ^ [ -: ENDPOS  ^ Q -: E-QUIT  bl -: SAME            ^ R -: RLD  ^ W -: E-CLEAR 0 -: EF ;SWITCH              PSIZE ' EK    ' E-INIT  ' POS-KLETKA  ' RLD |  EDO GEDIT         AT GEDIT ACTOR EDIT EDO @ED    -HEADERS     -->                \ SOKOBAN 4   - GAME SECTION                                    : CHECK POLE C@ KASHON ;  : ?PUSH CHECK - KASHON U< ;           : ?MOVE CHECK U< ; : CAN?MOVE NEWXY ?MOVE ;                     : CAN?PUSH NEWXY ?PUSH DUP IF DROP WHERE ?MOVE THEN ;           : ?LEVEL 0 CNTRS 10 ERASE  PSIZE 0 DO I POLE C@ 2*  CNTRS 1+!     LOOP 2 CNTRS 2@ OR  0= IF 0 TO SBK  KEY 1 +LVL DROP THEN ;    : DO-MOVE ?KLETKA XY  + TO XY  AT MOVES +! M2. ;                : PUSH/2 DUP POLE KASHON SWAP XOR! VIEW1 ;                      : DO-PUSH NEWXY PUSH/2  WHERE PUSH/2  AT PUSHES +! P2. ;        : TRY XY PUSH  XK EF  POP TO XY    SBK TO 0  \ GET DIRECTION      CAN?PUSH IF 1 DO-PUSH SBK 1+! ?LEVEL  THEN \ TRY TO PUSH        CAN?MOVE IF 1 DIRXY DO-MOVE  SBK 1+! ;THEN \ TRY TO MOVE          WHAT? ;       -->           \ UNPOSSIBLE TO MOVE OR PUSH                                                                                                                                                                                                    \ SOKOBAN   PLAY SECTION                                        : DO-BACK   SBK 0 TO >< ?DUP 0;  1- PUSH                           -1 DIRXY NEGATE DO-MOVE \ MOVE FIRST                            POP IF -1 DO-PUSH  THEN ;                                                                                                    SWITCH: GF  WHAT?      kUP -: TRY    kDOWN -: TRY                    kLEFT -: TRY   kRIGHT -: TRY           ;SWITCH             SWITCH:  GK  WHAT?  ^ [ -: ENDPOS  C" U -: DO-BACK                      ^ R -: RLD    0 -: GF ;SWITCH                                                                                           : POS-BUTACH POS-KLETKA VBUTACH POS-KLETKA ;                    PSIZE ' GK    ' E-INIT ' POS-BUTACH  ' RLD |  EDO GPLAY          AT GPLAY ACTOR PLAY EDO @ED                                                                                                                                                                                                                                    \ LOCALS                                                          0 VALUE FPTR    0 VALUE #V   M: NEGATE 2* FPTR + ;M  TO #V      M: AT #V @ ;M   ' #V !       M: AT #V ! ;M    ' #V 2+ !                                                                       : LOCALS POP FPTR PUSH  RP TO FPTR OVER  AT #V TO RP  PUSH         FOR R@ 1+ TO #V NEXT  CO  FPTR TO RP  POP  TO FPTR ;                                                                         EXIT : LL  5 LOCALS  1 #V .  2 #V .  3 #V . 4 #V .  5 #V . ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ FREAD  - READ FILE OF TEXT  TO BLOCKS                         : FREAD ( NBLOCK) 0  0 16 BLK  HANDLES  6 LOCALS                   FOPEN TO HANDLES FIO -1 TO BLK                                   BEGIN 2 #V 0=                                                     IF 1 #V BLOCK DUP 1K BLANK UPDATE 2 TO #V THEN   3 #V           IF  2 #V 1L   EXPECT2 DROP    THEN                              1L  2 AT #V +!  3 AT #V 1+!    3 #V  4 #V =                     IF 1 AT #V 1+!  0 3 TO #V  0 2 TO #V THEN                       6 #V  HANDLES =                                               UNTIL   FLUSH  5 #V TO BLK                                  ;                                                                                                                                                                                                                                                                                                                                                                                               \                                                               FUNC: EXPECT2 ( _ADR _CNT ) SKIP [ -HEADERS                     ALSO  AT EDO                                                    ': ?CR XY 0 TO XY @EX ;M   ;METHOD                              ': ?CH bl 1-  XK U< IF XK  _ADR  AT XY @1+! + C! XK EMIT                 XY  _CNT = IF ?CR THEN THEN ;M                         ': ?BS XY IF bs EMIT SPACE bs EMIT AT XY 1-! THEN ;M            SWITCH: NK ?CH 0 -: DROP  bs -: ?BS                                            cr -: ?CR  26 -: ?CR ;SWITCH                                                                                      1K  ' NK    ' NOOP ' NOOP  ' NOOP |  EDO  EDLIN                                                                                 ] THEN   AT EDLIN [SEND] EDO @ED [ PRUNE ] ;                                                                                                                                                                                                                   \ TEST OF COROUTINE                                             : +, CO , ;   : CREATE LIT [ AT FORTH 2- @ , ] +, HEADER ;      : VARIABLE 0 +, CREATE ;    : 2VARIABLE 0 +, VARIABLE ;                                                                        \: PERFORM @ ?DUP IF PUSH THEN ;                                 : ^REVERCE ( A1 A2 ) OVER - REVERCE ;  : NUP PUSH DUP POP ;     : ^SWAP ( A1 A2 A3 ) DUP PUSH NUP ^REVERCE                              NUP ^REVERCE POP ^REVERCE ;                             : SWAP OVER PUSH PUSH DROP POP POP ;    \ STACK QUARKS          : NIP  PUSH DROP POP ;  : DRIP NIP  DUP ;   : DIP  DROP DUP ;   : NUP  PUSH DUP POP ;   : TUCK SWAP OVER ;  : TAKE DROP OVER ;  : ?DUP DUP IF DUP THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                        ˇˇˇˇˇˇˇ     ¿     ¿     ¿     ¿     ¿     ¿     ¿¸ˇ  ¿  ¿√/Ä  ¿√   ¿√ ,  ¿ˇø  ¿  ¿Ä¸  ¿   ¿ˇˇˇˇˇˇˇ©ˇˇˇˇˇˇˇW   ¿S#   ¿√   ¿   ¿èÃ   ¿Ôœ    ¿¿    ¿ˇˇ    ¿     ¿     ¿     ¿     ¿     ¿     ¿     ¿     ¿ˇˇˇˇˇˇˇ9 ?     00     ?3     4     ≥3     #2     ≥3     4     ˇ?                                                                    è ˇˇ        #+    c    c“    ò    Lï    åé        ¸ˇ                                                            u  ˇ     √?    0`1    0{1    ºH0    À0    ¿?    ¸√      ˇ                                                                    W      ˇˇ     √’     √’   ˇ√—   0 »¿   0»¿   0Úˇ√   ¸ˇ   ¸       ˛Û   å0    ¸è8     0     ¸?                      £ ˇˇˇ        #!   Cf   ìò   Cf   Éâ	   Cf   ìò   Cf   #!        ˇˇˇ                                      Æ      ˇ    p    #r    œs    Ã@    å0    Ã    ¨¸    Ã          ¸                                               ê   ˇ     √    ˇ?»     √    „˚√?   #Ú0    0   < 24   ?|5    5     ?                                                   ¿µ ˇ    ?¿    ‚    „Ã    è¬    Ã»    ÃÃ    ÃÃ    »    ¸     ¿?                                                  ¿U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ˇ    p    #r    œs    Ã@    å0    Ã    ¨¸    Ã          ¸                                               ê   ˇ     √    ˇ?»     √    „˚√?   #Ú0    0   < 24   ?|5    5     ?                                                   ¿µ ˇ    ?¿    ‚    „Ã    è¬    Ã»    ÃÃ    ÃÃ    »    ¸     ¿?                                                  ¿U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  12308098098090980 090 09 09 0980980980341423401293840123        123fjg;lskdfj;lgskdjf;lkgsjdf;lkg sdflksdlfkjgsd;lfkjgsldfkjg;ld                                                                skfg;lksdfj'lkas d;alsdkf;asldkf;saldf; a;s                     ldf                                                                k                                                            ;asld q                                                         wekqwo asdkf;askd;lfas;dlfa;sldf';sald ;alsdf';qlkj2p34o523p4o;'saldf;asdf;alskd;lfkasd;f a;sldf;asldf;lasdk;fl ;alsdfk;'lsadkf;sd;lf as;ldf;alskdf ;l sad;lfkas;dfksa;l as;dlkf;saldkf;als asd;lfka;sdlkf ;lkd;alksd;al asdfasdf    sd;lfa;sldf;lsd                                                                            0987654321                                                      lsad f;lasd'f;laksd;lfkas;lfd asasd';lfksa;ldkf;sdl as;dlfa's;ldf';lsad ;lasdf';lsakdf;lsad f'; a;sldf;'lsad f;lsa dl;ka;sldfk a                                                                (  EDITOR POSXY WIPE RELOAD SAVEBLK LB N B ARROW)               F83  149 LOAD   \ EDITOR OBJECT DEFINITION                      F83  147 LOAD   \ SWITCH DEFINITION                             F83   14 LOAD   \ TEMPORARY USING DICTIONARY SPACE              ( F83 VOCABULARY EDITOR      ALSO  EDITOR  DEFINITIONS) ALSO     <%  148 LOAD  %>   \ KEYS  DEFINITIONS    -HEADERS              -HEADERS    0 VALUE INS   0 VALUE ADR^ : ADR+ ADR^ + ;         : POSXY XY 1L U/MOD 4 2 TO + GOTOXY ;                           : L/ XY 1L NEGATE AND ;  ( LBEGIN)                              : /L XY 1L 1- OR ; ( LINE END)                                  : RDR HOME ADR^ .BLOCK ;   : LINE/ L/ ADR+ ;                    : LDRAW POSXY LINE/ cr EMIT XY 1L / .LINE ;                     : RLD SCR BLOCK  TO ADR^ RDR DISCARD ;                          : LB FLUSH SCR + TO MAX TO SCR ;    171 LOAD   PRUNE                   ;METHOD   -HEAD                                                                                                          ( COPY POS^ LINE/ /LINE LDRAW EL INSC DELC OVTC INSL DELL LL  ) : L2 1K  XY - 1L - TO MAX ;      : POS^ XY ADR+ ;               : /LINE /L ADR+ ;  : LL /LINE POS^ - ; : P2 POS^ DUP DUP 1L + ;  ALSO AT EDO    \ USE    ?+XY  AND  XY!                         : X-POS 0 18 GOTOXY @EX ;                                       1L NEGATE  ?+XY L_UP    1L  ?+XY L_DN    ( LINE UP/DOWN)        -1 ?+XY <-    1 ?+XY ->  -8 ?+XY <TAB  8 ?+XY TAB>              : ADV> XY 7 OR 1+ XY! ; ( NEXT TABULATION )                     : L_END  /L XY! ;  : L_BEG  L/ XY! ;      ;METHOD               : <_| L_BEG L_DN ;      ( CARRIGE RETURN L_DN L_BEG )           : APOS   0 TO XY ;      ( HOME POSITION OF CURSOR)    -->                                                                                                                                                                                                                                                                                                                                                                                                       : >EL 1K L2 - 1L MIN ; : EL >EL BLANK ; : RDRC RDR UPDATE ;     : DELL P2 SWAP L2 CMOVE L2 +  EL RDRC ; : POSC POS^ DUP 1+ ;    : >INSL P2 L2 TO CMOVE EL ; : INSL >INSL RDRC ;                 : DELC POSC SWAP LL CMOVE bl /LINE C! LDRAW UPDATE ;            : INSC INS IF POSC LL TO CMOVE THEN XK POS^ C! UPDATE ;         : ONEC XK bl U<  IF WHAT? ;THEN INSC LDRAW -> ;                 : _INS [ 75 2 PACK ]  LITERAL UNPACK GOTOXY                        INS 0= DUP TO INS IF ." INS" ELSE ." OVT" THEN  ;            : BS <- DELC ;  : ERLD DISCARD PREV 1+ OFF  RLD ;               : Q/ED  FLUSH  X-POS ;   : ESQ/E EMPTY-BUFFERS X-POS ;          : P "T NIP 0; >INSL POS^ "POP RDRC ;  : C POS^ >EL L_DN "PUSH ; : G C L_UP DELL ;  : N 1 LB RLD ;  : B -1 LB RLD ;              : E-INI _INS _INS ;                                                                      -->                                                                                                    \ MAIN KEYBOARD ASSIGNMENTS                                     SWITCH: EF WHAT?               kLEFT -: <-     kUP -: L_UP       kHOME -: L_BEG   kEND -: L_END  kPGUP -:  B   kPGDN -: N        kDOWN -: L_DN  kRIGHT -: ->   kINS  -: _INS    kDEL -: DELC     ksTAB -: <TAB            ;SWITCH                                                                                               SWITCH:  EK  ONEC   ^ J -: <-  ^ K -: ->     ^ X -:  G            127 -: DELL    bs -: BS        ^ D -: DELC  cr -: <_|          ^ N -: N     ^ B -: B    ^ L -: ERLD   ^ I -: TAB>              ^ C -: C     ^ V -: P    ^ Q -: ESQ/E   ^ Z -: APOS            kESQ -: Q/ED  ^ S -: INSL   0 -: EF   ^ A -: ADV>   ;SWITCH                                                                     1K  ' EK    ' E-INI   ' POSXY  ' RLD |  EDO EDI                                                                                  AT EDI ACTOR E EDO @ED    : EDIT TO SCR PAGE E ;                : HELP SCR PUSH EDIT POP EDIT ;                                \ TARGET  COMPILER                                              \ F83  VOCABULARY  TARGET  ALSO TARGET DEFINITIONS ALSO         : TAR ;            \ TARGET ADDRESS    LAST WORD ADDRESS         0 VALUE  T-OFFS   0 VALUE  T-ADR  0 VALUE T-LAST                VARIABLE T-H      0 VALUE  T-END  : T-HERE T-H @ T-OFFS - ;    : T-SPACE HERE TO T-ADR CLARY HERE TO T-END ;                   : T-ALLOT T-H +! ;   : T-C, T-H @1+! C! ;   : T-,  T-H @2+! ! ; : T-ORG T-ADR TUCK  T-H !  - TO T-OFFS ;    : T-!  T-OFFS + ! ; : T-@  T-OFFS + @ ;  : T-C! T-OFFS + C! ;  : T-C@ T-OFFS + C@ ; : T-STR, FOR COUNT T-C, NEXT DROP ;                             : T-",  COUNT DUP T-C, T-STR, ;                                                                                                 \  TEST   200 TSPACE  300 T-ORG  5 T,  300 T-@ .                \ 6D 30 13 32                                                                                                                                                                                   \ FORWARD WORDS  & FORWARD LABELS                               \ LINXFIX ( A>FIX A-LINK)   FROM RECURCE                        : 2VARIABLE VARIABLE 2Z, ;                                                                                                      : FW 2VARIABLE IMMEDIATE                                             DOES> DUP 1+!   ( USING COUNTER & FLAGS IF DEFINED)                   STR 0< IF @ , ;THEN   ( DEFINED IF)                             LINK+ ;     ( ADD TO LIST OF UNRESOLVED ELSE)        \ FORWARD BRANCH                                                64 WARY BRANCHES                                                : ^BRANCH [',] # DUP 1L U< 0= A"  BR? "  BRANCHES ;             : FB! ^BRANCH DUP @ A" REDEF! " HERE 2+ SWAP! , ;               : FB: ^BRANCH 0 TO >< THEN, ;                                   : FB? 1L 0 DO BRANCHES @ IF I . 7 EMIT THEN LOOP ;                                                                                                                                              \ MAKERS ??? TEST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0 QUAN  AR                                                      CODE +*  AX POP,                                                  1 #, AT AR /// TEST,   0=,  NOT,  IF, AX BX ADD,  THEN,         1 #, BX RCR, 1 #, W/ AT AR /// RCR,  AX PUSH,  NEXT, END-CODE                                                                 : 'UM* TO AR 0 16 FOR +* NEXT AR SWAP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         FUNC: 'UM* ( _M _L / _H1 _H2 )  (  )                             1H FOR  _L 1 AND                                                  IF _M 0 _H1 _H2 D+ TO _H2 TO _H1 THEN                          _L _H1 _H2 2  TO U/MOD  DROP  TO _H1 2 TO U/MOD NIP TO _L         NEXT  _L _H1 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \ LIST OF CHANGES                                               \ REGISTER ASIGNMENTS                                           \  TR   CX - STACK TOP  REGISTER                                \  DP   SP - DATA STACK POINTER                                 \  AR   BX - ADDRESS REGISTER                                   \  RP   BP - RETURN STACK POINTER                               \  WR   DI - WORK REGISTER                                      \  PC   SI - INSTRUNCTION POINTER                               \  BR   DX - ADDRESS REGISTER B                                 \  AXR  AX - SCRACH REGISTER                                    \                                                                                                                                                                                                                                                                                                                                                                                                                                                               PushReg  MACRO                                                          jmp  _PushAx                                                  ENDM                                                      SWAPREG MACRO                                                            JMP _SWAPAX                                                    ENDM                                                    DROPREG MACRO                                                            JMP XDROP                                                      ENDM                                                    next  MACRO                                                                                                                                                                                                                                                                                                                                                                                             jmp  _next                                                    ENDM                                                      SKIP1A  MACRO                                                            DB 60                                                          ENDM                                                    SKIP2A  MACRO                                                            DB 61                                                          ENDM                                                    SKIP2   MACRO                                                            DB 0BFH                                                        ENDM                                                                                                                    MyCseg  segment para  use16                                             assume cs: MyCseg,  ds: MyCseg, ss: MyCseg                                                                                                                                                                                                                      org 100h                                                Start   Label byte                                                      scasw                                                           scasw                                                   _does:  DEC  BP                                                         DEC  BP                                                         MOV  [BP],SI                                            _DOES0: POP  SI                                                         SKIP2A                                                          scasw                                                           scasw                                                   DOVAR:  scasw                                                           xchg AX,DI                                                      PUSHREG                                                                                                                         SCASW  SCASW                                            DOCON:  SCASW                                                           MOV  AX,[DI]                                                    PUSHREG                                                         scasw  scasw                                            setvar: scasw                                                           MOV   [DI],CX                                                   DROPREG                                                 ; ---------------------------------------------------           XSTORM: DEC   BX                ; !-                                    MOV   [BX],CH                                           XSTORCM:DEC   BX                ; C!-                           XSTORC: MOV   [BX],CL           ; C!A                                                                                                                                                                                                                                   JMP   SHORT XDROP                                       XSTORP: XCHG CL,CH              ; !+                                    MOV  [BX],CH                                                    INC  BX                                                 XSTORCP:MOV  [BX],CL            ; C!+                                   INC  BX                                                         JMP  SHORT XDROP                                        XADRSET:MOV   BX,CX             ; A!                                    jmp  short xDROP                                        XRSP1:  MOV   DI,[BP]           ; C!R+                                  XCHG  AX,CX                                                     STOSB                                                           JMP   SHORT XRSP0                                       XRSP2:  MOV   DI,[BP]           ; !R+                                   XCHG  AX,CX                                                                                                                     STOSW                                                   XRSP0:  MOV   [BP],DI                                                   jmp  short xDROP                                        XSTORE: MOV   DI,CX             ; !                                     POP   CX                                                _STORED:MOV   [DI],CX                                           xdrop:  pop  Cx                 ; DROP                                  JMP   SHORT _NEXT                                       XMBRANC:OR    CX,CX             ; -IF                                   jNS   XBRANC                                                    SKIP2                                                   XZBRANC:jCXZ  XBRANC            ; IF                                    LODSB                                                           JMP   SHORT _NEXT                                       XMBRAN: OR    CX,CX             ; -IF                                                                                                   jNS   XBRAN                                                     SKIP2                                                   XZBRAN: jCXZ  XBRAN             ; IF                                    LODSW                                                           JMP   SHORT _NEXT                                       XBRANC: LODSB                                                           CBW                                                             SKIP1A                                                  XBRAN:  LODSW                   ; WORD;                                 ADD   SI,AX                                                     JMP   SHORT _next                                       XWORDC: LODSB                                                           CBW                                                             SKIP1A                                                  XWORD:  LODSW                   ; WORD                                                                                                  ADD   AX,si                                                     XCHG  AX,SI                                                     JMP   SHORT _RPUSH                                      XTOR:   XCHG  AX,CX             ; PUSH                                  POP   CX                                                _RPUSH: DEC   BP                                                        DEC   BP                                                        MOV   [BP],AX                                                   JMP   SHORT _next                                       XEXIT:  mov  si,[bp+0]          ; ;                             xrdrop: inc  bp                 ; RDROP                                 inc  bp                                                         JMP  SHORT _NEXT                                        XFETCH: MOV   DI,CX             ; @                                     MOV   CX,[DI]                                                                                                                   JMP   SHORT _NEXT                                       XFROMR: MOV   AX,[BP]           ; POP                                   INC   BP                                                        INC   BP                                                        JMP   SHORT _PUSHAX                                     XATP:   MOV  AX,[BX]            ; @+                                    INC   BX    INC   BX                                            jmp  short _pushax                                      XRR:    MOV   DI,[BP]           ; @R                                    MOV   AX,[DI]                                                   jmp   short _PUSHAX                                     XATCP:  MOV  AL,[BX]            ; @C+                                   INC  BX                                                         jmp  short _pushaL                                                                                                                                                                      XADRGET:MOV   AX,BX             ; A  ADDRESS REGISTER A                 jmp  short _pushax                                      XOVER:  POP  AX                 ; OVER                                  PUSH AX                                                         JMP  SHORT _PUSHAX                                      XLIT:   LODSW                   ; NUM                                   JMP  SHORT _PUSHAX                                      XBlit:  lodsb                   ; BNUM                          _PUSHAL:xor  AH,ah                                              _PushAx:PUSH CX                                                 _SwapAx:xchg CX,ax                                              _next:  lodsw                   ; NOP                                   SHL  AL,1                                                       JNC  _EX                                                        DEC  SI                                                                                                                         MOV  AH,255                                             _ex:    xchg di,ax                                                      jmp  pw [di]                                            ; ---------------------------------------------------           xnip:   pop  Dx                 ; NIP                                   JMP  SHORT _next                                        XRAT:   mov  Ax,[bp]            ; R@                                    JMP  SHORT _PUSHAX                                      X2SLS:  SAR  CX,1               ; 2/                                    JMP  SHORT _next                                        X2STAR: SHL  CX,1               ; 2*                                    JMP  SHORT _next                                        XDUP:   PUSH CX                 ; DUP                                   JMP  SHORT _next                                        XORE:   POP  AX                 ; OR                                                                                                    OR   CX,AX                                                      JMP  SHORT _next                                        XAND:   POP  AX                 ; AND                                   AND  CX,AX                                                      JMP  SHORT _next                                        XXORX:  POP  AX                 ; XOR                                   XOR  CX,AX                                                      JMP  SHORT _next                                        XNOT:   NOT  CX                 ; COM                                   JMP  SHORT _next                                        XPLMUL: TEST  CL,1                                                      JZ   _NEXT                                                      POP   AX                                                        PUSH  AX                                                        JMP   SHORT _PLUS                                                                                                       XPLUS:  POP  AX                 ; +                             _PLUS:  ADD  CX,AX                                                      JMP  SHORT _next                                        XSWAP:  POP  AX                                                         JMP  SHORT _PUSHAX                                      XROT:   POP  DI aX      ; AX DI CX->                                    PUSH DI         ; DI CX AX                                      JMP  SHORT _PUSHAX                                      XMROT:  POP  aX DI      ; DI AX CX->                                    PUSH Cx DI      ; CX DI ax                                      swapReg                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;------------------------------                                                                                                 XRET4TH:PUSH  SI         ;   F>C;                                       MOV   SI,[BP]                                                   INC   BP                                                        INC   BP                                                        RET                                                     XFROMF: JMP   SI         ;   F>C                                SUB4TH: DEC   BP         ;   :C>F                                       DEC   BP                                                        MOV   [BP],si                                           J4th:   POP   SI         ;   C>F                                        NEXT                                                    XDOS:   XCHG  AX,CX                                                                                                                     POP   BX CX DX                                                  INT   21H                                                       PUSH  DX CX BX AX                                               JC    _DOS                                                      XOR   AX,AX                                             _DOS:   SWAPREG                                                 ; ---------------------------------------------------           MyCseg  ends                                                            end  Start                                                                                                                      CLD                                                             MOV   AX,OFFSET COLD                                            JMP   AX                                                COLD    DW    0                                                 WARM    DW    0                                                : ?V  NEGATE 2* 7 FRM @ @ + ;  -HEAD  |  : WORD. DUP .H ID. ;   | : ?CODER CREATE C, DOES> C@ PUSH DUP N>C POP + @ 2 ?V @ = ;   0  ?CODER ?CFA0    2  ?CODER  ?CFA1   4  ?CODER  ?CFA2          | : FOUND DUP COUNT #LEN AND  HERE COUNT TO -TEXT 1+ NIP NIP ;  | : ?OUT OUTC 1H ALIGN DUP 80 = IF CR DROP ;THEN OUTC - SPACES ; | : VOC. 2- DUP @ 728 - IF 2- THEN C>N DROP WORD. ." VOC: " ;  : VOCS. VOCLINK   BEGIN ?DUP  WHILE DUP 2-  VOC.  @ REPEAT ;    | FUNC: ALL-WORDS. ( ?CMP ?COD / _C1 _C2 _V _L )  AT MACROS 2+  VOCLINK OVER ! CR BEGIN ?DUP WHILE DUP 2- DUP BEGIN @ ?DUP      WHILE ?CMP EXEC IF DUP WORD.  ?OUT  AT _C2 1+! THEN  N>C 2-     REPEAT DROP _C2 IF AT _C2 0 TO >< AT _C1 +! DUP CR VOC. CR      THEN @ REPEAT _C1 CR ." TOTAL: " . ; : ALL. ' SWAP ALL-WORDS. ; : WHERE BLWORD DROP ['] FOUND 0 ALL-WORDS. ;   PRUNE                                                                                                                                                                                                            \   EXPECT2                                                     FUNC: EXPECT2 ( _ADR _CNT ) SKIP [ -HEADERS                     ALSO  AT EDO                                                    ': ?CR XY 0 TO XY @EX ;M   ;METHOD                              ': ?CH bl 1-  XK U< IF XK  _ADR  AT XY @1+! + C! XK EMIT                 XY  _CNT = IF ?CR THEN THEN ;M                         ': ?BS XY IF bs EMIT SPACE bs EMIT AT XY 1-! THEN ;M            SWITCH: NK ?CH 0 -: DROP  bs -: ?BS                                            cr -: ?CR  26 -: ?CR ;SWITCH                                                                                      1K  ' NK    ' NOOP ' NOOP  ' NOOP |  EDO  EDLIN                                                                                 ] THEN   AT EDLIN [SEND] EDO @ED [ PRUNE ] ;                                                                                                                                                                                                                   \ FREAD  - READ FILE OF TEXT  TO BLOCKS                         210 LOAD  \ EXPECT3                                                                                                             FUNC: FREAD ( _NBLK / _ADR _LIN _BLK _HND )                       HANDLES TO _HND  BLK TO _BLK   FOPEN TO HANDLES FIO -1 TO BLK   BEGIN  _LIN  1H =                                                 IF AT _NBLK 1+!  0 TO _LIN  0 TO _ADR THEN                           _ADR 0=                                                    IF _NBLK BLOCK DUP 1K BLANK  UPDATE TO _ADR  THEN _LIN          IF _ADR 1L   EXPECT3 CR  THEN                                             \  EXPECT2 DROP    THEN                               1L AT _ADR +!  AT _LIN 1+!                                      _HND  HANDLES =                                               UNTIL   FLUSH  _BLK TO BLK  _NBLK 1+ TO SCR  ;                                                                                                                                                                                                                \        FLOAD STARTING.TX                                      \        FLOAD ENGINEM.TX                                       \        FLOAD COMPILE.TX                                               FLOAD CONTROL.TX                                                FLOAD MAKERS.TX                                                 FLOAD STRINGS.TX                                                FLOAD CMD.TX                                                    FLOAD LOCALS.TX                                                                                                                 FLOAD NUMOUT.TX                                                 FLOAD MISC.TX                                                   FLOAD DEBUG.TX                                                  FLOAD BLOCKS.TX                                                 FLOAD FORGET.TX                                                 FLOAD WORDS.TX                                          \       FLOAD STARTING.TX                                        : TRACE ' TR EXEC TO TR ; IMMEDIATE                             ' EXIT 4 + ALIAS BYE                                            : C" TO WORD 1+ C@ [',] LITERAL ; IMMEDIATE                     : ['] ' ?C TO , AT , , ; IMMEDIATE                              : 1Z, 0 C, ;                                                    : ( C" ) WORD DROP ; IMMEDIATE                                  : LIKE @ HEADER , ;    ' bl LIKE 1K  1024 ,                     : -HEAD AT HERE SPTR 1K AT 2* - AT VSWAP TO ! 0 TO HEADER ;     -HEAD                                                           : NM: NEGATE HERE SWAP [TO] DOES> HERE 2- AT + ] ;              : M: HERE AT , [ ' WORD @ 1+ DUP @ + 2+ , ] [AT] DOES> ] ;      : JM: M: 5 HERE 2- AT + ;                                       : LBL: HEADER TO , [ ' INTERPRET 2+ @ , ]  ] ;                                                                                                                                                 \       FLOAD STARTING.TX                                                                                                        ' (" 4 + ALIAS ".  ' (" 2+ ALIAS (".                            : LINK+ HERE TO >< , ;                                          : W, TO COUNT , ;    ' >MARK 4 + ALIAS 2Z,                      : N,   (FOR [ >MARK ]  ,       TO (FOR [ TO >MARK ]  ;          : NW,  (FOR [ >MARK ]  W,      TO (FOR [ TO >MARK ]  ;          : STR, (FOR [ >MARK ] COUNT C, TO (FOR [ TO >MARK ] DROP ;      : MAKER CREATE DUP C,  N, ' , DOES> COUNT HEADER NW, AT EXEC ;   AT FORTH  2- DUP @ SWAP  2- DUP @ SWAP 2- @ 3 MAKER MAKEVOC 2Z,                                                                : WORDLIST VOCLINK LINK+ ;                                      : VOCABULARY TO FORTH MAKEVOC WORDLIST ;                                                                                        MAKEVOC MACROS                                                  VOCABULARY HIDDEN                                              \       FLOAD STARTING.TX                                                                                                        ' bl       @  1 MAKER CONSTANT ,                                ' SCRH  TO @  2 MAKER VALUE ,                                   ' INITW TO @  2 MAKER VECTOR ,                                  : PREVIOUS  AT ORDER# TO CONTEXT ;                              : ALSO CONTEXT TO ORDER# ;                                      : DEFINITIONS CONTEXT TO CURRENT ;                              : ONLY ORDER# TO 0 FORTH ALSO MACROS ALSO HIDDEN ALSO ;         ONLY                                                                                                                                                                                            1 TO HEADER                                                     : 'C CREATE , IMMEDIATE DOES>  ?C @ ,  C" " WORD ", ;                                                                                                                                          \       FLOAD STARTING.TX                                                                                                         ' IOV @  ' SCRH  TO @ 1- SWAP 1- SWAP 3 MAKER QUAN  ,           ' IOV @  1 NM: AT 2+ ! ;M 2 NM: AT 2- @ ;M 3 MAKER STACK> ,     ' IOV @  1 NM: AT 2- ! ;M 2 NM: AT 2+ @ ;M 3 MAKER <STACK ,     ' IOV @  1 MAKER VARIABLE 2Z,                                                                                                    256 DUP <STACK ON; ,   ( "," FOR FAST COMPARING BELOW)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \        FLOAD CONSTANT.TX                                                                                                                                                                                                                                        1028 CONSTANT B/BUF                                               16 CONSTANT 1H                                                  31 CONSTANT #LEN                                                64 CONSTANT 1L                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \        FLOAD ENGINEM.TX                                                                                                          0 VALUE MH                                                      HERE C" ; STACK> MAC: ,                                         : EXECUTE >R ;                                                                                                                4 TO HEADER                                                       TIB DUP <STACK MS ,                                              : SWAPH    HERE MH TO HERE TO MH ;                           LBL: >IO_POS  TO >IN TO BLK TO INTERPRET [                      LBL: _TEVAL   0 SWAP TIB - >IO_POS [                                                                                              0 NM: BLK >R >IN >R EXECUTE R> TO >IN R> TO BLK ;M                                                                              HEADER         LOAD , ] 0 >IO_POS [                             ' LOAD LIKE    EVAL   ] _TEVAL [                             \        FLOAD ENGINEM.TX                                                                                                            0  ( SAVE PLACE FOR "C"-STYLE STRING "LENGTH" PROCEDURE )       M: TO MH AT MACROS ! ;M                                         M: AT MACROS @ MH ;M                                          HEADER MAC , , ,                                                                                                              1 TO HEADER                                                       : MAC> CREATE AT MAC: @  WORD COUNT STR, 1Z,                         IMMEDIATE DOES>                                                 AT DROP BLK >IN TO MS TO MS _TEVAL ; AT ALLOT            : >MAC SWAPH CURRENT >R TO MACROS EXEC R> TO CURRENT SWAPH ;                                                                       M: ['] MAC> >MAC ;M                                             ' MAC: !                                                        : ?MAC ' 2+ AT MAC TYPE ;                                   \        FLOAD ENGINEM.TX                                                                                                           M: AT MAC: @ [',] C" AT MAC: ! MAC: AT MAC: ! ;M                ' MAC: 2+ !                                                     : -MAC TIB DUP AT MS TO ! 0 MPTR TO MAC ;                    LBL: _EOL AT MS TO @ - 0; MS MS >IO_POS [                            -MAC ' _EOL TO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \        FLOAD MACRO.TX                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( COMPILE.TX)                                                                                                                   : WITHIN OVER - >R - R> U< ;                                    : CLARY HERE OVER ERASE ALLOT ;                                 : BARY HEADER TO , [ ' ORIGIN+ 2+ @ 2+ 2+ , ] CLARY ;           : WARY HEADER TO , [ ' ORIGIN+ 2+ @ 2+    , ] CLARY ;           : QARY HEADER TO , [ ' ORIGIN+ 2+ @       , ] CLARY ;           : 5ARY HEADER TO , [ ' ORIGIN+ 2+ @ 2-    , ] CLARY ;           : TARY HEADER TO , [ ' ORIGIN+ 2+ @ 2- 2- , ] CLARY ;           ' (". 'C ."         ' (" 'C "          ' ABORT 2+ 'C  A"        : 'STR, DUP C, STR, ;                                           : ," TO WORD ", ;                                               : .( C" ) WORD ". ; IMMEDIATE                                   : 0" HERE 2+ [',] " 1Z, TO 1+ ; IMMEDIATE                                                                                                                                                      \   EXPECT3                                                     FUNC: EXPECT3 ( _ADR _CNT / _IND _K )                             BEGIN  KEY B>W DUP TO _K                                         CASE                                                              cr OF  _IND  TO _CNT ENDOF                                      bs OF _IND                                                        IF AT _IND 1-! bs EMIT SPACE bs EMIT THEN ENDOF               #LEN _K U< IF _K  _ADR  AT _IND @1+! + C! _K EMIT THEN        ENDCASE     _IND _CNT =                                        UNTIL _IND TO SPAN ;                                                                                                                                                                                                                                                                                                                                                                                                                                          \ CONTROL                                                                                                                        2 TO HEADER                                                     : (B CREATE , IMMEDIATE DOES> ?C @ ,  >MARK 2 ;                 : (L CREATE , IMMEDIATE DOES> ?C @ , 1 =?  , ;                  ( : IF   ?C TO , TO (BR  >MARK 2 ;  IMMEDIATE)                  ( : -IF  ?C TO , AT (BR  >MARK 2 ;  IMMEDIATE)                  : ELSE ?C 2 =? TO ,  (BR >MARK SWAP TO >MARK 2 ; IMMEDIATE      : THEN ?C 2 =? TO >MARK ;         IMMEDIATE                     ' (BR       (B   SKIP                                           ' (BR 2+    (B   IF                                             ' (BR 2+ 2+ (B  -IF                                                                                                             : \ BLK 1 -1 WITHIN IF >IN 63 OR 1+ TO >IN                         ELSE -1 WORD DROP THEN ; IMMEDIATE                           \ : UNTIL ?C 1 =? TO , TO (BR , ;   IMMEDIATE)                                                                                  \ : -UNTIL ?C 1 =? TO , AT (BR , ;  IMMEDIATE)                  \ : AGAIN ?C 1 =? TO , (BR  , ;     IMMEDIATE)                  ' (BR        (L   AGAIN                                         ' (BR 2+     (L   UNTIL                                         ' (BR 2+ 2+  (L  -UNTIL                                                                                                         : BEGIN ?C HERE 1 ;               IMMEDIATE                     : WHILE  1 =? 1 [',] IF  ;        IMMEDIATE                     : -WHILE 1 =? 1 [',] -IF ;        IMMEDIATE                     : REPEAT >R  >R  [',] AGAIN R>  R>  [',] THEN ; IMMEDIATE       : ?DO ?C TO , TO (DO >MARK HERE 3 ;              IMMEDIATE      : DO ?C  TO , (DO >MARK HERE 3 ;  IMMEDIATE                     : LOOP ?C 3 =?  TO , (LP , TO >MARK ;            IMMEDIATE      : +LOOP ?C 3 =? TO , TO (LP , TO >MARK ;         IMMEDIATE      : FOR ?C TO , (FOR >MARK 6 ; IMMEDIATE                                                                                          : NEXT ?C 6 =? TO , TO (FOR TO >MARK ; IMMEDIATE                : CSP! CSP SP TO CSP ;                                          : ?CSP SP CSP - A" SP CHG!" TO CSP ;                            : CASE ?C CSP! 4 ;  IMMEDIATE                                   : OF 4 =? TO , (OF >MARK 2 5 ;  IMMEDIATE                       : ENDOF 5 =? [',] ELSE 4 ;     IMMEDIATE                        : ENDCASE 4 =? TO , DROP  BEGIN SP CSP -                          WHILE [',] THEN  REPEAT TO CSP ; IMMEDIATE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( MAKERS.TX)                                                                                                                    TO HIDDEN                                                                                                                       ( WITH-ADDR  ROOTLINK_ADR WITH-ADDR  - )                        M: ( FIXLINX) BEGIN OVER TO >< ?DUP -UNTIL DROP ;M  TO ON;        0 NM: AT CURRENT N>C OVER ( FIXLINX) [ >MARK TO ON; ] TO 0 ;M                                                                   1 NM: LINK+ ;M                                                2 MAKER RECUR ,                                                                                                                 TO FORTH                ( AT RECURCE - FIXLINX)                   0 RECUR RECURCE  HERE ON; !  ON; ,  IMMEDIATE                                                                                                            -->                                                                                                  ( MAKERS.TX)                                                                                                                        M: ON; >R ;M       ( THIS IS "AT CO")                           M: R> TO ON; AT ,  [ >MARK TO ON;   ] TO ON; ;M                 ' RP 4 + @ (  v--       --v  "DO" ">RELEASE" TRICKY WAY)    TO HIDDEN                                                       HEADER CO  3 N,  HERE 2- ON; !                                                                                                  TO FORTH                                                        : ; [',] ; [TO] RECURCE                                              BEGIN AT ON; TO @ - WHILE ON; EXEC REPEAT ; IMMEDIATE                                                                                                                                                                                                                                                                                                                                     (  BYTE SIZE LEN STRING WORDS)                                   TO HIDDEN                                                                                                                       \ STR   ( A - A' N )    = WCOUNT                                \ TO STR ( A1 N A2 - )  = S!                                    \ AT STR ( A1 N A2 - )  = S+!                                   (  CELL SIZE LEN STRING  WORDS                                )                                                                 : S+C! ( C A - ) SWAP PUSH RP 1 ROT  AT STR RDROP ;             : "T SPTR STR ; ( -- A N )   : "N SPTR STR + STR ;              : "DROP "T + TO SPTR ; : "POP ( A --) "T ROT SWAP CMOVE "DROP ;                                                                 : "ALLOT ( N -- N A )  DUP 2+ AT SPTR TO @+! ;                  : "BUFF  ( C N -- ) "ALLOT ! "T ROT FILL ;                      : "PUSH  ( A N -- ) "ALLOT OVER PUSH 2+ SWAP MOVE POP SPTR ! ;                                                                                                                                  : "INS   ( A N -- ) "T PUSH TO SPTR "PUSH POP SPTR +! ;         | : ?INS" ( C -) CREATE C, DOES> PUSH SP POP C@ "INS DROP ;     1 ?INS" C"INS       2 ?INS" W"INS                              \ : "SWAP [ MAC: RVR TO /STR DUP PUSH REVERCE ; ] "N RVR  "T RVR \   SPTR  POP POP + REVERCE ;                                   : ">' SPTR "DROP COUNT OVER C! ;                                : NUP PUSH DUP POP ;                                            : 2REV DUP PUSH NUP REVERCE NUP REVERCE POP REVERCE ;           : "SWAP SPTR 2 FOR DUP STR + NEXT 2REV ;                        : "CUT ( N --) "T ROT 2DUP 0 WITHIN -IF DROP DUP THEN ( A N N)      -ROT PUSH 2DUP + 2- TO SPTR SWAP "PUSH POP SPTR @ - "T + ! ;                                                                : "+ "SWAP "T "DROP "INS ;   : '>" COUNT "PUSH ;                : =' C" " WORD '>" ">' ;     : =" =' COUNT ;                                                                                                                                                    : "EVAL "PUSH 0 1 "BUFF "+ "T DROP EVAL "DROP ;                 : "P>OS "PUSH bl C"INS "+ ">' SHELL ;                                                                                             0. "PUSH  0.  "PUSH    ( EMPTY STACK ELEMENT )     TO FORTH   CREATE T.NAME ," TEMP.TXT                                       : FED " EDT" '>" "P>OS ;        : REMOVE " DEL" '>" "P>OS ;                                                                                                                                     ( "STR "COPY "+ "LEN "LEFT "RIGHT "MID "INS "DEL ", "MAKE )     \ : COPY' OVER C@ 1+ CMOVE ;  : MAKE' PAD TUCK C! COUNT CMOVE PAD ;                                                             \ : "LEFT SWAP COUNT ROT MIN "MAKE ; : N>" D# "MAKE ;           \ : "RIGHT OVER C@ MIN >R COUNT + R@ - R> "MAKE ;               \ : "BEG HERE 2+ HERE ! ; | : "END HERE TO COUNT OVER - "MAKE ;                                                                                                                                 \ : "PAD! PAD TO STR ;  : =" C" " WORD COUNT ;                  \ : "PAD+! PAD AT STR ;                                         \ : +C" 92 C! 92 1 "PAD+! ;  : +0" 0 +C" ;                      \ : "MID >R OVER C@ OVER 1- - TO MAX R> MIN >R + R> "MAKE ;     \ : "INS "BEG TO DUP COUNT ROT 1- MIN DUP >R ("+ ROT COUNT      \ ("+ NIP COUNT R@ - SWAP R> + SWAP ("+  "END ;                \ : "DEL ( DST POS LEN) "BEG SWAP 1- DUP 3 AT OVER COUNT ROT MIN \ ("+ + SWAP COUNT 2 AT OVER - TO MAX TO ROT + SWAP ("+ "END ;  \ : +C' 1 SWAP PACK >R  RP +' RDROP ;  : +0' 0 +C' ;                                                                                                                                                                                                                                                                                                                                                                                                           ( SHELL DOSCMD" ED DIR DEL CD RD REN CMD> CLS                 )  | : CMD0  CREATE =" 'STR, ;                                     \ | : CMD1" CMD0 DOES> SHELL ;                                  \ CMD1" TED EDT TEMP.TXT"                                       | : CMD2" CMD0 DOES> '>" =" "P>OS ;                             CMD2" DOS COMMAND /C"                                           CMD2" ED EDT"                                                   CMD2" DIR DIR /O"                                               CMD2" DEL DEL"                                                  CMD2" CD CD"                                                    CMD2" RD RD"                                                    CMD2" REN REN" ( CMD1" CLS CLS")                                CMD2" ATEST ..\AFD.COM"                                         \ : VIEW " TYPE " ='  +' "  | MORE" +' SHELL ;                  ( : MF7 LIT" MF7 LOADF MINI2.4TH " SHELL ; )                                                                                   \ : EDNO CO 1 . ; : DVE CO 2 . ; : TRI CO 3 . ;                 \ : PROBA EDNO DVE TRI ." PROBA " ;                             M: 7 FRM @ ;M  VALUE FRAME                                      M: AT FRAME ! ;M   M: AT FRAME @ ;M  ' FRAME 2!                 0 VALUE CO-PTR                                                  0 NM:  FRAME PUSH RP   CO-PTR !  DUP  TO CO-PTR @  TO RP            POP  TO FRAME ;M   1 NM: ;M  2 MAKER CO-VAR                 0 CO-VAR MAIN                                                   : CO-INI ( CO-PARAMS... CO-ADR CO-VAR )                            ( RET-ADR FRAME)  FRAME PUSH  RP MAIN DUP TO CO-PTR !             0 TO FRAME   @ TO RP  EXEC ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( ARGS /ARGS  ?END                                            )                                                                 ONLY HIDDEN ALSO FORTH DEFINITIONS                              : /LOCALS COMPILE [ 1 FRM , ] ; IMMEDIATE                                                                                       TO HIDDEN                                                       : ?END >IN  >R BLWORD COUNT 1-     IF DROP -1 ELSE C@ THEN         SWAP COUNT  ROT SCAN 1+ DUP   IF RDROP ELSE R> TO >IN THEN   ;                                                               | : 1VAR DUP 1 9 WITHIN                                             IF LIT [ 7 FRM @ , ] SWAP AT 2* NEGATE + ALIAS                  ELSE HEADER 2 FRM W, W, W, 2* NEGATE , IMMEDIATE THEN       ;                                                               MAC  CSP!                                                                                                                                                                                       MAC: LVAR  ['] 1VAR >MAC ;                                                                                                      FLOAD  LOCALMAC.TXT                                                                                                             ( (ARGS LOCALS( PROC                                          )                                                                 | : (ARGS  1 769 LOC/                                             BEGIN 0" /)" ?END DUP 2 < ( 0 WRD 1 /)                          WHILE IF L1@ IF 0 L1! ELSE 1 A" / >1 ?" THEN                          ELSE  L2@ 1+ DUP L2!  LVAR  L1@                                    IF L3 ELSE L4 THEN    1+!                                    THEN                                                      REPEAT DROP  L3@ L4@ PACK /LOC                                ;                                                                                                                               ?CSP TO MAC      TO FORTH                                                                                                       : LOCALS( (ARGS COMPILE [ 0 FRM , ] ,                           ; IMMEDIATE                                                                TO FORTH                                             : ':  HEADER DO: ;                                              : : MAC CSP! : TO CO ?CSP TO MAC ;                              : :: :  RECOVER  ['] INTERPRET STR , @ , ;                                                                                        8 FRM ALIAS RETURN  ( DEFINE RETURN PROCEDURE )               : FUNC: : RECOVER  ( MOVE H BACK 1 CELL TO CLEAR XNEST)           C" ( BLWORD 1+ C@ =? (ARGS                                          COMPILE [ 5 FRM @ , ] ,    TO CO                                RECOVER ( EXIT TOKEN )   COMPILE RETURN  ;                 F83                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( BARY PAD SPACES <# #> # #S SIGN D# D.R D. .R . U.           )                                                                 : DIG. ALPHA EMIT ;     : PAD HERE 320 + ;                      : 1H. 1H 1- AND DIG. ;  : 1B. 1H /MOD 1H. 1H. ;                 : 1W. UNPACK 1B. 1B. ;  : 1D. 1W. 1W. ;                         : SPACES TO MAX FOR SPACE NEXT ;                                : UM/MOD TUCK U/MOD PUSH  SWAP TO U/MOD POP ;                   : 1# BASE UM/MOD  AT HLD 1+! ;                                  : S# AT HLD  OFF BEGIN 1# 2DUP OR -UNTIL 2DROP ;                : D# IF DABS S# -10 AT HLD 1+! EXIT THEN S# ;                   : D.R PUSH D# POP HLD - SPACES HLD FOR DIG. NEXT ;                                                                              : D. S>D 0 D.R SPACE ;          : .R PUSH S>D S>D POP D.R ;     : . S>D D. ;                    : U. 0 D. ;                     : U.R  0 0 ROT D.R ;            : UD. 0 0 D.R SPACE ;           : UD.R 0 SWAP D.R ;             : .H 1W. SPACE ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( FIXES ON WORDS)                                               : ALIGN 1- SWAP 1- OR 1+ ;                                      : RESCAN >IN -FIND ROT TO >IN ;                                                                                                   M: RESCAN NIP 0; CR   HERE ". ."  EXIST ! "                       BLK 1- 0>= 0; ." IN BLK " BLK .  ;M                                                                                           260 !   ( 104 IN HEX)                                                                                                         M: DUP BEGIN COUNT -UNTIL 1- OVER - ;M      ' MAC 4 + !                                                                         : .. BASE PUSH DECIMAL .R POP TO BASE ;                         : HOME 0 0 GOTOXY ;                                             : PAGE (CLSC HOME ;                                                                                                             : ?EMIT DUP bl < IF DROP C" . THEN EMIT ;                       : ?TYPE FOR COUNT ?EMIT NEXT DROP ;                             : .LINE 3 .. SPACE 1L ?TYPE ;                                   : .BLOCK CR ." Scr# " SCR 6 .. 1H 0                                   DO CR DUP I .LINE 1L + LOOP DROP ;                        : CTRL TO WORD 1+ C@ #LEN AND [',] LITERAL ; IMMEDIATE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          : TRACE ' TR EXEC TO TR ; IMMEDIATE                             : WW DUP H. DUP @ DUP H. ?ID. 2+ ;  ( DEBUG ONE ADDRESS)        | : DUMPLINE  CR DUP 1W. 1H 2DUP FOR COUNT SPACE 1B.            NEXT DROP SPACE C" [  EMIT ?TYPE C" ] EMIT ;                    : DUMP 1H ALIGN 1H / FOR DUP DUMPLINE 1H + NEXT DROP ;          \ : 'W DUP H. TO COUNT DUP H. ;                                 \ : 'B DUP H. COUNT DUP H. ;                                    \ : 'S DUP H. DUP ". COUNT + ;                                  : WDS FOR CR WW NEXT ;  : SEE ' 2+  1H WDS ;                    : ? @ . ;                                                       ( : #S. 2- OVER MAX ?DO I @ . -2 +LOOP ;)                       | : #S. CR ".                                                   [     MAC: -WCOUNT 2- DUP @ ;                                         MAC: ?ITEMS TO DUP - NIP 2 / 1- ;                                                                                               MAC: ?STACK DUP 0< A" STACK UNDERFLOW" ;                  ]   ?ITEMS ?STACK FOR -WCOUNT . NEXT DROP C" ] EMIT ;           : S. S0 SP " S[ " #S. ;  : R. R0 RP " R[ " #S. ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 0 NM: C@ PREV C! ;M  DUP     TO HIDDEN                           HEADER DISCARD ,   0 C,     TO FORTH                            HEADER UPDATE  ,  -1 C,                                                                                                       TO HIDDEN                                                       : EMPTY-BUFFERS FIRST LIMIT OVER - ERASE                            LIMIT FIRST DO  -1 I 1+ ! B/BUF +LOOP ;                                                                                     EMPTY-BUFFERS                                                   | : +BUF B/BUF + DUP LIMIT = IF DROP FIRST THEN DUP PREV - ;    | : BUFFER USE DUP >R  BEGIN +BUF UNTIL TO USE R@ COUNT            IF DUP TO COUNT TO NBLK 0 R@ C! THEN  R@ TO PREV ! R> 3+ ;   : SAVE-BUFFERS LIMIT FIRST ?DO I C@ IF I COUNT I TO XOR             TO COUNT TO NBLK THEN B/BUF +LOOP ;                                                                                         : -USE SCRH 1+ IF SCRH CLOSE DROP -1 TO SCRH THEN ;             TO FORTH                                                        : FLUSH SAVE-BUFFERS EMPTY-BUFFERS ;                            : USING FLUSH -USE FOPEN TO SCRH ;                              : BLOCK >R PREV DUP 1+ @ R@ - IF                                   BEGIN +BUF 0=  IF DROP R@ BUFFER DUP R@ NBLK 2- 1- THEN           DUP 1+ @ R@ =                                                 UNTIL   DUP TO PREV  THEN                                         AT DROP 3+ DERR ?DUP                                            IF CR DISCARD ." I/O ERROR " . 0 TO DERR ABORT THEN ;          ' BLOCK  ' NBLK 10 + !                                                                                                      : LIST DUP TO SCR  BLOCK .BLOCK ;                               | : ?LD BLK 0= A" LOADING?" ;                                   : --> ?LD 0 TO >IN BLK 1+ TO BLK ; IMMEDIATE                                                                                    : COPY  SWAP BLOCK SWAP BLOCK 1K CMOVE UPDATE FLUSH ;           : THRU  1+ SWAP  DO I LOAD LOOP ;                               : +THRU BLK DUP D+ THRU ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0  VALUE FENCE                                                  : forget   DUP FENCE U< A" fence !" >R  ( éÉêÄçàóàíÖã - R@ )       BEGIN  VOCLINK                                                   ( ëöÑöêÜÄ ÄÑêÖëÄ çÄ ÄÑêÖëÄ çÄ çÄâ-èéëãÖÑçàü ëèàëöä)              @ ?DUP R@ U<     ( íéâ èé-åÄãöä ãà Ö éí áÄÑÄÑÖçàü ?)          -WHILE @ VOCLINK !                                                      ( ÑéäÄíé çÖ Ö - èêÖåÄïçà Éé à èêÖåàçà äöå èêÖÑàòÖç)     REPEAT  VOCLINK                                                          ( ëãÖÑ äÄíé ëÄ èêÖåÄïçÄíà Çëàóäà èé-Ééêçà ëèàëöñà)  BEGIN DUP 2-  ( ÑÄ ëÖ çÄèêÄÇà ëöôéíé à ë ÑìåàíÖ éí éëíÄçÄãàíÖ)    BEGIN @ DUP                                                       ( - çÄåàêÄ ëÖ ÄÑêÖëÄ çÄ çÄâ-ÉéêçÄíÄíÄ ÑìåÄ éí ëèàëöäÄ)             R@ U<          ( - íéâ èé-åÄãöä ãà Ö éí áÄÑÄÑÖçàü ?)                                                                                                                                                                                                                                                                          -WHILE N>C 2-    ( - ÑéäÄíé çÖ Ö - èêÖåàçà äöå èêÖÑàòÖç)        REPEAT           ( - Ääé Ö çÄåÖêÖç -v  çÄÑéãì)                  OVER 2- !        ( êÖÉàëíêàêÄçÖ çÄ ÄÑêÖëÄ )                     @ ?DUP           ( íéÇÄ èéëãÖÑçàü ëèàëöä ãà Ö ?)             -UNTIL  FORTH       ( FORTH -> CONTEXT)                          TO FORTH  R>       ( FORTH -> CURRENT)                          TO HERE            ( R>    -> HERE   )                          DROP ;             ( VOCLINK @ )                             : FORGET ' C>N DROP forget ;                                    HERE TO FENCE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   : WORDS  CR 10 TO CSP CONTEXT  -1 0 DO @ ?DUP                       IF DUP  C@ 31 AND 6 + OUTC + 80 <                                  -IF CR CSP ?DUP                                                    IF 1- TO CSP                                                    ELSE  10 TO CSP KEY B>W 27 =                                       IF DROP I " LISTED"  LEAVE THEN  THEN                     THEN                                                            DUP .H DUP ID.   1H OUTC OVER MOD ?DUP                              -IF DUP THEN -                                                  DUP 13 < -IF DROP 1 THEN                                        OUTC 64 < -IF 1- THEN SPACES  N>C 2-                     ELSE CR I " TOTAL" LEAVE THEN                                 LOOP ". ."  WORDS = " . ;                                                                                                    \ FWRITE  PROCEDURE TO WRITE BLOCKS TO FILE                     \ FIRST   READ & MODIFY TEXT TO BE READ AS A SEQENTAL FILE      : C!ADR   PUSH COUNT R@ C! POP 1+ ;                             : !LINE   1L FOR C!ADR NEXT PUSH cr R@ C! POP 1+ ;              : !BLOCK  SWAP PUSH BLOCK POP 1H FOR !LINE NEXT NIP ;           : !BLOCKS 1+ SWAP DO I !BLOCK LOOP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             F83                                                                                                                                                                                             \ : WORD. DUP H. ID. ;                                          \ : VOC. 2- C>N DROP CR ." VOCABULARY : " WORD. ;               \ : VOCS. VOCLINK BEGIN ?DUP WHILE DUP 2-  VOC. @ REPEAT ;      \ : WORDS.  DUP VOC. BEGIN @ ?DUP WHILE DUP WORD. N>LINK REPEAT \ : HERE<.  DUP VOC. BEGIN @ ?DUP WHILE DUP                     \     HERE U<  IF DUP WORD. THEN N>LINK REPEAT ;                \ : HERE>.  DUP VOC. BEGIN @ ?DUP WHILE DUP                     \    HERE U< -IF DUP WORD. THEN N>LINK REPEAT ;                 \ : ALL-W. VOCLINK BEGIN ?DUP WHILE DUP V>LINK WORDS. @ REPEAT                                                                                                                                                                                                                                                                  : PRUNE VOCLINK                                                  BEGIN    DUP  >R       \  ÑéäÄíé àåÄ éôÖ ëèàëöñà                      V>LINK           \  èéáàñàéçàêÄçÖ Çöêïì ëèàëöä              BEGIN @ DUP          \  ÑéäÄíé Ç ëèàëöäÄ àåÄ éôÖ Ñìåà            HERE U<             \   Ääé ÄÑêÖëÄ Ö >= HERE                  -WHILE N>LINK REPEAT  \  èêàÉéíÇà áÄ àáíêàÇÄçÖ                   DUP R@ V>LINK !      \   áÄèéåçà ÇöÇ ÇöáÇêÄíçàü ëíÖä ãàçä çÄ                         \  ÑìåÄ < HERE                                                  \  àáíêàâ äÄíé èéãáìÇÄò äéêÖçÄ çÄ ëíÖäÄ                                                                       ?DUP IF DUP >R    \  Ääé ëèàëöäÄ Ö èêÄáÖç - ëãÖÑÇÄô            BEGIN N>LINK       \    ëãÖÑÇÄôÄ ÑìåÄ                            @ ?DUP            \     àåÄ ãà                                 WHILE DUP HERE U<  \    ÑéäÄíé ÑìåàíÖ ëÄ ë ÄÑêÖë < HERE                                                                           IF DUP R>        \      ëÖ çÄÇêöáÇÄí Ç ëèàëöä                       N>LINK       \       éëíÄçÄãàíÖ ëÖ èêéèìëäÄí                  ! DUP >R       \                                              THEN             \                                            REPEAT             \                                            0 R> N>LINK !      \    êÖÉàëíêàêÄ ëÖ äêÄü çÄ ëèàëöäÄ         THEN                 \                                        R> @ ?DUP -UNTIL       \  ëãÖÑÇÄô ëèàëöä                       ;                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ CO PROCEDURES LIBRARY                                                                                                          0 VALUE FRAME  M: 7 FRM @ ;M   TO FRAME \  PSEUDO QUAN         M: AT FRAME ! ;M   M: AT FRAME @ ;M  ' FRAME 2!                 0 VALUE CO-PTR    \ LAST CO-PROCEDURE CO-VAR ADRS               0 NM:  FRAME PUSH RP   CO-PTR !  DUP  TO CO-PTR @  TO RP            POP  TO FRAME ;M   1 NM: ;M  2 MAKER CO-VAR ,               5 CO-VAR MAIN    \ OPERATOR`S CO-VAR                            : ;LOOP R@ RP 2-! PUSH ;                                        : CO-INI ( CO-PARAMS... CO-ADR CO-VAR )  ( RET-ADR FRAME)        FRAME PUSH  RP MAIN ! 0 TO FRAME  DUP TO CO-PTR @ TO RP EXEC ;                                                                 20 CLARY  HERE CO-VAR 1-CO                                      FUNC: 1+. ( / _NUM ) ;LOOP TO MAIN  AT _NUM @1+! EXIT ;          ( NO CO-PARAMS)  ' 1+. 1-CO  CO-INI                            FUNC: TIMES ( _TODO _TIMES ) _TIMES FOR _TODO EXEC NEXT ;       FUNC: ?PRIME ( _N / _D _SP ) SP TO _SP SKIP [  -HEADERS          ': U<EXIT U< IF _SP TO SP -1 RETURN THEN ;M                     ': 0=EXIT -IF 0 RETURN THEN ;M                                  ': CHECK+  AT _D +!   _N _D U/MOD _D U<EXIT  0=EXIT ;M         ] THEN  _N 4 U<EXIT _N 1 AND 0=EXIT  3 CHECK+  ( 3)  2               BEGIN  CHECK+ ( 5)  2 CHECK+ ( 7)  4 AGAIN                   [ PRUNE  HEADERS ]   ;                                        : .PRIMES 1+ SWAP DO I ?PRIME IF I . THEN LOOP ;                : +PRIMES 1+ SWAP 0 -ROT DO I ?PRIME - LOOP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   FUNC: ?PRIME ( _N / _D )                                          _N 4 U< IF -1 RETURN THEN                                       _N 1 AND 0= IF 0 RETURN THEN                                    _N 3 DO                                                           _N I /MOD I U< IF DROP -1 RETURN THEN                              0= IF 0 RETURN THEN                                             2 +LOOP                                                  ;                                                               FUNC: ?PRIME ( _N / _D )                                          _N 4 U< IF -1 RETURN THEN                                       _N 1 AND 0= IF 0 RETURN THEN                                    _N 3 DO                                                           _N I /MOD I U< 0= IF DROP -1 RETURN THEN                           0= IF 0 RETURN THEN                                             2 +LOOP                                                  ;                                                                 AT MACROS 2+  VOCLINK SWAP!   \ INITIALIZATION                : ?V  NEGATE 2* 7 FRM @ @ + ;  -HEAD  |  : WORD. DUP .H ID. ;   | : ?CODER CREATE C, DOES> C@ PUSH DUP N>C POP + @ 2 ?V @ = ;   0  ?CODER ?CFA0    2  ?CODER  ?CFA1   4  ?CODER  ?CFA2          | : FOUND DUP COUNT #LEN AND  HERE COUNT TO -TEXT 1+ NIP NIP ;  | : ?OUT OUTC 1H ALIGN DUP 80 = IF CR DROP ;THEN OUTC - SPACES ; | : VOC. 4 - DUP @ 728 - IF 2- THEN C>N DROP WORD. ." VOC: " ; : VOCS. AT MACROS 2+ BEGIN ?DUP WHILE DUP VOC. @ REPEAT ;       | FUNC: ALL-WORDS. ( ?CMP ?COD / _C1 _C2 _V _L )  AT MACROS 2+   CR BEGIN ?DUP WHILE DUP 2- BEGIN @ ?DUP WHILE ?CMP EXEC          IF DUP WORD.  ?OUT  AT _C2 1+! THEN  N>C 2-  REPEAT DROP       _C2 IF AT _C2 0 TO >< AT _C1 +! DUP CR VOC. CR THEN @ REPEAT                 _C1 CR ." TOTAL: " . ; : ALL. ' SWAP ALL-WORDS. ; : WHERE BLWORD DROP ['] FOUND 0 ALL-WORDS. ;   PRUNE                                                                                                                                              AT MACROS 2+  VOCLINK SWAP!  -HEAD   \ INITIALIZATION         : ?OUT RP @2+! OUTC ROT ALIGN DUP 80 = IF DROP PERFORM ;THEN     OUTC - SPACES DROP ;      -HEADERS        : WORD. DUP .H ID. ; : VL>N 4 - DUP @ 728 - IF 2- THEN C>N DROP ;                    : VOC. C" : EMIT VL>N WORD. ;     : TOPV AT MACROS 2+ ;         FUNC: ALL-WORDS. ( ?CMP ?COD / _C1 _C2 _V _L _LN ) TOPV  CR     bs TO _LN SKIP [ SMUDGE  ': +C1  AT _C2 0 TO >< AT _C1 +! ;M    CREATE ?FOUND                                                   DO: _L COUNT #LEN AND  HERE COUNT TO -TEXT 1+ NIP NIP ;M        LBL: TOT SKIP [ ': ?CR OUTC  IF CR AT _LN 1-!@  -IF bs TO _LN           KEY B>W 27 =   IF TOT THEN  THEN  THEN ;M                  ] THEN +C1 _C1 ?CR ." LISTED: " . RETURN [  ( END TOT )      ': ?CODER CREATE C, DOES> C@ PUSH _L N>C POP + @ ?COD = ;M      | CREATE ?CONTEXT  DO: CONTEXT 2+ _V = ;M        -->                                                                                                                                                                                                             ] THEN                                                           BEGIN DUP TO _V   BEGIN 2- @ DUP TO _L   WHILE ?CMP EXEC            IF AT _C2 1+! _L WORD. 1H ?OUT ?CR THEN  _L N>C   REPEAT     _C2 IF ?CR  _C2 .   +C1  _V VOC. ?CR THEN _V @ ?DUP  -UNTIL  TOT ;  -2 ALLOT   SMUDGE     : ALL. ' SWAP ALL-WORDS. ;         : WHERE BLWORD DROP ?FOUND 0 ALL-WORDS. ;                       0  ?CODER ?CFA0    2  ?CODER  ?CFA1   4  ?CODER  ?CFA2          : VOCS. TOPV CR BEGIN DUP VOC. 1H ?OUT CR @ ?DUP -UNTIL ;       : WORDS  ?CONTEXT 0 ALL-WORDS. ;        PRUNE                                                                                                                                                                                                                                                                                                                                                                                                                    VARIABLE FRAME  DO: 7 FRM @ ;M                                 0 NM: EXEC ! ;M  1 NM: EXEC @ ;M    2DUP  ' FRAME 2!             0 CONSTANT #V  USE: NEGATE 2* 7 FRM @ @ + ;M  DROP ' #V 2!     0 VALUE CO-PTR    : ;LOOP R@ RP 2-! PUSH ;                      0 NM:  FRAME PUSH RP   CO-PTR !  DUP  TO CO-PTR @  TO RP            POP  TO FRAME ;M   1 NM: ;M  2 MAKER CO-VAR ,               5 CO-VAR MAIN    \ OPERATOR`S CO-VAR                            : CO-INI ( CO-PARAMS... CO-ADR CO-VAR )  ( RET-ADR FRAME)        FRAME PUSH  RP MAIN ! 0 TO FRAME  DUP TO CO-PTR @ TO RP EXEC ; LBL: RETURN FRAME TO RP   POP TO FRAME ;M                       : LOCALS POP FRAME PUSH RP TO FRAME OVER #V TO RP PUSH              FOR R@ 1+ TO #V NEXT  CO  RETURN ;                          20 CLARY  HERE CO-VAR 1-CO                                      : 1+. 1 LOCALS ;LOOP TO MAIN  1 AT #V @1+! ;                     ( NO CO-PARAMS)  ' 1+. 1-CO  CO-INI                            FUNC: TIMES ( _TODO _TIMES ) _TIMES FOR _TODO EXEC NEXT ;                                                                       0 VALUE FRAME   HERE 2- TO XK                                   CODE PARSET                                                       CX CX XOR,  BH CL XCHG,    CX DI MOV,  1 X/D DI LEA,            DI DI ADD,  DI BP SUB,     BP DI MOV,                           SS AX MOV,  AX ES MOV,     AX DS MOV,                           AX AX XOR,  REP,           AX STOS,    SP AX MOV,                                                      AX SI XCHG,              BX CX MOV,  REP,           AX MOVS,    SI SP MOV,                                                      AX SI XCHG,              DI AX MOV,  XK /// AX XCHG,            AX STOS,                 CS AX MOV,  AX ES MOV,     AX DS MOV,  BX POP, NEXT,          END-CODE                                                        : LOCALS                                                                                                                                                                                                                                                        0 VALUE FRAME   HERE 2- TO XK                                   CODE PARSET   STD,  BP AX MOV,  XK /// AX XCHG,  0 /BP AX XCHG,   SP CX MOV,  AX PUSH,    SI PUSH,    -2 /BP DI LEA, CX SI MOV,   AX STOS,    AX AX XOR,  BL AL MOV,     AX CX MOV,               AX DEC,     AX AX ADD,     SP AX ADD,  AX PUSH,    SI PUSH,     AX SI MOV,  REP,           AX MOVS,    SI POP,     SP POP,      BH CL MOV,  AX AX XOR,     REP,        AX STOS,                 CLD,        2 /DI BP LEA,  BX POP,  NEXT,                     END-CODE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0 VALUE FRAME   HERE 2- TO XK                                  CODE PARSET   CX CX XOR,  BH CL XCHG,                             CX DI MOV,  BX DI ADD,  DI DI ADD,     DI BP SUB,               BP DI MOV,  AX AX XOR,  REP, AX STOS,  SP AX MOV,               AX SI XCHG, BX CX MOV,  REP, AX MOVS,  SI SP MOV, AX SI XCHG,   0 /DI BX MOV, DI AX MOV,  XK /// AX XCHG,  AX STOS,  NEXT,    END-CODE                                                        \           EXIT                                                CODE #V BX NEG,  BX BX ADD,  XK /// BX ADD, NEXT, END-CODE      :: RETURN FRAME TO RP  POP TO FRAME ;                           :: LOCALS  PARSET PUSH CO TO RETURN ; AT ALLOT                  0 NM: STR SWAP PUSH TO LOCALS [                                 HEADER FUN , 1 , ] 1 #V @ . ;M                                                                                                                                                                                                                                   253 LOAD                                                       :: RETURN FRAME TO RP  POP TO FRAME ;                           :: LOCALS  UNPACK POP  FRAME PUSH RP TO FRAME  \ FIX FRAME        ROT 2+ NPUSH POP POP  ZPUSH  PUSH CO  TO RETURN ; AT ALLOT    0 NM: STR SWAP PUSH TO LOCALS [  TO XK                          : FUNC: PACK PUSH : AT ALLOT COMPILE [ XK , ] POP , ;           1 0 FUNC: FUN 1 #V @ . ;                                        : R-ALLOT POP SWAP ZPUSH PUSH ;                                 : ROT  2 NPUSH PUSH  3 NPOP ;                                   : -ROT 3 NPUSH POP   2 NPOP ;                                   : 2SWAP  4 NPUSH 2 NPOP 2 NPOP ;                                                                                                                                                                                                                                                                                                 0 VALUE FRAME   HERE TO XK                \ OK                 ASM          BP DI MOV,  BX CX MOV,  BX BX ADD,  BX DI SUB,         BX POP,  BX CALL,    BX POP,  NEXT,  END-CODE               CODE #V           BX NEG,    BX BX ADD,                                 XK 2- /// BX ADD,         NEXT,               END-CODE  CODE NPOP    SP DI MOV, XK 2+ #, CALL,  BX POP,  DI SP MOV,                  BP AX MOV,   AX SI XCHG,    REP, AX MOVS,                       AX SI XCHG,  AX BP XCHG,          BX JMP, END-CODE CODE NPUSH    XK #, CALL, BX POP,  DI BP MOV,  SP AX MOV,                     AX SI XCHG,          REP,       AX MOVS,                        AX SI XCHG,   AX SP XCHG,        BX JMP, END-CODE CODE ZPUSH   XK #, CALL,   DI BP MOV,                                         AX AX XOR, REP, AX STOS,  RET, END-CODE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Jumps       Memory      Arithmetic  Register                    00  ;       08  @p      10  +*      18   dup                    01  ;:      09  @+      11  2*      19   pop                    02  jump    0a  @b      12  2/      1a   over                   03  call    0b  @       13  -       1b   a                                                                                      04  unext   0c  !p      14  +       1c   .                      05  next    0d  !+      15  and     1d   push                   06  if      0e  !b      16  or      1e   b!                     07  -if     0f  !       17  drop    1f   a!                                                                                     Registers are:            S - second number on data stack       R - top of return stack       A - address/scratch               B - address                   P - program counter               I - instruction word          T - top of data stack                                                                             Jump Instructions  Jump to address in register P, I or R                                                                        00 ;     ;Jump thru R (destructive)                             Return from subroutine      -:  ;                               Computed jump - address in T-:  push ;                                                                                          01 ;:     ;Jump thru R, save P in R                                                                                             02 jump    ;Jump thru I                                         The opcode is not used explicitly. The compiler generates it                                                                    03 call     ;Jump thru I, push current address to R             Referencing any defined word generates a call                   Subroutine call -:   word . . . ;                                                                                                                                                               04 next       ;This instruction has 2 forms:                    If the low-order bit is 0 it's called unext:                    If R is non-zero, jump to slot 0 and decrement R.               Otherwise pop R and execute the next slot.                      Discards the address left by for.                               Begin fills the current instruction word with .                 loop begins in the next word.                                   Leaves address on compiler stack for next to use                Search for match:                                               for @+ over or if drop swap next no match then match            Swap is executd at compile time to access the address for nexT  /mod for begin over over . + -if drop 2* swap next ;            then over or or - 2* - next ;                                   Divide operation: trial subtract and shift in either 0 or 1                                                                                                                                     06 if   ;Jump thru I if T is zero                               If leaves its address on compiler stack for then to complete.   Then may abort if address won't fit in slot                                                                                     07 -if  ;Jump thru I if T is positive                           Absolute value: -:  abs -if - 1 . + then ;                      Maximum:        -:  max - over . + - -if drop ; then + ;        Minimum:        -:  min - over . + - -if + ; then drop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Memory Instructions   Fetch or store thru registers A, B, P.    @ and ! are Forth abbreviations for 'fetch' and 'store'.        Fetch pushes the data stack; store pops it                                                                                      08 @p   ;Fetch thru P, increment P                              Increment suppressed when executing from port                   Fetch a number: -:  123         ;Uses 1 slot plus 1 word                                                                        09 @+   ;Fetch thru A, increment A                              Increment suppressed when referencing port                      Check-sum memory:       -:  0 63 for @+ . + unext                                                                               0a @b   ;Fetch thru B   ;Read status:   -: io b! @b                                                                             0b @    ;Fetch thru A   ;Read status:  -:  io a! @                                                                              0c !p   ;Store thru P, increment P                              Send status to port from which you're executing instructions:   @b !p ;Make a constant (x) into a variable: -: x! @p drop !p ;  x 100 ;         ;Avoids using an address register                                                                               0d !+   ;Store thru A, increment A                              Fill memory from port:  -:  63 for @b !+ unext                  Fill memory executing from port:  -: 63 for @p !+ unext                                                                         0e !b   ;Store thru B   ;Be careful to distinguish !b from b!   Set 2 I/O pins  -:  30003 !b  ;Reset 3 I/O pins  -:  2000a !b                                                                   0f !    ;Store thru A   ;Set first I/O pin     -:  30000 !                                                                                                                                                                                                      ALU Instructions                                                Unary and binary operations:                                                                                                    10 +*   ;Multiply step:                                         add S to T if A0=1 then shift T and A right                     4-bit multiply:       -:  . +* . +* . +* . +*                   n-bit multiply:       -:  push . begin +* unext                 * a! 17 push . begin +* unext drop a ;  ;18-bit result                                                                          11 2*   ;Shift T left   ;Multiply by 5:  -:  dup 2* 2* . +      Multiply by 6:  -:  2* dup 2* . +                               Multiply by 7:  -:  dup 2* dup 2* . + . +                                                                                       12 2/   ;Shift T right; sign fill                                                                                                                                                               13 -    ;One's complement T     ;Test for positive:  -:  - -if  Negate:             -:  - 1 . + ;Subtract T from S:  -:  - . +  Subtract S from T:  -:  - . + -                                 Subtract T from S:  -:  push - pop . + -                        Construct -1:       -:  dup or -    -:  dup dup - . +           Construct -2:       -:  dup or - 2*                             Construct +1:       -:  dup or - 2* -                                                                                           14 +    ;Add S to T (discard S) ;Add:  -:        . +            Clear and save carry: -:   dup or . +                           Return -1 if carry zero; 0 if carry set. -:  dup dup - . +      Set carry:   -: dup or - dup . +                                                                                                15 and          Bit-wise and of S and T                         Return zero if T was a power of 2:      -:  dup -1 . + and                                                                      16 or           ;Bit-wise exclusive-or of S and T               Inclusive-or:   -:  over - and or                               nip:            -:  over or or                                                                                                  17 drop         ;Discard T      ;Discard R:  -:  pop drop       nip (discard S):   -:  push drop pop                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Stack Instructions                                                                                                              18 dup  ;Create a working copy of T   A 0 -:  dup or            Preserve the stack while using it destructively: -: dup dup or  Square a number:        -:      dup *                           Cube a number:          -:      dup dup * *                                                                                     19 pop  ;Fetch R (destructive)  ;Retrieve something saved       Retrieve a loop index:  -:  pop dup push                        Discard loop index and exit loop:   -:  pop drop ;                                                                              1a over ;Fetch S (non-destructive)                              Working copy of two numbers:    -:  over over                                                                                   1b a    ;Fetch A (non-destructive)  ;Retrieve something saved   Read address for decrementing:  -:  a over . +                  1c .    ;Do nothing     ;Fill unused slots                      Delay:  -:  !b . !b                                                                                                             1d push         ;Push T into R   ;Set loop count                Expose deeper stack:    -:  push over                           nip:    -:  push drop pop                                       Decrement non-zero number:  -:  push here 1 + next pop          clip:   -:      push max pop min                                                                                                1e b!           ;Store into B                                   Be careful to distinguish b! and !b                             Set @b !b address                                                                                                               1f a!                                                           Store into A        ;Set @ ! address     ;Save top of stack     Clean swap:     -:  push a! pop a                                                                                              LIST OF CHANGES              REGISTER ASIGNEMENTS                TPR  CX - STACK TOP          DSP  SP - STACK POINTER            AR   BX - ADDRESS REGISTER   RSP  BP - RSTACK POINTER           WR   DI - WORK REGISTER      IPR  SI - INSTRUNCTION POINTER     DXR  DX - SCRACH REGISTER    AXR  AX - SCRACH REGISTER                                                                          MAC: SKIP2  186 , ;             MAC: SKIP1  178 , ;                                                                             locals  @@                                                      ;pd  equ dword ptr   ;pw  equ word  ptr   ;pb  equ byte  ptr                                                                                                                                    PushReg  MACRO  ;jmp  _PushAx   ;ENDM                           SWAPREG MACRO   ;JMP _SWAPAX    ;ENDM                           DROPREG MACRO   ;JMP XDROP      ;ENDM                                                                                           next  MACRO     ;jmp  _next     ;ENDM                           SKIP2A  MACRO   ;DB 0B8H        ;ENDM                           SKIP2   MACRO   ;DB 0BFH        ;ENDM                           SKIP1   MACRO   ;DB 03CH        ;ENDM                                                                                           MyCseg  segment para  use16                                             assume cs: MyCseg,  ds: MyCseg, ss: MyCseg                                                                                                                                                      org 100h                                                Start   Label byte                                              TH:        PUSH  SI              ;   F>C;                              MOV   SI,[BP]                                                       INC   BP                                                        INC   BP                                                                                                                        RET                                                  F:         JMP   SI              ;   F>C                        H:         DEC   BP              ;   :C>F                                  DEC   BP                                                        MOV   [BP],si                                        J4th:      POP   SI              ;   C>F                                NEXT                                                               jmp  _next                                           ; ---------------------------------------------------           XSTORM: DEC   BX                ; !-                                       MOV   [BX],CH                                        XSTORCM:DEC   BX                ; C!-                           XSTORC: MOV   [BX],CL           ; C!A                                      JMP   SHORT XDROP                                    XSTORP: XCHG CL,CH              ; !+                                                                                                       MOV  [BX],CH                                                    INC  BX                                              XSTORCP:MOV  [BX],CL            ; C!+                                      INC  BX                                                         JMP  SHORT      XDROP                                XADRSET:MOV   BX,CX             ; A!                                       jmp  short      xDROP                                :  MOV   DI,[BP]        ; C!R+                                             XCHG  AX,CX                                                     STOSB                                                           JMP   SHORT XRSP0                                    :  MOV   DI,[BP]        ; !R+                                              XCHG  AX,CX                                                     STOSW                                                   XRSP0:  MOV   [BP],DI                                                                                                                   jmp  short      xDROP                                XSTORE: MOV   DI,CX             ; !                                        POP   CX                                             _STORED:MOV   [DI],CX                                           xdrop:  pop  Cx                 ; DROP                                     JMP   SHORT _NEXT                                    XMBRAN: OR    CX,CX             ; -IF                                      jNS   XBRAN                                                  SKIP2                                                              DB 0BFH                                              XZBRAN: jCXZ  XBRAN             ; IF                                       LODSW                                                           JMP   SHORT _NEXT                                    :          mov   si,[si]        ; WORD;                                    JMP   SHORT _next                                                                                                       LEA   AX,[SI+2]      ; WORD                                             mov   si,[si]                                                   JMP   SHORT _RPUSH                                              XCHG  AX,CX          ; PUSH                                     POP   CX                                             H:         DEC   BP                     ; WORD                             DEC   BP                                                    MOV   [BP],AX                                                       JMP   SHORT _next                                       mov  si,[bp+0]       ; ;                                     xrdrop: inc  bp                 ; RDROP                                    inc  bp                                                         JMP  SHORT      _NEXT                                XFETCH: MOV   DI,CX             ; @                                        MOV   CX,[DI]                                                                                                                   JMP   SHORT _NEXT                                    R: MOV   AX,[BP]        ; POP                                           ADD   BP,2                                                         JMP   SHORT _PUSHAX                                  XATP:   MOV  AX,[BX]            ; @+                                    ADD  BX,2                                                          jmp  short      _pushax                                 MOV   DI,[BP]        ; @R                                               MOV   AX,[DI]                                                   jmp   short _PUSHAX                                  XATCP:  MOV  AL,[BX]            ; @C+                                      INC  BX                                                         jmp  short      _pushaL                              XADRGET:MOV   AX,BX             ; A  ADDRESS REGISTER A                    jmp  short      _pushax                                                                                              XOVER:  POP  AX                 ; OVER                                     PUSH AX                                                         JMP  SHORT      _PUSHAX                              XLIT:   LODSW                   ; NUM                                      JMP  SHORT      _PUSHAX                              XBlit:  lodsb                   ; BNUM                             _PUSHAL:xor  AH,ah                                           _PushAx:PUSH CX                                                 _SwapAx:xchg CX,ax                                              _next:  lodsw                   ; NOP                           ;       TEST AL,1                                               ;       JE   _EX                                                ;       DEC  AX                                                 ;       DEC  SI                                                 ;       MOV  AH,3                                                                                                               _ex:    xchg di,ax                                                         jmp  pw [di]                                         ; ---------------------------------------------------           xnip:   pop  Dx                 ; NIP                                      JMP  SHORT      _next                                   mov  Ax,[bp]         ; R@                                               JMP  SHORT      _PUSHAX                              X2SLS:  SAR  CX,1               ; 2/                                       JMP  SHORT      _next                                X2STAR: SHL  CX,1               ; 2*                                       JMP  SHORT      _next                                XDUP:   PUSH CX                 ; DUP                                      JMP  SHORT      _next                                XORE:   POP  AX                 ; OR                                       OR        CX,AX                                                                                                                 JMP  SHORT      _next                                XAND:   POP  AX                 ; AND                                      AND  CX,AX                                                      JMP  SHORT      _next                                XXORX:  POP  AX                 ; XOR                                      XOR  CX,AX                                                      JMP  SHORT      _next                                XNOT:   NOT  CX                 ; COM                                      JMP  SHORT      _next                                L: TEST  CL,1                                                              JZ        _NEXT                                                 POP   AX                                                        PUSH  AX                                                        JMP   SHORT _PLUS                                    XSTR:   MOV  DI,SP              ; /STRING                                                                                                  SCASW                                                       ADD  SS:[DI],CX                                          XMINUS: NEG  CX                 ; -                             XPLUS:  POP  AX                 ; +                             _PLUS:  ADD  CX,AX                                                         JMP  SHORT      _next                                XSWAP:  POP  AX                                                            JMP  SHORT      _PUSHAX                              XROT:   POP  DI aX      ; AX DI CX->                                       PUSH DI      ; DI CX AX                                         JMP  SHORT      _PUSHAX                              XMROT:  POP  aX DI      ; DI AX CX->                                       PUSH Cx DI           ; CX DI ax                              swapReg                                                            JMP _SWAPAX                                                                                                                                                                          _does2: scasw                                                   _does1: scasw                                                   _does:  DEC  BP                                                            DEC  BP                                                      MOV  [BP],SI                                            _DOES0: POP  SI                                                         SKIP2A                                                           DB 0B8H                                                dovar2: scasw                                                   dovar1: scasw                                                   DOVAR:  scasw                                                   DOVAR0: xchg AX,DI                                                      PUSHREG                                                            jmp  _PushAx                                                                                                         DOCON2: SCASW                                                   DOCON1: SCASW                                                   DOCON:  SCASW                                                   DOCON0: MOV  AX,[DI]                                                    PUSHREG                                                            jmp  _PushAx                                         setvar2:scasw                                                   setvar1:scasw                                                   setvar: scasw                                                   setvar0:MOV   [DI],CX                                                   DROPREG                                                        JMP XDROP                                                ;------------------------------                                                                                                 MyCseg  ends                                                   0 VALUE  ?ADR   : ?L:  <% DUP TO ?ADR CONSTANT %> ;             : L: HERE ?L: ; -HEAD   ASM  <% : SCASW, AX SCAS, ;             : JJ CREATE ?ADR , DOES> @ JMP, ; : JUMPER <% JJ %> ;           : SKIP2,    1234 #, AX MOV,  RECOVER ;                          : SKIP1,    12 #, AL CMP,  34 C, RECOVER ;                      : 3-SCASW, SCASW, SCASW, SCASW, ;  %>                           L: START/    3-SCASW,                                           L: <DOES   2 #,  BP  SUB,   JUMPER >DOES                                   SI 0 /BP MOV,   SI POP,   SKIP2, 3-SCASW,            L: <VAR     AX DI XCHG,      JUMPER >VAR                        L: <PUSH    CX PUSH,         JUMPER >PUSH                       L: <SWAP    AX CX XCHG,      JUMPER >SWAP                       L: <NEXT    AX LODS,         JUMPER >NEXT                       L: <EXEC    AX DI XCHG,      JUMPER >EXEC                                   0 /DI JMP,                                                        1 3 +THRU      END-CODE                           \ Arithmetic                                                    L: DROP#  CX POP,   >NEXT      JUMPER >DROP     ( 17  drop)     L: 2*# 1 #, CX SHL, >NEXT                       ( 11  2*)       L: 2/# 1 #, CX SAR, >NEXT                       ( 12  2/)       L: -#     CX COM,   >NEXT                       ( 13  - )       L: +#    AX POP,   AX CX ADD, >NEXT             ( 14  + )       L: AND#  AX POP,  AX CX AND, >NEXT              ( 15  AND)      L: OR#  AX POP,  AX CX XOR, >NEXT               ( 16  OR )      L: DUP#  CX PUSH,  >NEXT                             ( 18  dup) L: OVER# AX POP, AX PUSH,   >PUSH                    ( 1a over) L: B!#   CX BX MOV,  >DROP                           ( 1e   b!) L: A!#   CX DX MOV,  >DROP                           ( 1F   A!) L: CO#    SI 0 /BP  XCHG,              >NEXT     ( 1  ;:)       3-SCASW,    L: <FETCH   0 /DI AX MOV,  >PUSH  JUMPER >FETCH     3-SCASW,    L: <STORE   CX 0 /DI MOV,  >DROP  JUMPER >STORE                                                                     L: @R#   0 /BP DI MOV,   2 #, W/ 0 /BP ADD, >FETCH  ( 08  @R )  L: @+#  DX DI MOV, 2 #, DX ADD,         >FETCH      ( 09  @+ )  L: @B#    0 /BX AX MOV,       >PUSH                 ( 0a  @b )  L: @#        DX DI MOV,   >FETCH                    ( 0b  @  )  L: !R#  0 /BP DI MOV,  2 #, W/ 0 /BP ADD, >STORE    ( 0C  !R )  L: !+#     DX DI MOV, 2 #, DX ADD,     >STORE       ( 0D  !+ )  L: !B#     CX 0 /BX MOV,    >DROP                   ( 0e  !b )  L: !#      DX DI MOV,         >STORE                ( 0f  !  )  L: POP#  BP DI MOV, 2 #, BP ADD, >FETCH ( 19  pop)  ( 19  pop)  L: RET#     0 /BP SI MOV,             ( 0  ;)                   L: <RDROP   2 #,  BP ADD,  >NEXT                JUMPER >RDROP   L: SJUMP#  AL LODS,  CBW, SKIP1,                                L: JUMP#   AX LODS,  AX SI ADD, >NEXT ( 2 JUMP) JUMPER >JUMP                                                                                                                                                                                                    L: <CALL   AX SI XCHG,            JUMPER >CALL                  L: <RPUSH 2 #, BP SUB,  AX 0 /BP MOV,  >NEXT    JUMPER >RPUSH   L: PUSH#  AX POP,  AX CX XCHG, >RPUSH            ( 1d push)     L: CALLB  AL LODS,  CBW, SKIP1,                                 L: CALL#   AX LODS, SI AX ADD, >CALL             ( 3 CALL)      L: NEXT#  W/ 0 /BP DEC, JUMP# 0=, UNTIL, >RDROP  ( 4 NEXT)      L: IFB    SJUMP# CXNZ, UNTIL,                                   L: <BSKIP   AL LODS, >NEXT                   JUMPER >BSKIP      L: MIFB   SJUMP# CX CX OR, 0<, UNTIL,  >BSKIP                   L: IF#     JUMP# CXNZ, UNTIL,         ( 6 IF)                   L: <SKIP   AX LODS, >NEXT                     JUMPER >SKIP      L: MIF#    JUMP# CX CX OR, 0<, UNTIL,  >SKIP    ( 7 -IF)        L: +*# SP DI MOV,  1 #, DL TEST,  0=, NOT, IF,  ( 10  +*)              0 /DI CX ADD,  THEN, 1 #, CX RCR, 1 #, DX RCR, >NEXT                                                                                                                                     0 QUAN A        0 QUAN   I  \ INSTRUNTION REGISTER              0 QUAN B        0 QUAN   T  \ TOP OF STACK REGISTER                287 LOAD     0 QUAN  WR  \ WORK REGISTER                                                                                     : #DROP S> TO T ;   : #PUSH T >R# #DROP ;                       : #DUP T >S ;       : #POP #DUP R#> TO T ;                      : A! T TO A S>T ; : #! S> A ! ; : #@ #DUP A @ TO T ;            : B! T TO B S>T ; : !B S> B ! ; : @B #DUP B @ TO T ;            : #B T>S B TO T ; : #A T>S A TO T ;                             CODE +*  AX POP,                                                  1 #, AT A /// TEST,   0=,  NOT,  IF, AX BX ADD,  THEN,          1 #, BX RCR, 1 #, W/ AT A /// RCR,  AX PUSH,  NEXT, END-CODE  : #+* S> T +* TO T >S ;                                                                                                                                                                                                                                         \ LITTLE STACK  OBJECT   POS=0  DATA    PUSH  POP               CLASS: LSO    F: POS  ;F 2Z,       10 F: DATA ;F ALLOT                     -1 F: #>S TO C@ ;F C,    1 F: S># TO C@ ;F C, ;CLASS METHOD: LSO   : POS! POS @ + POS DATA - |<>| POS ! ;              : ADR@ POS @ 2* DATA + ;    : N>S  #>S POS! ADR@ ! ;            : S>N  ADR@ @  S># POS! ;   ;METHOD                                                                                           64 -1 1 LSO RSTK     \ RETURN STACK                             : R#> AT RSTK [SEND] LSO S>N ; : >R# AT RSTK [SEND] LSO N>S ;                                                                   64 -1 1 LSO DSTK     \ DATA STACK                               : S> AT DSTK [SEND] LSO S>N ; : >S AT DSTK [SEND] LSO N>S ;                                                                     128 1 1 LSO PSTK     \ PROGRAM                                  : P> AT PSTK [SEND] LSO S>N ; : >P AT PSTK [SEND] LSO N>S ;     : P! AT PSTK [SEND] LSO POS ! ; : P@ AT PSTK [SEND] LSO POS @ ;  00  ;       08  @p      10  +*      18   dup                    01  ;:      09  @+      11  2*      19   pop                    02  jump    0a  @b      12  2/      1a   over                   03  call    0b  @       13  -       1b   a                                                                                      04  unext   0c  !p      14  +       1c   .                      05  next    0d  !+      15  and     1d   push                   06  if      0e  !b      16  or      1e   b!                     07  -if     0f  !       17  drop    1f   a!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    0  QUAN A   0 VALUE B   0 VALUE IR  \ INSTRUNTION REGISTER      0 VALUE T   0 VALUE #SLOT  0 VALUE WR     : ,2* DUP , 2* ;      : CLIP 2DUP U< IF DROP ;THEN OVER 1+ IF 2DROP 0 ;THEN + ;       CLASS: LSO   NOOP F: POS  ;F 2Z,                                    NOOP F: DATA OVER + + ;F ALLOT                                     5 F: CLIP? @ CLIP  ;F ,2*   ;CLASS                       METHOD: LSO      : POS! CLIP? POS ! ;  : POS@ POS @ ;            : TOP@ POS@ DATA @ ;         : TOP! POS@ DATA ! ;               : !DATA CLIP? DATA ! ;       : @DATA CLIP? DATA @ ;             : POS++ POS@ 1+ POS! ;       : S!+  TOP! POS++ ;                : S@+  TOP@ POS++ ;   : S-!  POS@ 1- POS! TOP! ;  ;METHOD      CODE +*  AX POP,                                                  1 #, AT A /// TEST,   0=,  NOT,  IF, AX BX ADD,  THEN,          1 #, BX RCR, 1 #, W/ AT A /// RCR,  AX PUSH,  NEXT, END-CODE    1 3 +THRU                                                                                                                     32 LSO RSTK     \ RETURN STACK                                  32 LSO DSTK     \ DATA STACK                                    64 LSO PSTK     \ PROGRAM  MEMORY                                AT RSTK  ACTOR R#>  LSO S@+    AT RSTK  ACTOR >R# LSO S-!                                                                       AT DSTK ACTOR S> LSO S@+      AT DSTK ACTOR >S LSO S-!                                                                         AT PSTK ACTOR DAT! LSO !DATA   AT PSTK ACTOR DAT@ LSO @DATA     AT PSTK ACTOR PC!  LSO POS!    AT PSTK ACTOR PC@  LSO POS@      AT DSTK ACTOR @PC  LSO S@+     AT DSTK ACTOR !PC  LSO S!+                                                                       : 2OP1 CREATE , DOES> S> T ROT PERFORM TO T ;                   : 0OP1 CREATE , DOES> PERFORM T >S TO T ;                       : 1OP1 CREATE , DOES> T SWAP  PERFORM TO T ;                    : MEM@ CREATE , DOES> T >S PERFORM DAT@ TO T ;                  : MEM! CREATE , DOES> S> T ROT PERFORM DAT! TO T ;              : 'OVER OVER >S >S ;   : '+* +* SWAP >S ;   : A++ AT A @1+! ;   : SAVE-PC PC@ >R# ; : ?LOOP R#> 1- ?DUP ; : ;:CELL CO 0 TO WR ; ' A MEM@ #@     ' B MEM@ #@B    ' A++ MEM@ #@+                  ' A MEM! #!     ' B MEM! #!B    ' A++ MEM! #!+                  ' '+* 2OP1 #+*  ' 2* 1OP1 #2*   ' 2/ 1OP1 #2/   ' NOT 1OP1 #-   ' +  2OP1 #+   ' AND 2OP1 #AND ' XOR 2OP1 #OR ' DROP 2OP1 #DROP ' T 0OP1 #DUP   ' R#> 0OP1 #POP ' 'OVER 2OP1 #OVER  ' A 0OP1 #A ' @PC 0OP1 #@P                                                  ' >R# 2OP1 #PUSH ' A 2+ 2OP1 #A! ' B 2+ 2OP1 #B!    : #. ;      ' !PC 2OP1 #!P   : 'JUMP WR PC! ;                               : JUMP : DOES> ;:CELL PUSH ;    JUMP #; R#> PC! ;               JUMP #;: R#> SAVE-PC PC! ;      JUMP #JUMP 'JUMP ;              JUMP #CALL SAVE-PC 'JUMP ;      JUMP #NEXT ?LOOP 0; >R# 'JUMP ; JUMP #UNEXT ?LOOP 0; >R# IR TO WR RDROP -1 TO #SLOT ;  \ 04  uneJUMP #IF   T 0= IF 'JUMP THEN ; JUMP #-IF  T 0< IF 'JUMP THEN ;                                                                 : XTABLE CREATE DOES> #SLOT 1+ 3 AND TO #SLOT OVER + + PERFORM ; XTABLE ITABLE ]                                                 #;    #;:   #JUMP #CALL #UNEXT #NEXT  #IF  #-IF                 #@P   #@+   #@B   #@    #!P    #!+    #!B  #!                   #+*   #2*   #2/   #-    #+     #AND   #OR  #DROP                #DUP  #POP  #OVER #A    #.     #PUSH  #B!  #A!     [                                                                           : IEXEC TO WR BEGIN WR 32 UM* SWAP TO WR ITABLE WR 0= UNTIL ;   : #EXECUTE PC! BEGIN -1 TO #SLOT @PC DUP TO IR IEXEC AGAIN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ LITTLE STACK  OBJECT   POS=0  DATA    PUSH  POP               : ACTOR CREATE , METHOD: ' , ;METHOD DOES> 2@ SEND ;            : ,2* DUP , 2* ;   CLASS: LSO     NOOP F: POS  ;F 2Z,               NOOP F: DATA OVER + + ;F ALLOT                                     5 F: CLIP? @ LOCALS( NEWPOS SIZE )                         NEWPOS SIZE U< IF NEWPOS RETURN THEN                            NEWPOS 1+ IF 0 RETURN THEN SIZE 1- RETURN ;                                         ;F ,2*   -1 F: #>S TO C@ ;F C,                   1 F: S># TO C@ ;F C,       ;CLASS                        METHOD: LSO                                                      : POS? DUP SIZE U< IF ;THEN DUP 1+ IF DROP 0 ;THEN SIZE + ;     : POS! POS? POS ! ;             : POS+ POS @ + POS! ;           : DATA! POS? DATA ! ;           : DATA@ POS? DATA @ ;           : N>S  #>S POS+ POS @ DATA ! ;  : S>N  POS @ DATA @ S># POS+ ; ;METHOD                                                                                                                         : 0BITS 8 ALIGN AT 2/ CLARY ;    0 QUAN BADR  0 VALUE #MASK     : ?BADR TO BADR 8 U/MOD AT BADR +! 2^ TO #MASK ;                0 NM: ?BADR ;M  1 NM: ?BADR BADR C@ #MASK OR BADR C! ;M         2 NM: ?BADR BADR C@ #MASK AND ;M  2 MAKER %BITS 0BITS           : %CLEAR BADR C@ #MASK NOT AND BADR C! ;                        : ?BITS 0 ?DO I OVER EXEC IF I . THEN LOOP DROP ;               50 %BITS PROBA 0BITS                                                5 TO PROBA   7 TO PROBA    17 TO PROBA                      ' PROBA 50  ?BITS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0 VALUE  ?ADR   : ?L:  <% DUP TO ?ADR CONSTANT %> ;             : L: HERE ?L: ; -HEAD   ASM  <% : SCASW, AX SCAS, ;             : JJ CREATE ?ADR , DOES> @ JMP, ; : JUMPER <% JJ %> ;           : SKIP2,    1234 #, CX MOV,  RECOVER ;                          : SKIP1,    12 #, CL MOV,  34 C, RECOVER ;                      : 3-SCASW, SCASW, SCASW, SCASW, ;  %>                           HERE 256 ALIGN TO HERE                                          L: START/  -?, IF,                                              L: _COLD  DW,          L:  _WARM  DW,   L: _TASKP               L: _EMIT  DW,          L:  _KEY   DW,                           L: _?KEY  DW,          L: _PRESCAN  DW,                         L: _VSEG  DW,          L: _VATR   DB,    L: _CARRY  DB,                     THEN,     1 6 +THRU      END-CODE                   \ Arithmetic                                                    L: +*# 1 #, DL TEST, 0=, NOT, IF, SP DI MOV, 0 /DI BX ADD,          THEN, 1 #, BX RCR, 1 #, DX RCR, -?, IF,                     L: CO#    SI 0 /BP  XCHG,           -?, IF,     ( 1  ;:)        L: @#    0 /BX BX MOV,    -?, IF,               ( 0a  @b )      L: DROP#  BX POP,   -?, IF,    JUMPER >DROP     ( 17  drop)     L: 2*# 1 #, BX SHL, -?, IF,                     ( 11  2*)       L: 2/# 1 #, BX SAR, -?, IF,                     ( 12  2/)       L: -#     BX COM,   -?, IF,                     ( 13  - )       L: +#    AX POP,   AX BX ADD,  -?, IF,          ( 14  + )       L: AND#  AX POP,  AX BX AND,   -?, IF,          ( 15  AND)      L: OR#  AX POP,  AX BX XOR,    -?, IF,          ( 16  OR )      L: DUP#  BX PUSH,              -?, IF,          ( 18  dup)                   3-SCASW,                                           L: <DOES   2 #,  BP  SUB,   JUMPER >DOES                                   SI 0 /BP MOV,   SI POP,   SKIP2, 3-SCASW,            L: <VAR     AX DI XCHG,      JUMPER >VAR                        L: <PUSH    BX PUSH,         JUMPER >PUSH                       L: <SWAP    AX PUSH,         JUMPER >SWAP                       L: <DROP    BX POP,          JUMPER >DROP  THEN,  THEN,         THEN,  THEN,  THEN,  THEN,  THEN,  THEN,  THEN,  THEN, THEN,    L: <NEXT    AX LODS,         JUMPER >NEXT                       L: <EX      AX DI XCHG,      JUMPER >EX    0 /DI JMP,           L: SP@#   BX PUSH,  SP BX MOV,   >NEXT  ( SP@)                  L: RP@#   BP AX MOV,     >PUSH          ( RP@)                  L: A@#    DX AX MOV,     >PUSH          (  A@)                  L: @IP#   AX  LODS,      >PUSH          ( @P )                  L: SP!#   BX SP MOV,  BX POP,    >NEXT          ( 1F   A!)      L: RP!#   BX BP MOV,  BX POP,    >NEXT          ( 1F   A!)      L: A!#    BX DX MOV,  BX POP,    >NEXT          ( 1F   A!)      L: C@T+# BX SI XCHG, 0 #, AH MOV, AL LODS,  -?, IF, ( COUNT)    L: @T+#  BX SI XCHG,  AX LODS,  THEN, BX SI XCHG, >PUSH  ( STR) L: POP#  BP DI MOV, 2 #, BP ADD,  -?, IF,            ( 19  pop) L: @R+#  0 /BP DI MOV,  2 #, W/ 0 /BP ADD,  -?, IF,  ( 08  @R)  L: @A+#  DX DI MOV, 2 #, DX ADD,        -?, IF,      ( 09  @+ ) L: @#    BX DX MOV,  BX POP,          ( 1e   b!)                L: @A#        DX DI MOV,     -?, IF,                 ( 0b  @  ) L: OVER#  SP DI MOV,  -?,  IF,                       ( 1a over) 3-SCASW,        THEN,  THEN,  THEN,  THEN,  THEN,               L: <FETCH   0 /DI AX MOV,  >PUSH                                L: !#       BX DX MOV,  BX POP,                      ( 1e   b!) L: !A#      DX DI MOV,                     -?, IF,   ( 0f  !  ) L: !R+#  0 /BP DI MOV,  2 #, W/ 0 /BP ADD, -?, IF,   ( 0C  !R ) L: !A+#     DX DI MOV, 2 #, DX ADD,        -?, IF,   ( 0D  !+ ) 3-SCASW,   THEN, THEN,  THEN,                                   L: <STORE   BX 0 /DI MOV,  BX POP,  >NEXT                       L: RET#     0 /BP SI MOV,   L: <RDROP   2 #,  BP ADD,  >NEXT    L: JUMP#   AX LODS,  L: <JUMP  AX SI ADD, >NEXT ( 2 JUMP)       L: CALL#   AX LODS, SI AX ADD,  AX SI XCHG, SKIP2, ( 3 CALL)    L: PUSH#  AX POP,  AX BX XCHG,  L: <RPUSH          ( 1d push)             2 #, BP SUB,  AX 0 /BP MOV,  >NEXT     3-SCASW,       L: <EXEC  AX SCAS, AX DI XCHG, AX SI XCHG, <RPUSH SJMP,         \ L: CICLE# SI AX MOV,   AX DEC,  <RPUSH SJMP,                  L: NEXT#   AX LODS, W/ 0 /BP DEC, <JUMP JNZ,         ( 4 NEXT)                                               <RDROP SJMP,       L: IF#    AX LODS, BX CX MOV,  <JUMP JCXZ, >NEXT    ( 6 IF)     L: -IF#   AX LODS, BX BX OR, 0<, <JUMP JM, >NEXT    ( 7 -IF)    \ IO                                                            L: C@P  AL IN, 0 #, AH MOV, >PUSH                               L:  @P  AX IN,              >PUSH                               L: C!P  BX AX MOV, AL OUT,  BX POP, >NEXT                       L:  !P  BX AX MOV, AX OUT,  BX POP, >NEXT                                                                                                                                                                                                                                                                                                                                                       MARKER -TARGET  ASSEMBLER ALSO  TO HIDDEN   32768 CONSTANT MSB  VARIABLE LX : CODE, HEADER , ; | : @LITERAL @ [',] LITERAL ;    10 WARY ADR:  10 WARY VAL: : ALIGNED HERE SWAP ALIGN TO HERE ;  :   GET:   0 DO ' 2+ DUP I ADR: ! @  I VAL: ! LOOP ;            : RESET:   0 DO I VAL: @  I ADR: @ ! LOOP ;  : @, @ , ;         :   SET:   0 DO ' EXEC  I ADR: @ ! LOOP ;                        10 GET: AGAIN SKIP UNTIL IF -UNTIL -IF ;M DO: [LIT] OF         : (( HEADER COMPILE [ ' DO: @, ] , , IMMEDIATE ;                | : CONST CONSTANT , DOES> DUP 1+! 2+ @LITERAL ;                | : <F> <% LX LINK+ CONST IMMEDIATE %> ;  | : <00F> 0 0 <F> ;   ' IOV @  1 NM: HERE 2+ SWAP! ;M  2 NM: @LITERAL ;M                HEADER JUSTIFY , , , 0 ,  IMMEDIATE   : RDROPS CO RDROP ;     | : DUPE? RDROPS RESCAN 0>=                                        IF 2DROP ;THEN STR ROT - IF DROP ;THEN  RDROP                   STR 0< A" DUP! " MSB OVER 2- XOR!  HERE   ;                  | : ?REL HERE SWAP  IF OVER 2+ - THEN ;           -->           | : A?REL DUP 1- C@ 1 OR $ E9 XOR 0= ?REL ;                     : FW <00F> TO JUSTIFY DOES> DUP 1+! STR 0< IF @, ;THEN LINK+ ;  : ?FW JUSTIFY DUPE?  N>C SWAP                                            BEGIN OVER TO >< ?DUP -UNTIL DROP ;                    : FL <00F> TO JUSTIFY  DOES> DUP 1+! STR 0< IF @LITERAL ;THEN    ?E ' CASE ['] JMP,  OF BCOMPILE [ $ E9 C, ] LINK+ ENDOF                   ['] CALL, OF BCOMPILE [ $ E8 C, ] LINK+ ENDOF                   [']   DW, OF LINK+ ENDOF  A" NO LBL OP!" ENDCASE ;   | : ?FL JUSTIFY DUPE? BEGIN TO >< ?DUP WHILE A?REL REPEAT               ( !!! BLWORD DROP )    BLWORD DROP RDROP ;              : CL: MSB <F> ;   : L: ?FL HERE CL: ;                           | : NODE. CR DUP ID. N>C STR H. STR H. @ H. ;                   | : ?NODE. DUP N>C 2+ @ 0< 0= IF NODE. ;THEN DROP ;             : VIEW LX @ SKIP BEGIN  STR SWAP NODE.  THEN ?DUP -UNTIL ;      : UNDEF. LX @ SKIP BEGIN  STR SWAP ?NODE. THEN ?DUP -UNTIL ;    PREVIOUS   F83                                                  \  FORWARD DEFINITIONS                                          FL ;#     FL JUMP#   FL OF#     FL <JSR    FL IF#  FL EXEC#     FL @IP#   FL NEXT#   FL -IF#                                       FL <VAR   FL <DOES     FL <MAIN   FL <EX   \ FW COMPILE         FL <PUSH  FL <DROP     FL <SWAP   FL <DBG  FW ;CODE          0 <% : DUP+ 2+ DUP ; %>                                         DUP+ CL: >TASK   DUP+ CL: <TASK   DUP+ CL: >SP                  DUP+ CL: >S0     DUP+ CL: >R0     DUP+ CL: >H                   DUP+ CL: >BASE   DUP+ CL: >OUT    DUP+ CL: >>IN                 DUP+ CL: >BLK    DUP+ CL: >TIB    DUP+ CL: >STATE                                                                               DUP+ CL: >HLD    DUP+ CL: >SCR    DUP+ CL: >CSP                 DUP+ CL: >SELF   DUP+ CL: >SPTR   DUP+ CL: >DBL                 DUP+ CL: >MPTR   DUP+ CL: >MTOP   DUP+ CL: >CONTEXT             DUP+ CL: >HDR    DUP+ CL: >VLINK  DUP+ CL: >CURRENT             DUP+ CL: >AREG   DUP+ CL: >BREG   DROP                            +*#  CODE, +*      +?#  CODE, +?       +#  CODE, +             AND#  CODE, AND    OR#   CODE, XOR    DUP#  CODE, DUP            2*#  CODE, 2*     2/#   CODE, 2/     INV#    CODE, INV             ;#  CODE, EXIT  <RDROP  CODE, RDROP    POP#  CODE, POP      RPUSH#  CODE, PUSH   CALL#  CODE, CALL     ;:#   CODE, ;:       SWAP# CODE, SWAP   FLIP# CODE, FLIP       <MAIN  CODE, NOP      SP@#   CODE, SP@     RP@#   CODE, RP@     A@#    CODE, A@       @IP#   CODE, @IP     OVER#  CODE, OVER    A#     CODE, A         @P#   CODE, @PORT    @R+#  CODE, @R+      C@P#  CODE, C@PORT   @A+#   CODE, @A       @#    CODE, @        @A#   CODE, @A       C@A#   CODE, C@A      C@T+# CODE, C@T+     @T+#  CODE, @T+      SP!#  CODE, SP!    RP!#  CODE, RP!         A!#   CODE, A!       !#    CODE, !      C!P#  CODE, C!PORT     !P#  CODE, !PORT      !A#   CODE, !A     !R+#  CODE, !R+        !A+#  CODE, !A+       C!A+# CODE, C!A+  <DROP  CODE, DROP    <PERFORM CODE, PERFORM   <DOS  CODE, DOS   <TRONX CODE, TRON      <TROFF CODE, TROFF    VOCABULARY KERNEL  KERNEL  ALSO  TO  KERNEL                     -HEAD  ASM    299  LOAD  256 ALIGNED                            L: START/   CLD, JMP,F 1                                        L: _BOOT 0 DW,  L: _COLD 0 DW,  L: _WARM 0 DW,  L: _USER 0 DW,  L: _OF    OF# DW,  L: _JUMP JUMP# DW,   L: _IF     IF# DW,      L: _-IF   -IF DW,  L: _JSR   <JSR DW,   L: _LIT   @IP# DW,      L: _EXIT   ;# DW,  L: _NEXT NEXT# DW,   L: _EXEC EXEC# DW,                                                                      L: _ARME 0 DW,                  L: _DERR 0 DW,                  L: _PRSC 0 DW,                                                  L: _EMIT 0 DW,     L: _KEY  0 DW,  L: _?KEY 0 DW,  \ IO         L: _VSEG 0 DW,     L: _VATR 0 DW,  L: _CRRY 0 DW,  \ VIDEO      L: FSTAT  <VAR DW, L: _AX   0 DW,  L: _SI   0 DW,  \ DEBUG      FL! 1        1 8 +THRU  HERE START/ - .     END-CODE                                                                                                                                                                                                                   CALL,F 1                   FL! 1                                     SI POP,          -2 /SI CX MOV,                        2 /SI DI MOV,          DI _USER /// MOV,                        REP, AL MOVS,                 AX AX XOR,                      $ 80 #, SI MOV,            -168 #, DI MOV,                             AL LODS,                 AX BX MOV,                        AH 0 X/S MOV,              1 /BX CX LEA,                       REP,  AL MOVS,          $ 1000 #, BX MOV,                      $ 4A #, AH MOV,                    33 INT,                                                                                     <% : CRY@ _CRRY /// AX MOV, SAHF, ;  : SCASW,2 SCASW, SCASW, ;     : DUP,  BX PUSH, ;       : SCASW,3 SCASW,2 SCASW, ;             : DROP, BX POP, ;                                               : CRY! LAHF, AH _CRRY 1+ /// MOV, ;  %>                                                                                      \ Arithmetic                                                    L: +*# 1 #, DL TEST, 0=, NOT, IF, AX POP,    AX BX ADD,          AX PUSH, THEN, 1 #, BX RCR, 1 #, DX RCR, -?, IF,               L: +?#  CRY@ AX POP,   AX BX ADC,   -?, IF, ( 14  + )           L: +#    AX POP,   AX BX ADD,                                                     THEN, THEN,  CRY!   -?, IF,   ( 14  + )       L: ;#     0 /BP SI MOV,                                         L: <RDROP   BP INC,   BP INC,         -?, IF,     ( 0  ; )      L: JUMP#   ( AX LODS,   AX SI ADD, !!!  )                                     0 /SI  SI MOV,          -?, IF,     ( 2 JUMP)                                                                                                                                                                                                                                                                                                                                                                                                     L: CALL#   LODSW, ( SI AX ADD,!!!)  AX SI XCHG,  SKIP2,         L: RPUSH#   AX POP,  AX BX XCHG,                  ( 1d push)    L: <RPUSH  BP DEC, BP DEC,  AX 0 /BP MOV,  -?, IF,              SCASW,3                                           ( 3 CALL)     L: <JSR  AX SCAS, AX DI XCHG, AX SI XCHG, <RPUSH JMP,           \ L: CICLE# SI AX MOV,   AX DEC,          <RPUSH JMP,           L: IF#    BX BX OR,  JUMP# JZ,   -?, IF,     ( 6 IF)            L: -IF#   BX BX OR,  JUMP# JM,   -?, IF,     ( 7 -IF)           L: OF# AX POP, AX BX XCHG, BX AX XOR, JUMP# JNZ,                                                                BX POP, -?, IF,  L: NEXT#  LODSW,  W/ 0 /BP DEC,  <RDROP JZ,  JUMP# JMP,        THEN, THEN, THEN, SI INC,  SI INC, -?, IF,                      L: ;:#    0 /BP SI XCHG,       -?, IF,          ( 1   ;: )      L: AND#  AX POP,  AX BX AND,   -?, IF,          ( 15  AND)      L: OR#  AX POP,  AX BX XOR,    -?, IF,          ( 16  OR )                                                                      L: DUP#  DUP,              -?, IF,          ( 18  dup)          L: 2*# 1 #, BX SHL, -?, IF,                     ( 11  2*)       L: 2/# 1 #, BX SAR, -?, IF,                     ( 12  2/)       L: INV#     BX COM, -?, IF,                     ( 13  - )       SCASW,3 L: <DOES   BP  DEC,  BP DEC,   SI 0 /BP MOV,            L: <DOES2   SI POP,   SKIP2, SCASW,3                            L: <VAR     AX DI XCHG,                                         L: <PUSH    DUP,                                                L: <SWAP    AX BX XCHG,    SKIP2,                               L: >FORTH   AX POP,                                             L: <JUMP    AX SI XCHG,                                         THEN,  THEN,  THEN,  THEN,  THEN,  THEN,                        THEN,  THEN,  THEN,  THEN,  THEN,  THEN,                        L: <MAIN  AX LODS,                                              L: <EX  AX DI XCHG,   0 /DI JMP,   <DBG  JMP,                                                                                   L: SP@#   DUP,  SP BX MOV,  <MAIN JMP,  ( SP@)                  L: RP@#   BP AX MOV,        <PUSH JMP,     ( RP@)               L: A@#    DX AX MOV,        <PUSH JMP,     (  A@)               L: @IP#   AX  LODS,         <PUSH JMP,     ( @P )               L: OVER#  AX POP, AX PUSH,  <PUSH JMP,  ( 1a oveR)              L: SP!#   BX SP MOV,                       ( 1F   A!)           L: <DROP    DROP,           <MAIN JMP,                          L: RP!#   BX BP MOV,        <DROP JMP,     ( 1F   A!)           L: A!#    BX DX MOV,        <DROP JMP,     ( 1F   A!)           L: SWAP#  AX POP, <PUSH JMP,                                    L: FLIP#  BL BH XCHG, <MAIN JMP,                                L: C@P#  AL IN, 0 #, AH MOV, <PUSH JMP,                         L:  @P#  AX IN,              <PUSH JMP,                         L: C!P#  BX AX MOV, AL OUT,  <DROP JMP,                                                                                                                                                         L:  !P#  BX AX MOV, AX OUT,  <DROP  JMP,                        L: POP#  BP DI MOV, 2 #, BP ADD,  -?, IF,            ( 19  pop) L: @R+#  0 /BP DI MOV,  2 #, W/ 0 /BP ADD,  -?, IF,  ( 08  @R)  L: @A+#  DX DI MOV, 2 #, DX ADD,        -?, IF,      ( 09  @+ ) L: @#    BX DX MOV,  DROP,          ( 1e   b!)                  L: @A#        DX DI MOV,     -?, IF,                 ( 0b  @  ) SCASW,3     THEN,  THEN,  THEN,  THEN,                          L: <FETCH   DUP, 0 /DI BX MOV,  <MAIN JMP,                      L: !#       BX DX MOV,  DROP,                        ( 1e  b! ) L: !A#      DX DI MOV,                     -?, IF,   ( 0f  !  ) L: !R+#  0 /BP DI MOV,  2 #, W/ 0 /BP ADD, -?, IF,   ( 0C  !R ) L: !A+#     DX DI MOV, 2 #, DX ADD,        -?, IF,   ( 0D  !+ )                                                                                                                                                                                                                                                                 SCASW,3    THEN, THEN,  THEN,                                   L: <STORE   BX 0 /DI MOV,  DROP, <MAIN JMP,                     L: <USER!   _USER DI MOV,  <STORE JMP,                          L: C!A+#    DX DI MOV,  BL 0 /DI MOV, DX INC, <DROP JMP,        L: C@A#    AX AX XOR, DX DI MOV,  0 /DI AL MOV, <PUSH JMP,      L: C@T+# BX SI XCHG, 0 #, AH MOV, AL LODS,  -?, IF, ( COUNT)    L: @T+#  BX SI XCHG,  AX LODS, THEN, BX SI XCHG, <PUSH JMP,     L: A#  BX PUSH,  DX BX MOV, <MAIN JMP,                          \ DOS INTERFACE                                                 L: <DOS  AX BX XCHG,  DROP,  CX POP,  DX POP,  ( A!)             $ 21 INT,  AX PUSH,     U<, NOT, IF,  AX AX XOR, THEN,               AX _DERR /// MOV,  <DROP JMP,                                     L: <USER   2 /DI DI MOV,  _USER /// DI ADD, <VAR JMP,   SCASW,3 L: <@USER  2 /DI DI MOV,  _USER /// DI ADD, <FETCH JMP, SCASW,  L: <!USER  2 /DI DI MOV,  _USER /// DI ADD, <STORE JMP,                                                                 L: <ALI  SKIP2,  SCASW,3                                        L: <@EXEC  0 /DI AX MOV,  AX AX OR,  0=, IF,    <MAIN JMP,      L: <PERFORM   BX DI MOV,  DROP,              <@EXEC JMP,        L: EXEC#     AX BX XCHG,  DROP,   THEN,         <EX JMP,        SCASW,3 L: <EXEC AX DI XCHG, <EX JMP,                                                                                           L: <TROFF LODSW, -?, FB, 63                                     L: <TRONX LODSW,                                                L: <DBG $ 2E #, <EX /// XOR,  FB! 63                                         _AX #,  DI  MOV,    AX 2 /DI XCHG,                               SI 4  /DI XCHG,       AX DI XCHG, 0 /DI JMP,                                                                                                                                                                                                                                                                                                                                      \ GENERATE HI LEVEL WORDS  IN  NEW KERNEL                       \ DECIMAL    89  LOAD                                            DECIMAL   301  LOAD  \ LOW LEVEL DEFINITIONS IN ASSEMBLER       DECIMAL   300  LOAD  \ HI LEVEL DEFINITIONS - PRIMITIVS         DECIMAL   1 4 +THRU  \ DEFINITION WORDS   ALIAS, CONSTANT ...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <%  : DOES> [',] ;CODE  <DOES  [AT] DOES> ; IMMEDIATE           : ALIAS    HEADER COMPILE [ <ALI ,   ] , ;                      : VECTOR   HEADER COMPILE [ <@EXEC 1- , ]                                  COMPILE [ <STORE 1- , ] , ;                          : VARIABLE HEADER COMPILE [ <VAR 1- , ] 2Z, ;                   : CONSTANT HEADER COMPILE [ <FETCH 1- , ] , ;                   : USER     HEADER COMPILE [ <USER  , ] , ;                      : VUSER    HEADER COMPILE [ <@USER  , ]                                           COMPILE [ <!USER  , ] , ;                     : QUSER    HEADER COMPILE [ <@USER 1- , ]                               COMPILE [ <!USER 1- , ] COMPILE [ <USER  , ] , ;        : VALUE    HEADER COMPILE [ <FETCH 2- , ]                                  COMPILE [ <STORE 1- , ] , ;                          : QUAN HEADER COMPILE [ <FETCH 3 - , ]                                COMPILE [ <STORE 2- , ]  COMPILE [ <VAR 1- , ] , ;                                                                                                                                                                                                        ' <MARK  ' PUSH ((  FOR        ' ,<MARK _NEXT ((  NEXT           : : ?FW : ;                                                                    %>       -MAC  \ WITHOUT MACROS                  10 SET: _JUMP _JUMP _IF _IF _-IF _-IF _EXIT _JSR _LIT _OF                                                                                                                                      \ : (( HEADER COMPILE [ ' DO: @, ] , , IMMEDIATE ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \  TEST FOR NEXT : ALIAS DOES> CONSTANT VARIABLE USER ;          0 CONSTANT 0  1 CONSTANT 1  -1 CONSTANT -1 2 CONSTANT 2        : MAX INV OVER + INV -IF DROP EXIT THEN + ;  : 1+  1 + ;        : MIN INV OVER + INV -IF + EXIT THEN DROP ;  : 1- -1 + ;        : C@A+ @A DUP C!A+ 255 AND ; : @A+ @A DUP !A+ ;                 : ABS -IF INV 1+ THEN ;             : NIP OVER XOR XOR ;        : PERFORM @ IF EXEC EXIT THEN DROP ; : OR OVER INV AND XOR ;    : EMIT _EMIT PERFORM DROP ;               : ?2^ DUP 1- AND ;    : ?EMIT OVER INV + -IF DROP EMIT EXIT THEN DROP ;               : TYPE SWAP A! FOR C@A+ EMIT NEXT ; : CLIP PUSH MAX POP MIN ;   : KEY  DUP   _KEY PERFORM ;  : ?KEY DUP  _?KEY PERFORM ;        : SEARCH FOR @A+ OVER XOR IF DROP NEXT # 0 EXIT THEN RDROP A ;  : * A! 15 FOR +* NEXT DROP A ;                                  : *M A! 15 FOR +* NEXT PUSH DROP A POP ;                        : /MOD  FOR BEGIN OVER OVER + -IF DROP 2* NEXT EXIT THEN                OVER XOR  XOR INV 2* INV NEXT ;                          0 VALUE HANDLE                                                  0 VALUE AXREG   0 VALUE DXREG                                  : D0 0 0 ;  \ IO KERNEL FUNCTIONS                               : DO_DOS A PUSH DOS TO AXREG  A TO DXREG  POP A! ;              : DO_HANDLE PUSH HANDLE POP DO_DOS ;                            : HFSIZE D0 $ 4202 DO_HANDLE ;  : HCLOSE D0 $ 3E00 DO_HANDLE ;  : HREAD $ 3F00 DO_HANDLE ;        : HWRITE $ 4000 DO_HANDLE ;   : BLKPOS 1K M* $ 4200 DO_HANDLE ; : FOPEN A D0 $ 3D02 DO_DOS ;  : RBLK BLKPOS 1K HREAD ;          : WBLK BLKPOS 1K HWRITE ;     : F_KEY 1 SP@ OVER HREAD ;        : F_EMIT SP@ 1 HWRITE NIP ;   : STD_KEY  0 D0 $ 100 DO_DOS ;   : STD_EMIT  D0 $ 200 DO_DOS ;  : STD_?KEY  D0 D0 DO_DOS ;                                                                                                                                                                                                                                                                                                      \ STREEM EVALUATION  - SEVAL                                  \\VARIABLE LINES    210 LOAD  \ EXPECT3                           FUNC: SEVAL ( _HANDLE _NBLK / _IN _BLK _TIB _HND _LINE )           >IN TO _IN   BLK TO _BLK  TIB TO _TIB                           RP 84 - DUP  TO RP  TO TIB    HANDLES TO _HND                   _HANDLE TO HANDLES   _NBLK TO BLK                              BEGIN   AT _LINE 1+!  0 TO >IN                                          BLK 0= IF CR ." ]" THEN                                         TIB 80 EXPECT3  TIB SPAN + TO 0 INTERPRET                       BLK 0= IF ."  ok!" THEN                                   _HND  HANDLES =                                               UNTIL   _BLK TO BLK  _TIB TO TIB _IN TO >IN  _LINE LINES +! ; : ;S ( TREEM)  AT HANDLES BLK 1+ 0= IF DUP CLOSE THEN DROP ;    : FLOAD HANDLES bs - 0= ?? FOPEN  FIO  -1 SEVAL ;                                                                                                                                               \ STREEM EVALUATION  - SEVAL                                  \\VARIABLE LINES | ( ' CO ALIAS ;:)  210 LOAD  \ EXPECT3          | : OK?  BLK IF CO CR ;THEN ."  ok!" CR ." >" CO SPACE ;        | : 1LINE OK?  0 TO >IN  TIB 80 EXPECT3 CO                              TIB SPAN + TO 0 TO INTERPRET ;                          | : ?IO DUP NOT IF SIO ;THEN FIO ;                              | : FOPEN HANDLES bs - 0= ?? FOPEN DUP 0< A" OPEN ERR" ;        FUNC: SEVAL ( _HANDLE _NBLK / _IN _BLK _TIB _HND _LINE )           >IN TO _IN   BLK TO _BLK  TIB TO _TIB                           RP 84 - DUP  TO RP  TO TIB    HANDLES TO _HND                   _HANDLE TO HANDLES   _NBLK TO BLK                              BEGIN   AT _LINE 1+!  1LINE  _HND  HANDLES =  UNTIL             _BLK ?IO TO BLK  _TIB TO TIB _IN TO >IN  _LINE LINES +! ;     : ;S HANDLES 0; AT HANDLES BLK 1+ 0= IF CLOSE THEN DROP ;       : FLOAD FOPEN  -1 ?IO SEVAL ;  : KBD  0 0 ?IO SEVAL ;           PRUNE                                                           \ 0 VALUE HDR                                                   : CATCH SP  PUSH     HDR PUSH     RP TO HDR                             EXEC                                                            HDR TO RP    POP TO HDR   RDROP  0 ;                    : THROW ?DUP IF  ( E/ )       POP                                   ( EA /   )   HDR   TO     RP                                    ( EA / SH)   POP   TO     HDR                                   ( EA / S )   POP   -ROT   PUSH                                  ( SE / A )   PUSH  TO SP  DROP   POP                        THEN ;                                                                                                                          : SAFE/  ?DUP   IF / ;THEN  5 THROW ;                           : PROBA ['] SAFE/ CATCH IF DROP ." ZERO DIVIDE"  THEN ;                                                                                                                                                                                                         MARKER -TARGET   PREVIOUS  VOCABULARY TCOMP   ASSEMBLER ALSO      TCOMP ALSO   DEFINITIONS                                      |   32768 CONSTANT MSB     |  MSB 1-  CONSTANT -MSB              VARIABLE LX : CODE, HEADER , ;                                  | : @LITERAL @ [',] LITERAL ;                                   | : @, @ , ;                                                    10 WARY ADR:  10 WARY VAL:                                      : ALIGNED HERE SWAP ALIGN TO HERE ;                            | :   GET:   0 DO ' 2+ DUP I ADR: ! @  I VAL: ! LOOP ;           : RESET:   0 DO I VAL: @  I ADR: @ ! LOOP ;                     :   SET:   0 DO ' EXEC  I ADR: @ ! LOOP ;                                                                                        10 GET: AGAIN SKIP UNTIL IF -UNTIL -IF ;M DO: [LIT] OF         : (( HEADER COMPILE [ ' DO: @, ] , , IMMEDIATE ;               -->                                                                                                                              | : CONST CREATE LX LINK+ , , DOES> 2+ DUP 1+! 2+ @LITERAL ;    | : <F> <% CONST IMMEDIATE %> ;   | : <00F> 0 0 <F> ;          <%                                                               ' IOV @                                                         1 NM: HERE 2+ SWAP! ;M                                          2 NM: @LITERAL ;M                                                HEADER JUSTIFY , , , 0 ,  IMMEDIATE                           %>                                                               : RDROPS CO RDROP ;                                             | : DUPE? RDROPS RESCAN 0>=                                        IF 2DROP ;THEN STR ROT - IF DROP ;THEN  RDROP                  2+ STR 0< A" DUP! " MSB OVER 2- XOR!  HERE   ;                | : ?REL HERE SWAP  IF OVER 2+ - THEN ;                         | : A?REL DUP 1- C@ 1 OR $ E9 XOR 0= ?REL ;                       -->                                                                                                                           : FW <00F> TO JUSTIFY                                                DOES> 2+ DUP 1+! STR 0<                                               IF @, ;THEN LINK+ ;                                  : ?FW JUSTIFY DUPE?  N>C SWAP                                            BEGIN OVER TO >< ?DUP -UNTIL DROP ;                    : FL <00F> TO JUSTIFY                                                DOES> 2+ DUP 1+! STR 0<                                               IF @LITERAL ;THEN    ?E ' CASE                            ['] JMP,  OF BCOMPILE [ $ E9 C, ]                                       LINK+ ENDOF                                             ['] CALL, OF BCOMPILE [ $ E8 C, ]                                       LINK+ ENDOF                                             [']   DW, OF LINK+ ENDOF                                                      A" NO LBL OP!" ENDCASE ;                     | : ?FL JUSTIFY DUPE? BEGIN TO >< ?DUP    WHILE A?REL REPEAT            ( !!! BLWORD DROP )    BLWORD DROP RDROP ;  -->         : C: MSB <F> ;   : L: ?FL HERE C: ;   : +C: 2+ DUP C: ;        | : ?TAB 52 OUTC < IF CR ;THEN  26 OUTC OVER MOD - SPACES  ;    | : VIEWER: : DOES> PUSH  CR LX @ SKIP BEGIN                      STR SWAP DUP @ R@ EXECUTE THEN ?DUP -UNTIL RDROP ;            | : ?NODE. 0= IF  DUP STR .H @ .H 4 - ?ID. ?TAB ;THEN DROP ;    VIEWER:  TLIST.  DUP XOR ?NODE. ;                               VIEWER:  UNDEF.  0< ?NODE. ;                                    VIEWER: UNUSED.  -MSB AND ?NODE. ;                              \ PREVIOUS                                                       VOCABULARY KERNEL   KERNEL ALSO F83    PRUNE                                                                                                                                                                                                                                                                                                                                                                                                                   \  FORWARD DEFINITIONS     LABELS & WORDS                         F83    ' , 2+ ALIAS COMPILE                                                                                                     KERNEL  DEFINITIONS  -MAC                                                                                                      FL ;#      FL JUMP#  FL OF#                                     FL <JSR    FL IF#    FL EXEC#                                   FL @IP#    FL NEXT#  FL -IF#                                    FL _TOP    FL <VAR   FL <DOES                                   FL <MAIN   FL <EX  \ FW COMPILE                                 FL <WARY   FL <PUSH  FL <DROP                                   FL <SWAP   FL <DBG   FW ;CODE                                   FL <TRONX                                                      -->                                                                                                                                                                                             \  FORWARD DEFINITIONS CONTINUE ...      USER CONSTANTS          0  +C: ->TASK   +C: -<TASK   +C: ->SP   +C: >S0    +C: >R0      +C: >FRAME     +C: >SELF     +C: >HDR   +C: >H     +C: >BASE    +C: >OUT      +C: >BLK       +C: >>IN   +C: >TIB   +C: >STATE                                                                   +C: >HOLD   +C: >SCR         +C: >CSP     +C: >DBL              +C: >SPTR   +C: >MPTR        +C: >MTOP    +C: >RPTR             +C: >VLINK  +C: >CURRENT     +C: >CONTEXT                       +C: >AX_R   +C: >BX_R   +C: >CX_R                               +C: >DX_R   +C: >ER_R   +C: >ER_A                               +C: >?USER                                                                                                                     DROP            -->                                                                                                                                                                                                                                              ASM   256 ALIGNED \ KERNEL SOURCE IN ASSEMBLER                                                                                  L: START/   CLD, JMP,F 1                                        L: _BOOT 0 DW,     L: _COLD 0 DW,                               L: _WARM 0 DW,     L: _USER 0 DW,                               L: _OF    OF# DW,  L: _JUMP JUMP# DW,   L: _IF     IF# DW,      L: _-IF   -IF DW,  L: _JSR   <JSR DW,   L: _LIT   @IP# DW,      L: _EXIT   ;# DW,  L: _NEXT NEXT# DW,   L: _EXEC EXEC# DW,      L: _ARME 0 DW,                  L: _DERR 0 DW,                  L: _PRSC 0 DW,                                                  L: _EMIT 0 DW,     L: _KEY  0 DW,  L: _?KEY 0 DW,  \ IO         L: _VSEG 0 DW,     L: _VATR 0 DW,  L: _CRRY 0 DW,  \ VIDEO      L: _DSTEP <TRONX DW,  0 DW,  _JUMP DW, _DSTEP DW,  \ DEBUG      L: FSTAT  <VAR DW, L: _AX   0 DW,  L: _SI   _DSTEP 2+ DW,       FL! 1     -->                                                                                                                     NOP,     CALL,F 1         L: _ORIG <WARY DW,                 \ 6    >TASK    <TASK          >SP         S0        R0         0 DW, $ FE00 DW, $ FE00 DW, $ FA00 DW, $ FA00 DW,  $ F400 DW,   \ FRAME  SELF   HDR     H       BASE    OUT     BLK     >IN      0 DW,   0 DW, 0 DW,  _TOP DW,  10 DW,  0 DW,  0 DW,  0 DW,     \ TIB   STATE   HOLD    SCR     CSP     DBL                      0 DW,   0 DW,  0 DW,  0 DW,   0 DW,  0 DW,                     \ SPTR  MPTR    MTOP    RPTR                                     0 DW,   0 DW,  0 DW,   0 DW,                                   \ AX_R    BX_R    CX_R    DX_R    ER_R    ER_A                   0 DW,   0 DW,   0 DW,    0 DW,   0 DW,   0 DW,                                                                                 \ +C: >VLINK  +C: >CURRENT     +C: >CONTEXT                                                                                     FL! 1         -->                                                                                                                            SI POP,          -2 /SI CX MOV,                        2 /SI DI MOV,          DI _USER /// MOV,                        REP, AL MOVS,                 AX AX XOR,                      $ 80 #, SI MOV,            -168 #, DI MOV,                             AL LODS,                 AX BX MOV,                        AH 0 X/S MOV,              1 /BX CX LEA,                       REP,  AL MOVS,          $ 1000 #, BX MOV,                      $ 4A #, AH MOV,                    33 INT,                                                                                     <% : CRY@ _CRRY /// AX MOV, SAHF, ;  : DROP, BX POP, ;             : SCASW,2 SCASW, SCASW, ;   : SCASW,3 SCASW,2 SCASW, ;          : DUP, BX PUSH, ;   : CRY! LAHF, AH _CRRY 1+ /// MOV, ;         : <J>  CONSTANT DOES> @ JMP, ;    : H>J, HERE <% <J> %> ;    %>                      -->                                                                                                                                                                     \ Arithmetic                                                    L: +*# 1 #, DL TEST, 0=, NOT, IF, AX POP,    AX BX ADD,          AX PUSH, THEN, 1 #, BX RCR, 1 #, DX RCR, -?, IF,               L: +?#  CRY@ AX POP,   AX BX ADC,   -?, IF, ( 14  + )           L: ;#     0 /BP SI MOV,                                         L: <RDROP   BP INC,   BP INC,         -?, FB, 0   ( 0  ; )      L: POP#     DUP, 0 /BP BX MOV,  <RDROP JMP,       ( 19  pop)    L: JUMP#       LODSW,                 -?, FB, 2   ( 2 JUMP v)   L: OF#        AX POP,   AX BX XCHG,                                   BX AX  XOR, JUMP# JNZ,  DROP,                             L: <SKIP    LODSW,                    -?, FB, 62                L: DUP#  DUP,                -?, FB,  18    ( 18  dup)          L: 2*# 1 #, BX SHL,          -?, FB,  11    ( 11  2*)           L: 2/# 1 #, BX SAR,          -?, FB,  12    ( 12  2/)           L: INV#     BX COM,          -?, FB,  13    ( 13  - )                           -->                                             L: IF#    LODSW,  BX BX OR,   0=, FB, 6  -?, FB, 36  ( 6 IF)    L: -IF#   LODSW,  BX BX OR,   0<, FB, 7  -?, FB, 37 ( 7 -IF)    L: NEXT#  LODSW,   -1 #, CX MOV, CX W/ 0 /BP ADD,                                    <RDROP JNB,   -?, FB, 5    ( 5 NEXT )      L: AND# AX POP,  AX BX AND,    -?, FB, 15   ( 15  AND)          L: OR#  AX POP,  AX BX XOR,    -?, FB, 16   ( 16  OR )          L: +#    AX POP,   AX BX ADD,                                            THEN, THEN,  CRY!   -?, FB,  14    ( 14  + )           L: RPUSH#   AX POP,  AX BX XCHG,  SKIP1,        ( 1d puSH)      L: CALL#    LODSW,  L: <RPUSH    AX SI XCHG,    ( 3 CALL )      L: <PCPUSH  BP  DEC,  BP DEC,  SI 0 /BP MOV,                         FB! 2  FB! 6  FB! 7  FB! 5         ( JUMP#  IF  -IF )      L: <JUMP    AX SI XCHG,        -?,  IF,                         H>J, >PUSH,   L: <PUSH           DUP,                           H>J, >SWAP,   L: <SWAP    AX BX XCHG,  \  SKIP2,               -->                                                             \ H>J, >2DROP,  L: <2DROP         DX POP,                           FB! 11 FB! 12  FB! 13  FB! 15 FB! 16  FB! 37   THEN,            FB! 14 FB! 0   FB! 62  FB! 18   FB! 36                       H>J, >NEXT,   L: <MAIN  AX LODS,                                L: <EX        AX DI XCHG,      0 /DI JMP,   <DBG  JMP,          L: CALL>F         AX POP,    <PCPUSH JMP,                       L: SP@#   DUP,  SP BX MOV,   >NEXT,       (  SP@   )            L: SWAP#  AX POP,            >PUSH,                             L: RP@#   BP AX MOV,         >PUSH,       (  RP@   )            L: A@#    DX AX MOV,         >PUSH,       (   A@   )            L: @IP#       LODSW,         >PUSH,       (   @P   )            L: @P#   AX IN,              >PUSH,                             L: OVER#  AX POP,   AX PUSH, >PUSH,       ( 1a oveR)            L: >FORTH         AX POP,    <JUMP   JMP,        -->                                                                                                                                            L: C@IP#     AL LODS,                                          H>J, >BPUSH,  L: <BPUSH 0 #, AH MOV, >PUSH,                      L: C@P#   AL IN,             >BPUSH,                            L: !#       BX DX MOV,  DROP,                        ( 1e b!)   L: !A#      DX DI MOV,                     -?, IF,   ( 0f ! )   L: !A+#     DX DI MOV, 2 #, DX ADD,        -?, IF,   ( 0D !+)   SCASW,3    THEN, THEN,                                          L: <STORE   BX 0 /DI MOV,                                       H>J, >DROP,   L: <DROP          DROP,   >NEXT,                 SCASW,3    L: <DOES AX POP,   DUP, DI BX MOV,  <PCPUSH JMP,     -->                                                                                                                                                                                                                                                                                                                                                                                             SCASW,3   H>J, >VAR,   L: <VAR  AX DI XCHG, >PUSH,              SCASW,3  SCASW,        L: <JSR  AX DI XCHG, <PCPUSH JMP,                                                                         L: @R#   0 /BP DI MOV,                   -?, IF,     ( 08 @R)   L: @A+#  DX DI MOV,  DX INC, DX INC,     -?, IF,     ( 09 @+)   L: @#    BX DX MOV,  DROP,                           ( 1e b!)   L: @A#   DX DI MOV,                      -?, IF,     ( 0b @ )   SCASW,3  THEN, THEN, THEN,                                      L: <FETCH   DUP, 0 /DI BX MOV,  >NEXT,                          L: SP!#   BX SP MOV,         >DROP,                             L: RP!#   BX BP MOV,         >DROP,       ( 1F   A!)            L: A!#    BX DX MOV,         >DROP,       ( 1F   A!)            L: C!P#  BX AX MOV, AL OUT,  >DROP,                             L:  !P#  BX AX MOV, AX OUT,  >DROP,                            -->                                                                                                                              L: !R+#   0 /BP SI XCHG,  BX 0 /SI MOV, DROP, LODSW, ( 0C !R)   L: ;:#    0 /BP SI XCHG,    >NEXT,                   ( 1  ;:)   L: <USER!   _USER DI MOV, <STORE JMP,                           L: C!A+#       DX DI MOV,  BL 0 /DI MOV, DX INC,   >DROP,       L: C@T+#    0 /BX AL MOV,  BX INC,   >BPUSH,                    L: @T+#    BX SI XCHG,  LODSW,  BX SI XCHG, >PUSH,                                                                              L: <ALI  SKIP2,  SCASW,3                                        L: <@EXEC  0 /DI AX MOV,  AX AX OR,  0=, IF,    >NEXT,          L: <PERFORM   BX DI MOV,  DROP,              <@EXEC JMP,        L: EXEC#     AX BX XCHG,  DROP,   THEN,         <EX JMP,        SCASW,3                                                         L: <EXEC AX DI XCHG, <EX JMP,                                  -->                                                                                                                                                                                              \ DOS INTERFACE                                                 L: <DOS  AX BX XCHG,  DROP,  CX POP,  DX POP,  ( A!)             $ 21 INT,  AX PUSH,  DUP,   CX PUSH, DX PUSH,    U<, NOT,       IF,  AX AX XOR, THEN,   AX BX XCHG,  >NEXT,      H>J, >USER,                                                                   L: XUSER   CX PUSH, 2 /DI DI MOV,  _USER /// DI ADD, RET,       L: <USER   <VAR   #, CX MOV,  >USER,                                  SCASW,2                                                   L: <@USER  <FETCH #, CX MOV,  >USER,                                  SCASW,                                                    L: <!USER  <STORE #, CX MOV,  >USER,                                                                                           -->                                                                                                                                                                                                                                                                                                                                                                                              L: <TROFF LODSW, -?, FB, 63                                     L: <TRONX LODSW,                                                L: <DBG $ 2E #, <EX /// XOR,  FB! 63                                _AX #,  DI  MOV,    AX 2 /DI XCHG,                               SI 4  /DI XCHG,       AX DI XCHG, 0 /DI JMP,                                                                                   0 DW,  0 DW,  0 DW,  0 DW,  0 DW, 0 DW,                                                                                      (  1 8 +THRU  HERE START/ - . )   END-CODE                                                                                    -->                                                                                                                                                                                                                                                                                                                                   +*#  CODE, +*                                                   +?#  CODE, +?                                                    +#  CODE, +                                                   AND#  CODE, AND                                                  OR#  CODE, XOR                                                 DUP#  CODE, DUP                                                  2*#  CODE, 2*                                                   2/#  CODE, 2/                                                  INV#  CODE, INV                                                   ;#  CODE, EXIT                                              <RDROP  CODE, RDROP                                               POP#  CODE, POP                                               RPUSH#  CODE, PUSH                                               CALL#  CODE, CALL         ;:#   CODE, ;:                    -->                                                                 SWAP#  CODE, SWAP                                           \    FLIP#  CODE, FLIP                                              <MAIN  CODE, NOP                                                 @IP#  CODE, @IP                                                OVER#  CODE, OVER                                                @A+#  CODE, @A+                                                   @#  CODE, @            !#  CODE, !                             A@#  CODE, A@          @A#  CODE, @A                          C@T+#  CODE, C@+                                                 @T+#  CODE, @+                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                  SP!#  CODE, SP!          SP@#  CODE, SP@                      <TROFF  CODE, TROFF                                               RP!#  CODE, RP!          RP@#  CODE, RP@                      <TRONX  CODE, TRON                                                 !A#  CODE, !A            A!#  CODE, A!                         <DOS  CODE, DOS                                                 C!P#  CODE, C!PORT        !P#  CODE, !PORT                     <DROP  CODE, DROP                                                 @P#  CODE, @PORT        C@P#  CODE, C@PORT                      @R#  CODE, @R           !R+#  CODE, !R+                        !A+#  CODE, !A+         C!A+#  CODE, C!A+                   <PERFORM  CODE, PERFORM                                                                                                        -->                                                                                                                                                                                              \ GENERATE HI LEVEL WORDS  IN  NEW KERNEL                       \  DECIMAL    89  LOAD                                          \  DECIMAL   301  LOAD  \ LOW LEVEL DEFINITIONS IN ASSEMBLER    \  DECIMAL   300  LOAD  \ HI LEVEL DEFINITIONS - PRIMITIVS      \  DECIMAL   1 2 +THRU  \ DEFINITION WORDS   ALIAS, CONSTANT .                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -->                                                                                                                                                                                              <%   ALSO  TO TCOMP                                                : DOES> [',] ;CODE                                                      [ <DOES 1- ] LITERAL                                            [AT] DOES> ; IMMEDIATE                                  : ALIAS    HEADER COMPILE [ <ALI ,   ] , ;                      : VECTOR   HEADER                                                       COMPILE [ <@EXEC 1- , ]                                         COMPILE [ <STORE 1- , ] , ;                             : VARIABLE HEADER                                                       COMPILE [ <VAR 1- , ] 2Z, ;                             : CONSTANT HEADER                                                       COMPILE [ <FETCH 1- , ] , ;                             : USER     HEADER                                                       COMPILE [ <USER  , ] , ;                            -->                                                                                                                                 : VUSER    HEADER                                                       COMPILE [ <@USER  , ]                                           COMPILE [ <!USER  , ] , ;                               : QUSER    HEADER                                                       COMPILE [ <@USER 1- , ]                                         COMPILE [ <!USER 1- , ]                                         COMPILE [ <USER  , ] , ;                                : VALUE    HEADER                                                       COMPILE [ <FETCH 2- , ]                                         COMPILE [ <STORE 1- , ] , ;                             : QUAN HEADER                                                           COMPILE [ <FETCH 3 - , ]                                        COMPILE [ <STORE 2- , ]                                         COMPILE [ <VAR 1- , ] , ;                           -->                                                                                                                                                                                                 ' <MARK  ' PUSH ((  FOR                                         ' ,<MARK  _NEXT ((  NEXT                                                                                                        : : ?FW : ;                                                                                                                  %>  ;METHOD                                                                                                                     -MAC  \ WITHOUT MACROS                                           10 SET: _JUMP _JUMP _IF _IF _-IF _-IF _EXIT _JSR _LIT _OF                                                                                                                                      \ : (( HEADER COMPILE [ ' DO: @, ] , , IMMEDIATE ;                                                                             -->                                                                                                                             ->TASK VUSER >TASK  -<TASK VUSER <TASK  ->SP VUSER >SP          >S0    VUSER S0     >R0 VUSER R0      >FRAME VUSER FRAME         >SELF VUSER SELF  >HDR VUSER HDR         >H QUSER HERE          >BASE VUSER BASE  >OUT VUSER OUT>      >>IN VUSER >IN           >BLK  VUSER BLK   >TIB VUSER TIB     >STATE VUSER STATE                                                                         >HOLD VUSER HOLD   >SCR VUSER SCR       >CSP VUSER CSP          >SPTR QUSER SPTR  >MPTR VUSER MPTR     >MTOP VUSER MTOP          >DBL VUSER DBL  >VLINK VUSER VLINK >CURRENT VUSER CURRENT      >CONTEXT  VUSER CONTEXT                                         >AX_R VUSER AX_R  >DX_R VUSER BX_R     >CX_R VUSER CX_R         >DX_R VUSER DX_R  >ER_R VUSER ER_R     >ER_A VUSER ER_A        >?USER VUSER ?USER                                              -->                                                                                                                                                                                              \  TEST FOR NEXT : ALIAS DOES> CONSTANT VARIABLE USER ;          0 CONSTANT 0  1 CONSTANT 1                                     -1 CONSTANT -1 2 CONSTANT 2                                     : MAX INV OVER + INV -IF DROP EXIT THEN + ;                     : 1+  1 + ;                                                     : MIN INV OVER + INV -IF + EXIT THEN DROP ;                     : 1- -1 + ;                                                     : NEGATE INV 1+ ;                                               : ABS -IF NEGATE THEN ;                                         : NIP OVER XOR XOR ;                                            : OR OVER INV AND XOR ;                                         : EMIT _EMIT PERFORM ;                                          : ?2^ DUP 1- AND 0= ;                                           : ?EMIT OVER INV +   -IF DROP EMIT EXIT THEN DROP ;             -->                                                                                                                             : TYPE FOR C@+ EMIT NEXT DROP ;                                 : CLIP PUSH MAX POP MIN ;     \ : KEY  DUP   _KEY PERFORM ;     : ?KEY DUP  _?KEY PERFORM ;                                     : SEARCH FOR @A+ OVER XOR                                                  IF DROP                                                       NEXT DROP 0 EXIT THEN                                           RDROP ;                                                : * A!  15 FOR +* NEXT DROP A@ ;                                : *M A! 15 FOR +* NEXT PUSH DROP A@ POP ;                       : /MOD  FOR BEGIN OVER OVER +  -IF DROP 2*   NEXT EXIT THEN                 OVER XOR  XOR INV 2* INV     NEXT ;                -->                                                                                                                                                                                                                                                                                                                              : D0 0 0 ;  \ IO KERNEL FUNCTIONS                               : DO_DOS A@ PUSH DOS TO AX_R  A@ TO DX_R  POP A! ;              : DO_HANDLE PUSH HANDLES POP DO_DOS ;                           : HFSIZE D0 $ 4202 DO_HANDLE ;                                  : HCLOSE D0 $ 3E00 DO_HANDLE ;                                  : HREAD $ 3F00 DO_HANDLE ;                                      : HWRITE $ 4000 DO_HANDLE ;                                     : BLKPOS 1K M* $ 4200 DO_HANDLE ;                               : FOPEN  D0 $ 3D02 DO_DOS ;                                     : RBLK BLKPOS 1K HREAD ;                                       -->                                                                                                                                                                                                                                                                                                                                                                                                                                                              : WBLK BLKPOS 1K HWRITE ;                                       : F_KEY 1 SP@ OVER HREAD ;                                      : F_EMIT SP@ 1 HWRITE NIP ;                                     : STD_KEY  0 D0 $ 100 DO_DOS ;                                  : STD_EMIT  D0 $ 200 DO_DOS ;                                   : STD_?KEY  D0 D0 DO_DOS ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ /MOD TEST                                                                                                                      : /MOD  FOR OVER OVER + DUP 0<                                                                 IF DROP 2* [ SWAP ]                                                        NEXT ;THEN                        OVER XOR XOR  NOT 2* NOT  TO (FOR ;                                                                                EXIT                                                             : /MOD  FOR BEGIN OVER OVER +  -IF DROP 2*   NEXT EXIT THEN                 OVER XOR  XOR INV 2* INV     NEXT ;                                                                                     -IF DROP 2*      NEXT EXIT THEN                                         OVER XOR  XOR INV 2* INV                                      TO (FOR ;                                                                                                                                                                            \                                                               \ : P1 OVER OVER + S. ;  : P2 DROP 2* S. ;                      \ : P3 OVER XOR XOR NOT 2* NOT S. ;                             \ EXIT                                                           0  VALUE DVZ   : D2* 2DUP D+ ;                                 : 1/MOD D2* DUP DVZ U< IF ;THEN DVZ - PUSH 1+ POP ;             : N/MOD TO DVZ 16 FOR 1/MOD NEXT ;                                                                                              EXIT                                                            : D1+ 1. D+ ;                                                   : D2* PUSH DUP + POP DUP ?+ ;                                   : /MOD A! 15 FOR BEGIN    D2* DUP A@ INV +                                    -IF DROP NEXT                                       EXIT THEN   A@ - D1+ NEXT ;                                                                                                                                                                   \ < > U<   WITH  XOR NOT +                                      : - NOT 1 + + ;                                                                                                                                                                                  0  VALUE DVZ                                                    : /MOD  TO DVZ  16  FOR DUP DVZ - DUP 0<                               IF DROP PUSH 2* POP [ SWAP ]                                                                       NEXT ;THEN                        OVER XOR XOR  PUSH NOT 2* NOT POP  TO (FOR ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                       MARKER MINI                                                                                                                                                                                     MAC: INV -1 XOR ;                                               MAC: -IF DUP 0< IF ;                                             : MAX INV OVER + INV -IF DROP EXIT THEN + ;                     : MIN INV OVER + INV -IF + EXIT THEN DROP ;                                                                                    : PROBA -1 -IF 0 THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          _key2:  CALL _hnd_GT                                                    XCHG AX,BX                                                      mov  cx,1                                                       push cx                                                         mov  dx,sp                                                      mov  ah,3fh                                                     int  21h                                                        pop  Cx                                                         xchg ax,cx                                                      jcxz @@2                                                        cmp  al,' '                                                     jae  @@1                                                                                                                                                                                                                                                                                                               :1 HEADER :089A 0 ?DUP IF 1- TO HEADER                             HERE TO CFA  TO VSWAP CFA ALIAS TO VSWAP ;THEN                TO CREATE TO CFA ;                                             :1 CREATE :136A HEADER COMPILE :02D8 ;                          :136D :0102  AT CURRENT TO WORD DUP CURRENT ! ", , ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             _EMIT1: MOV  DL,BL                                                      MOV  AH,2                                                       INT  021h                                                       ret                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     XNONAME:SCASW               ;                                           PUSH BX             ;                                           MOV  BX,[DI]        ;                                   XEXQCOM:mov  di,PW userv                                                mov  cx,[di+UvStat-Uv0]                                         jcxz xEXEC                                                      jmp  short xcomma                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      