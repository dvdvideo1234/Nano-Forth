// SIMBOLS  ÅöãÉÄêëäà à ãÄíàçëäà                                // COMMON   ABCEHK MPTìX              11                        // LAT      DFGJLN QRUVWZ             12  1 5  I S              // äàêàãàñÄ ÅÉÑÜàâãèîñóòôöúûü         18                        // ñàîêà    0123456789                10                        // áçÄñà    ./*,;+ -!@<>=             13                        //                                -------------                 //                                    64                        // COMMON   ABEKMHPCTìX               11                        // LAT      DFGIJLNQRSUVWZ            14                        // äàêàãàñÄ ÅÉÑÜàâãèîñòôöúûü          16                        // ñàîêà    0123456789                10  0 O  3 á  4 ó         // áçÄñà    ./*,;+ -!@<>=             13                        //                                -------------                 //                                    64                                                                                        \   +  AND  XOR  U2/C    CALCULATION                            \ DUP DROP  PUSH  POP    STACK                                  \  @+   !+  LIT  SWAP    DATA                                   \ NOP    ;   IF  CALL    CONTROL                                MARKER -RP   -MAC MAC: PUSH >R ;  MAC: POP R> ; MAC: D+ TO + ;  MAC: -ROT TO ROT ;                                               : DO. CREATE [',] C" C, DOES> C@ EMIT ;  DO. [. [  DO. ]. ]    : DOSTK. CREATE , DOES> @ TO @ CR [. ?DO I @ H. 2 +LOOP ]. ;    200 ALLOT HERE DUP <STACK #RP ,   AT #RP DOSTK. R.              200 ALLOT HERE DUP <STACK #SP ,   AT #SP DOSTK. S.              $ 8000 CONSTANT MSB    0 VALUE CARRY    0 VALUE ACC             ' KEY VECTOR 'KEY     ' EMIT VECTOR 'EMIT   2 CONSTANT CELL     : ;DX+ OVER POP -ROT PUSH PUSH PUSH CO POP POP + ;              : ;-OP   #SP ACC CO       TO ACC ;          : @+ CELL ;DX+ @ ;  : ;+OP       ACC CO       TO ACC TO #SP ;                       : ;COP     CARRY CO 1 AND TO CARRY ;                            : #+    ;-OP ;COP DROP 0 SWAP OVER D+ ;                         : #XOR  ;-OP XOR ;    : #KEY   ;+OP 'KEY  ;                     : #AND  ;-OP AND ;    : #EMIT  ;-OP 'EMIT ;                     : #U2/C ACC DUP 2/ ;COP IF MSB OR THEN SWAP ;                   : #DUP  ;+OP DUP ;   : #: : DOES> POP TO #RP PUSH ;             : #DROP ;-OP DROP ;                                             : #PUSH ;-OP TO #RP ;          : #POP  ;+OP #RP ;               : #@+   ;+OP CELL ;DX+  @ ;    : #!+  CELL ;-OP ;DX+ ! ;        : #C@+  ;+OP    1 ;DX+ C@ ;    : #C!+    1 ;-OP ;DX+ C! ;       : #LIT  POP  @+ PUSH ;+OP SWAP ;  : #SWAP #SP ;+OP SWAP ;       : #;    POP DROP #RP PUSH ;    : #NOP  ;                        : #IF   POP @+ ACC IF SWAP THEN PUSH DROP ;                     : #CALL POP @+ TO #RP PUSH ;                                                                                                                                                                                                                                    MAC: ! !+ DROP ;                                                MAC: @ @+ DROP ;                                                MAC: @R+ POP @+ PUSH ;                                          MAC: !R+ POP !+ PUSH ;                                          MAC: 2* DUP + ;                                                 MAC: @R  POP DUP PUSH @ ;                                       MAC: CARRY@ 0 U2/C ;                                            MAC: CARRY! 2* DROP ;                                           MAC: 1- -1 + ;                                                  MAC: 1+ 1 + ;                                                   MAC: XCHG POP SWAP PUSH ;                                       : INVERT -1 XOR ;                                               : NEGATE INVERT 1+ ;                                            : - NEGATE + ;                                                                                                                                                                                  : ROT PUSH SWAP POP SWAP ;                                      : -ROT SWAP PUSH SWAP POP ;                                     : NIP PUSH DROP POP ;                                           : OVER PUSH DUP POP SWAP ;                                      : OR OVER INVERT AND XOR ;                                      : 2/ DUP 2* DROP U2/C ;                                         : CLC 2* U2/C ;                                                 : U2/ CLC U2/C ;                                                : +C CARRY@  IF DROP 1+ CARRY@ IF PUSH + POP CARRY! ;THEN                    THEN DROP                 + ;                      : 0= IF 0 AND ;THEN INVERT ;                                                                                                                                                                                                                                                                                                                                                                    : (JUMP POP @ PUSH ;                                            : EXECUTE PUSH ;                                                : ;: POP XCHG PUSH ;                                            :  (FOR POP @+ ROT IF 1- PUSH PUSH DROP ;THEN DROP DROP PUSH ;  : (NEXT POP @+ POP IF 1- PUSH DROP PUSH ;THEN DROP PUSH DROP ;                                                                  :  1MOVE PUSH C@+ SWAP POP C!+ ;                                :  2MOVE PUSH @+ SWAP POP !+ ;                                  : ;MOVE U2/ POP CARRY@ PUSH PUSH ;: POP                                     IF -ROT 1MOVE THEN DROP DROP DROP ;                 : MOVE ;MOVE FOR 2MOVE NEXT ;                                   : TYPE FOR C@+ EMIT NEXT DROP ;                                                                                                                                                                                                                                                                                                 ( ;EVAL >IN TIB LNUF NEWBUFSIZE )                               : ;BUFFER         ( SIZE )                                            POP OVER    ( SIZE RETURN ZIZE)                                 DUP NEGATE  ( SIZE RETURN SIZE -SIZE )                          RP + DUP    ( SIZE RETURN SIZE BADR -- RP -=SIZE )              TO RP -ROT  ( SIZE BADR  RETURN SIZE)                           PUSH PUSH   ( SIZE BADR | RETURN SIZE)                     SWAP OVER OVER   ( BADR SIZE BADR SIZE -- ERASE ALLOCATED MEM)       ERASE CO    ( BADR SIZE -- RETURN TO CALLER)                    POP  POP    ( RETURN SIZE -- AFTER END OF CALLER )              RP + TO RP  ( RETURN -- FREEING MEMORY )                        PUSH ;                                                                                                                                                                                                                                                                                                                    \ ;PARAMETTERS       BLK >IN TIB LBUF FEOF                      : ;PARAMETTERS POP ( BLK >IN TIB LBUF FEOF RETURN )                    LBUF PUSH   BLK PUSH   >IN PUSH  TIB PUSH                       FEOF PUSH  ERRP PUSH  ( ONERR POINTER )                         RPOS PUSH RP TO RPOS  PUSH ( SET RETURN )                      ( FEOF BLK >IN TIB LBUF -- OLD VALUES SAVED)                                        ( FEOF BLK -- PROCESS NEW ONES)              TO FEOF  TO LBUF  TO TIB  TO >IN  TO BLK                   SKIP  BEGIN   DROP ?OK  TIB  80 REFILL  THEN                    BEGIN 32 PARSE WHILE FIND TODO REPEAT  2DROP                            NOREFILL UNTIL  DROP                                   RPOS TO RP   POP TO RPOS  POP TO ERRP  POP TO FEOF              POP TO TIB   POP TO >IN   POP TO BLK   POP TO LBUF   ;                                                                                                                                                                                                         \ ;FILE  STRUCTURE /FPTR/FHAND/NLINE/'KEY/'EMIT/                : ;FILE  POP               ( ADR LEN BUFF LBUF RETURN)               AT 'EMIT PUSH    AT 'KEY PUSH  NLINE PUSH  PUSH                PUSH SWAP OVER PUSH    ( ADR BUFF LEN | BUFF LBUF )          DUP IF  CMOVE POP DUP POP ( BUFF BUFF LBUF )                            POP ROT           ( BUFF LBUF RETURN BUFF)                      OPENF  DUP A" OPEN FILE ERROR "                                                   ( BUFF LBUF RETURN NEW_FHAND)                 FHAND PUSH  FPTR PUSH  RP TO FPTR  TO FHAND  PUSH               $ 8001 ( EOF|FILE = FEOF) FIO CO ( RETURN TO CALLER )           POP TO FPTR  POP TO FHAND  POP                              ELSE DROP DROP DROP POP POP                                         $ 8002 ( EOF|KBD = FEOF)  SIO CO ( RETURN TO CALLER )       THEN  POP TO NLINE  POP TO 'KEY  POP TO 'EMIT  ;                                                                                                                                           : ;EVAL POP LIT [ HERE ] LIT !                                                                                                    CO  SKIP  BEGIN   DROP ?OK  TIB  80 REFILL  THEN                BEGIN 32 PARSE WHILE FIND TODO REPEAT  2DROP                            NOREFILL UNTIL  DROP                                   RPOS TO RP   POP TO RPOS  POP TO NOREFILL   POP TO TIB           POP TO >IN  POP TO BLK     POP TO LBUF   ;                                                                                    : LOAD 0 ( >IN ) 0 ( TIB) 1K 1 TO REFLAG ;EVAL ?IO ;            : EVAL 0 0 2SWAP 1 TO REFLAG ;EVAL  ?IO ;                       : FLOAD ( ADR LEN -- OF FILENAME ) DUP 2 ALIGN 2+ 92 MAX              ;BUFFER ;FILE ;PARAMETTERS                                                                                                                                                                                                                                                                                                \ STREEM EVALUATION  - SEVAL   USING EXPECT3                  \\VARIABLE LINES  ( ' CO ALIAS ;:  210 LOAD)  |                   : OK? BLK IF CO CR ;THEN CR ." ><o " CO SPACE ;                 | : 1LINE OK?  0 TO >IN  TIB 80 EXPECT3 CO                              TIB SPAN + TO 0 TO INTERPRET ;                          | : ?IO DUP NOT IF SIO ;THEN FIO ;                              | : FOPEN HANDLES bs - 0= ?? FOPEN DUP 0< A" OPEN ERR" ;        FUNC: SEVAL ( _HANDLE _NBLK / _IN _BLK _TIB _HND _LINE )           >IN TO _IN   BLK TO _BLK  TIB TO _TIB                           RP 84 - DUP  TO RP  TO TIB    HANDLES TO _HND                   _HANDLE TO HANDLES   _NBLK TO BLK                              BEGIN   AT _LINE 1+!  1LINE  _HND  HANDLES =  UNTIL             _BLK ?IO TO BLK  _TIB TO TIB _IN TO >IN  _LINE LINES +! ;     : ;S HANDLES 0; AT HANDLES BLK 1+ 0= IF CLOSE THEN DROP ;       : FLOAD FOPEN  -1 ?IO SEVAL ;  : KBD  0 0 ?IO SEVAL ;                                                                           \   EXPECT3                                                     TO HIDDEN  FORTH  ALSO    10 CONSTANT nl                                                                                        FUNC: EXPECT3 ( _ADR _CNT / _IND _K )                             BEGIN  KEY B>W DUP TO _K                                         CASE                                                              cr OF  _IND  TO _CNT ENDOF                                      bs OF _IND                                                        IF AT _IND 1-! bs EMIT SPACE bs EMIT THEN ENDOF               #LEN _K U< IF _K  _ADR  AT _IND @1+! + C! _K EMIT THEN        ENDCASE     _IND _CNT =                                        UNTIL _IND TO SPAN ;                                                                                                                                                                                                                                                                                                          \   EXPECT3                                                     TO HIDDEN  FORTH  ALSO                                                                                                          FUNC: EXPECT3 ( _ADR _CNT / _IND _K )                             BEGIN  KEY B>W DUP TO _K                                         CASE                                                              cr OF  _IND  TO _CNT ENDOF                                      bs OF _IND                                                        IF AT _IND 1-! bs EMIT SPACE bs EMIT THEN ENDOF               #LEN _K U< IF _K  _ADR  AT _IND @1+! + C! _K EMIT THEN        ENDCASE     _IND _CNT =                                        UNTIL _IND TO SPAN ;                                          \ : TIB? BLK 0= ;                                                 1 2 +THRU     ;METHOD                                                                                                                                                                         \ FREAD  - READ FILE OF TEXT  TO BLOCKS                         \ 210 LOAD  \ EXPECT3                                           FUNC: FREAD ( _NBLK / _ADR _LIN _BLK _HND )                       HANDLES TO _HND  BLK TO _BLK   FOPEN TO HANDLES FIO -1 TO BLK   BEGIN  _LIN  1H 1- =                                              IF AT _NBLK 1+!  0 TO _LIN  0 TO _ADR THEN                           _ADR 0=                                                    IF _NBLK BLOCK DUP 1K BLANK  UPDATE TO _ADR  THEN _LIN          IF _ADR 1L   EXPECT3 CR  THEN                                   1L AT _ADR +!  AT _LIN 1+!                                      _HND  HANDLES =                                               UNTIL   FLUSH  _BLK TO BLK  _NBLK 1+ TO SCR  ;                                                                                                                                                                                                                                                                                \ STREEM EVALUATION  - SEVAL   USING EXPECT3                  \\VARIABLE LINES  ( ' CO ALIAS ;:  210 LOAD)  |                   : OK? BLK IF CO CR ;THEN CR ." ><o " CO SPACE ;                 | : 1LINE OK?  0 TO >IN  TIB 80 EXPECT3 CO                              TIB SPAN + TO 0 TO INTERPRET ;                          | : ?IO DUP NOT IF SIO ;THEN FIO ;                              | : FOPEN HANDLES bs - 0= ?? FOPEN DUP 0< A" OPEN ERR" ;        FUNC: SEVAL ( _HANDLE _NBLK / _IN _BLK _TIB _HND _LINE )           >IN TO _IN   BLK TO _BLK  TIB TO _TIB                           RP 84 - DUP  TO RP  TO TIB    HANDLES TO _HND                   _HANDLE TO HANDLES   _NBLK TO BLK                              BEGIN   AT _LINE 1+!  1LINE  _HND  HANDLES =  UNTIL             _BLK ?IO TO BLK  _TIB TO TIB _IN TO >IN  _LINE LINES +! ;     : ;S HANDLES 0; AT HANDLES BLK 1+ 0= IF CLOSE THEN DROP ;       : FLOAD FOPEN  -1 ?IO SEVAL ;  : KBD  0 0 ?IO SEVAL ;           PRUNE                                                           \  0    IF      CALL    ;       JUMP     - CONTROL              \  4    POP     AND     PUSH    XOR      - RREG + LOGIC         \  8    DROP    +       U2/C    DUP      - DREG + MATH          \ 12    SWAP    @+      LIT     !+       - TRANSFER             \                                                               \       0       1       2       3                               \       ^               ^                                       \       EVEN COLUMS   -        EVEN NUMBERS                     : OVER PUSH DUP POP SWAP ;  : INVERT -1 XOR ;  : 1+ 1 + ;       : OR OVER INVERT AND XOR ;  : NEGATE INVERT 1+ ;                : - NEGATE + ;   : >SKIP 1 + PUSH ;  : >ADR @ PUSH ;            : NIP SWAP DROP ; : @ @+ DROP ; : ! !+ DROP ;                   : (-IF DUP POP SWAP HI-BIT AND IF  DROP >SKIP ;THEN DROP >ADR ; : 0; IF DROP POP >SKIP ;THEN DROP POP @ PUSH ;                  : (NEXT POP POP IF -1 + PUSH @ PUSH ;THEN PUSH @+ NIP PUSH ;                                                                    : EX POP POP SWAP PUSH PUSH ;   : CLC DUP DUP XOR U2/C DROP ;   : CARRY+ 0 U2/C IF DROP EX 1+ ;THEN DROP ;    : +C CARRY+ + ;   : ROT PUSH SWAP POP SWAP ;   : 2*C CARRY+   : 2* DUP + ;        : DINVERT INVERT PUSH INVERT POP ;                              : D- DINVERT    : D1+  1 + IF ;THEN PUSH 1+ POP ;               : S>D  DUP HI-BIT AND IF DROP -1 THEN SWAP ;                    : M+ S>D : D+ ROT + PUSH +C POP ;  : D2*  2* PUSH 2*C POP ;     : -ROT SWAP PUSH SWAP POP ;                                     : (16+* (8+* : (8+* (4+* : (4+* (2+* : (2+* +*                  : +* DUP PUSH 1 AND                                                  IF DROP PUSH DUP POP + U2/C POP U2/C ;THEN                         U2/C DROP  POP U2/C ;                                   : UM* -ROT (                                                                                                                                                                                                                                                    