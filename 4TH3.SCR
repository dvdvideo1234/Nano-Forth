                                                                : (ARGS MAC@ CSP! ['] /ARGS TO ON;   0 1 0 0 4 LOCALS/                                                                                                                                                                                                          F83                                                             : INDEX 1+ SWAP DO CR I BLOCK I .LINE LOOP ;                    : KEYSCAN BEGIN KEY CR DUP 7 .R DUP B>W  4 .R   DUP HI 4 .R        SPACE B>W DUP EMIT   CTRL M = UNTIL ;                                                                                                                                                        : \ BLK 1 -1 WITHIN IF >IN 63 OR 1+ TO >IN                         ELSE -1 WORD DROP THEN ; IMMEDIATE                                                                                                                                                                                                                           (  THIS IS MY FIRST SCREEN         21.05.2003                 )                                                                 CR 2 . : STAR 42 EMIT ;                                         CR 3 . : STARS 0 MAX 0 DO STAR LOOP ;                           CR 4 . : MARGIN CR 30 SPACES ;                                  CR 5 . : BLIP MARGIN STAR ;                                     CR 6 . : BAR MARGIN 5 STARS ;                                   CR 7 . : F BAR BLIP BAR BLIP BLIP CR ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (  \   BLK. <> >< DEFINITIONS)                                  : \ BLK 1 -1 WITHIN IF >IN 63 OR 1+ TO >IN                         ELSE -1 WORD DROP THEN ; IMMEDIATE                           (                                    )                          ( : (SCR. BASE >R DECIMAL U. R> TO BASE ;  )                    ( : DEFINITIONS CONTEXT TO CURRENT ;   )                        ( : BLK. BLK (SCR. ; IMMEDIATE        )                         ( : <> = 0= ;                          )                        ( : >< UNPACK SWAP PACK ;              )                                                                                        \ PROBA                                                                                                                                                                                                                                                                                                                                                                                         \ ON OFF 0_2_4 6   8                                                                                                              VECTOR .IF   0 , 0 , ," .IF ," .ELSE ," .THEN 1 ,             HERE 2+ ] DOES> BL WORD 4 SWAP SCLST DUP 3 =                      ABORT" .IF NOT PAIRED"  EXIT [                                ' .IF 8 + !  : .THEN ; IMMEDIATE                                ( SKIP.IF STARTS)  : NONAMED HERE COMPILE [ ' : @ , ' ] , ]  ;  NONAMED  BEGIN [ ' .IF 8 + , ]  CASE 2 OF EXIT ENDOF             0 OF [ HERE 0 , 254 ! ] ENDOF ENDCASE AGAIN [                    DUP  ' .IF 6 + ! 254 @ ! ( SKIP.IF END )                      VECTOR UNSMUDGE  ' IMMEDIATE 6 + TO UNSMUDGE   6 LOAD           : ?EXEC STATE ABORT" execution only" ;                          : ?CSP SP CSP - ABORT" definition not finished" ;               VECTOR SMUDGE    ' UNSMUDGE TO SMUDGE                           : !CSP SP TO CSP ;                                              -1 EQU TRUE   0 EQU FALSE  CR BLK.                        -->   ( FORGET  & OTHER WORDS                                        )CR  BLK.                                                        NONAMED   ( START COMPILATION OF .ELSE )                          BEGIN [ ' .IF 8 +   , ] CASE                 ( SCAN WORDS)         0 ( .IF)   OF [ ' .IF 6 + @ , ]   ENDOF   ( SOME MAGIC)         2 ( .HERE) OF EXIT ENDOF   ENDCASE                           AGAIN [        ( END COMPILATION OF .ELSE)                    TO .ELSE       ( PATCH THE WORD)                                                                                                HEADER                                                                                                                                                                                                                                                          2 CONSTANT WSIZE                                                                                                                                                                                ( FORGET <FORGET> REMEMBER                                   )  TO HIDDEN : {WORD} >IN TO RS TO WORD RS TO >IN @ ;               : ?EXIST {WORD} 1- DUP IF DROP HERE FIND SWAP DROP THEN ;        VALUE FENCE    ' FENCE TO FENCE                               : forget   DUP FENCE U< A" fence !" TO RS  [AT] FORTH 2+           BEGIN @ DUP [AT] RS U< 0= WHILE  N>C 8 + REPEAT                 [AT] FORTH 2+ !  [ ' FORTH C>N DROP ] LITERAL                   BEGIN N>C 8 + DUP                                                 BEGIN 2- @ DUP [AT] RS U< 0=  WHILE N>C REPEAT                  OVER 2- ! @ DUP                                               UNTIL DROP [',] FORTH [TO] FORTH  RS TO HERE ;               HIDDEN TO FORTH                                                 : FORGET ' C>N DROP forget ;    : ^FORGET HERE forget ;         FORTH                                                                                                                                                                                           ( CODE .IF                         28.05.2003                 ) ( EXIT FOR .IF CODED AS                                       ) HERE ] DOES> R> 2DROP                                                  R> IF R> TO >IN ELSE RDROP THEN EXIT [                   DUP 2+ OVER ! 254 !                                                                                                             ( CODE OF THE .IF                                              )NONAMED >IN >R >R BEGIN [ ' .IF 8 + , ] CASE                    0 ( .IF  ) OF  [ ' .IF 6 + @ , ] ENDOF                          1 ( .ELSE) OF  [ 254 @ , ]     ENDOF                            2 ( .THEN) OF  [ 254 @ , ]     ENDOF ENDCASE AGAIN [            TO .IF                                                                                                                          CR BLK.                                                                                                                                                                                         ( FORGET <FORGET> REMEMBER                                     )                                                                  REGISTER FENCE ' FENCE TO FENCE                               : forget   DUP FENCE U< ABORT" fence !"                                >R [ ' FORTH C>N DROP ] LITERAL                              AT FORTH 2+ DUP @ IF DUP                                    BEGIN @ DUP R@ U< 0= WHILE N>C 8 + REPEAT                                 SWAP!    ELSE DROP THEN                               BEGIN   N>C 8 + DUP 2- DUP                                        BEGIN @ DUP R@ U< 0= WHILE N>C 2- REPEAT                        SWAP!                                                           @ DUP R@ U<                                                   UNTIL [COMPILE] FORTH TO FORTH R> TO HERE DROP ;                : FORGET ' C>N DROP forget ;                                    : SCLER   HERE CREATE , DOES> @ DUP TO FENCE forget ;                                                                           (  FORGET  & OTHER WORDS                                       ): .VOCS [AT] FORTH  6 - DUP CR C>N DROP DUP H. ID.                 BEGIN 8 + @ ?DUP                                                WHILE DUP CR H. DUP ID. N>C REPEAT ;                                                                                         : .VOCS2 [ ' FORTH C>N DROP ] LITERAL BEGIN                       DUP CR H. DUP ID. N>C 8 + @ ?DUP 0= UNTIL ;                   : ?0 -1 SWAP BLOCK TO DUP                                         ?DO I C@ 0= IF I OVER - SWAP LEAVE THEN LOOP DROP . ;         CREATE T1 ," ABRACADABRA ," VIOLET                              ," TITAN ," VOC ," VOCABULARY ," DIDO                           : NT  6 0 DO T1 CR I TO SCLST ID. LOOP ;                        CREATE T2 ," VOCABULARY                                         : TEST T1 6 T2     SCLST  .   ;                                                                                                                                                                 ( .IF .ELSE .THEN TEST                                        ) (  : DOT3 3 0 DO ROT DUP . LOOP ; )   6 5 4 CR                    1     1     0    ( 0= SWAP 0= ROT 0=  DOT3)                     .IF   .IF   .IF   1 . 0 .                                                   .ELSE 2 . 1 .                                                   .THEN                                                     .ELSE .IF   3 . 2 .                                                   .ELSE 4 . 3 .                                                   .THEN      .THEN                                    .ELSE                                                                 .IF   .IF   5 . 4 .                                                   .ELSE 6 . 5 .                                                   .THEN                                                     .ELSE .IF   7 . 6 .                                                   .ELSE 8 . 7 .                                                   .THEN      .THEN   .THEN                          ( DUMP                                                        ) TO HIDDEN                                                                                                                       : DUMPLINE  <# CR  C" ] TO HLD   0 15  DO DUP I + C@              DUP  32 < OVER 127 = OR IF DROP C" . THEN TO HLD -1 +LOOP     C" [ TO HLD bl TO HLD                                            0 15 DO DUP I + C@ bl TO HLD 0 # # TO DROP -1 +LOOP             bl TO HLD  bl TO HLD  0 # # # # #> TYPE ;                                                                                       TO FORTH                                                                                                                       : DUMP BASE >R HEX 16 /MOD SWAP IF 1+ THEN                             0 ?DO DUP DUMPLINE  16 + LOOP  DROP R> TO BASE ;                                                                         F83                                                                                                                             ( SELF. 7890123456789012345678901234567890123456789012345678901): SELF. CREATE DOES> 2- C>N DROP ID. ;                          HERE -2 ALLOT ] DOES> 2+ @ , [ ' EXIT OVER 2- !                 HERE ] DOES> AT CURRENT N>C SWAP! EXIT [ ' EXIT OVER ! 2+       HEADER MYSELF SWAP , , 0 ,   IMMEDIATE                                                                                          : HANOJ  TO MYSELF                                                       (  S_PILON 0..2   D_PILON 0..2    DISKS 1..20 )          1- ?DUP IF TO RS  TO DUP OVER OR 3 XOR AT RS  MYSELF                           TO DUP 1                  MYSELF                           SWAP OVER OR 3 XOR SWAP  RS  MYSELF                           ELSE CR ." Move Disk From Pilon  " SWAP 1+ .                            ."   To Pilon  " 1+ .   THEN   ;                                                                                                                                                                                                              ( "STR "COPY "+ "LEN "LEFT "RIGHT "MID "INS "DEL ", "MAKE )     : "COPY OVER C@ 1+ CMOVE ; | : ("+ DUP HERE @+! SWAP CMOVE ;    : "MAKE 255 MIN PAD DUP >R C! R@ COUNT CMOVE R> ;               : "LEFT SWAP COUNT ROT MIN "MAKE ; : "STR D# "MAKE ;            : "RIGHT OVER C@ MIN >R COUNT + R@ - R> "MAKE ;                 | : "BEG HERE 2+ HERE ! ; | : "END HERE TO COUNT OVER - "MAKE ; : "STR, DUP C@ 1+ FOR COUNT C, NEXT DROP ;                      : =" C" " WORD COUNT "MAKE ;                                    : "+ SWAP "BEG COUNT ("+ COUNT ("+ "END ;                       : "MID >R OVER C@ OVER 1- - TO MAX R> MIN >R + R> "MAKE ;       : "INS "BEG TO DUP COUNT ROT 1- MIN DUP >R ("+ ROT COUNT         ("+ NIP COUNT R@ - SWAP R> + SWAP ("+  "END ;                  : "DEL ( DST POS LEN) "BEG SWAP 1- DUP 3 AT OVER COUNT ROT MIN   ("+ + SWAP COUNT 2 AT OVER - TO MAX TO ROT + SWAP ("+ "END ;   : +0" PAD 2- 1 OVER ! "+ ;                                                                                                      ( "STR "COPY "+ "LEN "LEFT "RIGHT "MID "INS "DEL ", "MAKE )     "COPY  ( S1 S2 -)  COPY STRING FROM S1 TO S2                    ("+    ( A N -)  ADD STRING TO STRING BUFFER                    "MAKE  ( A1 N - S) A1 - ADDRESS N - LEN -> S - STRING           "LEFT  ( S1 N - S2)  -  LEFT N CHARS FROM S1                    "RIGHT ( S1 N - S2)  - RIGHT N CHARS FROM S1                    "BEG - INITS STRING BUF & "END  MAKES A STRING FROM BUFFER      "STR,  ( S1 -) COMPILES STRING TO HERE                          ="     ( -  S) GETS A STRING FROM INPUT STREAM                  "+     ( S1 S2 - S3)  CONCATENATES STRINGS                      "MID   ( S1 P C- S2)  STR, POS, CHARS - NEW STRING              "INS   ( S1 P S2-S3) STR1 IN POS TO STR2 MAKES STR3             "DEL   ( DST POS LEN)                                           : +0" 1 SP "+ NIP 1+ ; ADDRESS OF NUL-TERMINATED STRING                                                                                                                                         ( ;M NM: M: MAKER QUAN <STACK STACK> ON; USE: ; RECURCE )       F83  : RECOVER -2 ALLOT ;  : ;M [TO] ; ; IMMEDIATE              : M: HERE AT , [ ' WORD @ 1+ DUP @ + 2+ , ] [AT] DOES> ] ;      : NM: NEGATE HERE SWAP [TO] DOES> HERE 2- AT + ] ;              : USE: HERE [TO] : ; : LIKE, HEADER NW, ;                       : MAKER CREATE DUP C, FOR , NEXT DOES> COUNT LIKE, , ;            ' IOV @   ' SCRH DUP 2+ @ 1-   SWAP @ 1-   3 MAKER QUAN         ' IOV @ 1 NM: AT 2- ! ;M 2 NM: AT 2+ @ ;M  3 MAKER <STACK       ' IOV @ 1 NM: AT 2+ ! ;M 2 NM: AT 2- @ ;M  3 MAKER STACK>     0 QUAN RECURCE IMMEDIATE 2 NM: TO RS HERE AT RS @ , RS ! ;M     ' RECURCE ! 1 NM: TO RS AT CURRENT N>C  BEGIN AT RS @ ?DUP       WHILE DUP @ AT RS !  OVER SWAP !  REPEAT RS DROP DROP ;M       ' RECURCE 2+ ! 256 <STACK ON;   : ; [',] ; [TO] RECURCE BEGIN    AT ON; @ 256 < WHILE  ON; EXEC REPEAT  ; IMMEDIATE             : ON> ON; TO RS ; : ;CONT> RS TO ON; LIT ON> TO ON; ;                                                                           ( SHELL DOSCMD" ED DIR DEL CD RD REN CMD> CLS                 ) | : SHELL ?CS: SWAP SHELL TO DERR ;                                                                                             | : CMD2" CREATE =" "STR, DOES> =" "+ SHELL ;                   CMD2" CMD COMMAND "                                             CMD2" ED PE2 /PPE2.PRO "                                        | : CMD1" CREATE =" "STR, DOES> SHELL ;                         CMD2" DIR DIR "  CMD2" DEL DEL "  CMD2" CD CD "                 CMD2" RD RD "    CMD2" REN REN " ( CMD1" CLS CLS")              : VIEW " TYPE " =" "+ "  | MORE" "+ SHELL ;                     ( : MF7 LIT" MF7 LOADF MINI2.4TH " SHELL ; )                                                                                                                                                                                                                                                                                                                                                    ( UPCASE                                                      ) CR .( UPCASE TEST) CR    : U-CASE COUNT TO RS                                  ?CS: SWAP OVER HERE AT RS U-C HERE RS "MAKE ;    =" qWeRtYuIoP{]}|;lKjHgFdSazXcVbNm,>/"   U-CASE ".              CR CR CR  CR .( OPEN TEST) CR  ?CS: =" ARM_FILE.000" 2 1 U-ARCH    .( SP = ) SP . CR .( OPEN RESULT = ) D.                      DECIMAL FORGET IT : IT ; : ALERASE HERE OVER ALLOT SWAP ERASE ; : A-DESCR CREATE ALERASE ;                                      : DSC. DUP 12 + DO I TO @ SWAP -4 +LOOP  SWAP  . . D. D. D. ;     CREATE  DSC1 1 , 2 , 3 , 0 , 5 , 0 , 7 , 0 ,  16 A-DESCR DSC2 HEX   DSC1 DSC.   CR  DSC2 DSC.     DECIMAL                     : NEL<> AND 1+ ;                                                : A-SCAN DUP TO RS  4 + 12 0 FILL  BEGIN  AT RS 3 A-<> NEL<>      WHILE  AT RS CR DSC. ." DOMAIN CHANGE"                        BEGIN AT RS 7 A-<> NEL<>  WHILE AT RS CR DSC. ." ELEMENT CHANGE"     REPEAT  REPEAT AT DROP ;                                   ( ARGS /ARGS  ?END                                            ) ONLY HIDDEN ALSO FORTH DEFINITIONS                              : /LOCALS COMPILE [ 1 FRM , ] ; IMMEDIATE   TO HIDDEN           : ?END >IN  >R BLWORD COUNT 1-  IF DROP -1 ELSE C@ THEN         SWAP COUNT  ROT SCAN 1+ DUP  IF RDROP ELSE R> TO >IN THEN ;     USE: DUP 1 9 WITHIN IF LIT [ 7 FRM @ , ] SWAP AT 2* NEGATE +    ALIAS ELSE HEADER 2 FRM W, W, W, 2* NEGATE , IMMEDIATE THEN ;M  : LVAR  [ 0 SWAP ] LITERAL EX'MAC ; DROP ( TO LEAVE UNCHGED SP)   MAC@ CSP!  33 LOAD                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( (ARGS LOCALS( PROC                                          ) : (ARGS  1 769 LOC/                                               BEGIN 0" /)" ?END DUP 2 < ( 0 WRD 1 /)   WHILE IF L1@             IF 0 L1! ELSE 1 A" / >1 ?" THEN ELSE  L2@ 1+ DUP L2!            LVAR  L1@ IF L3 ELSE L4 THEN 1+!   THEN                       REPEAT DROP  L3@ L4@ PACK /LOC ;  ?CSP MAC!  TO FORTH         : LOCALS( (ARGS COMPILE [ 0 FRM , ] , ; IMMEDIATE                 TO FORTH  ' : ALIAS :' : : MAC@ CSP! : TO CO ?CSP MAC! ;        8 FRM ALIAS RETURN  ( DEFINE RETURN PROCEDURE )               : FUNC: : RECOVER  ( MOVE H BACK 1 CELL TO CLEAR XNEST)           C" ( BLWORD 1+ C@ =? (ARGS COMPILE [ 5 FRM @ , ] , TO CO            RECOVER ( EXIT TOKEN )   COMPILE RETURN  ;                 F83                                                                                                                                                                                                                                                            ( F: ;F  CLASS: ;CLASS )                                        : ?SIZE 0 SWAP FOR R@ 1+ PICK + NEXT ;                          : '? ' DUP @ [ ' AT @ ] LITERAL = IF 2+ C@ ' + THEN ;           : ;F [',] ;M '? TO ON; ; IMMEDIATE                                0 NM: TO CONTEXT ;M 0 0 QUAN MHP , ,                          : F: HEADER COMPILE [ 9 FRM @ , ] USE: TO ON; ;                 : CLASS:  HEADER COMPILE [ ' DOES> 2+  @ , ] >MARK AT MHP 2+ !    ALSO           COMPILE [ AT MHP 4 + @ , ] 2Z,  COMPILE CREATE   AT MHP 2+ @ , [',] DOES> COMPILE TO SELF AT MHP 2+ @ 2+ DUP ,   EXEC DEFINITIONS  COMPILE EXIT MH TO ON; ;                    : ;CLASS  M: AT MHP 2+ @ ! BEGIN AT ON; @ 254 - WHILE ON; DUP ,   MH TO MHP EX'MAC MH DUP MHP - SGN CASE 0 OF RECOVER ENDOF       1 OF DROP MHP ENDOF ENDCASE 254 @ - ON;  ! REPEAT               [',] ;M  ON; TO MH  PREVIOUS DEFINITIONS ;                                                                                                                                                    ( FIRST LOAD SCREEN                                          )  PAGE    ( MACROSES)                                                                                                             .( Hello friends, I am ready!)                                  CR CR CR                                                                                                                                                                                        QUIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( PROBA ARGS( / ARGS                                         )  ( 19 LOAD )                                                                                                                     : P1 LOCALS( / A B C D )                                           [ MAC: GG CR A . B . C . D . ; ]     GG                        1 TO A   2 TO B   3 TO C   4 TO D     GG  GG                   /LOCALS ;                                                                                                                      : PROBA2 (  AT LEAVE)                LOCALS( P  P2 P3 P4 )      CR   P .  P2 .  P3 .  P4 . CR      /LOCALS     ;                                                                                : PP LOCALS( P  ) P  .   P  0 DO . LOOP /LOCALS ;                                                                               FUNC: FAC ( N ) N 2 <  IF 1 RETURN  THEN  N N 1- RECURCE * ;    : PROB 5 FAC ;                                                                                                                  (   /ARGS PUSH  ADROP NPUSH NPOP APUSH            )                                                                             FORTH TO HIDDEN  VARIABLE ASP                                   VARIABLE ABP  FIRST ASP !  : ADROP 0 [TO] WORD DROP ;           : NPUSH ASP AT 2- ! ; : NPOP ASP AT 2+ @ ;                      : APUSH {WORD} 1- DUP IF B>W 2+ + NEGATE ASP @+!                                  ELSE 1+  A" END OF INPUT"    THEN ;           TO FORTH HIDDEN HEX                                             : /ARGS 7 =? ASP @ =?   1 FRM , HERE   forget                      6 ABP @ + ASP !  NPOP TO CONTEXT  NPOP TO CURRENT               NPOP ABP ! NPOP ASP !    ; IMMEDIATE                                                                                                                                                                    -->                                                                                                                                                                                  ( ARGS(  /   /ARGS                                           )  : ARGS( ASP @ NPUSH ABP @ NPUSH CURRENT NPUSH CONTEXT NPUSH        [TO] FORTH HERE NPUSH 0 NPUSH 0 NPUSH ASP @ ABP ! 1 TO RS      BEGIN {WORD}  CASE 1 OF ADROP ENDOF  2901 OF ADROP ENDOF         2F01 OF ADROP 1+ ENDOF 2 SWAP ENDCASE [ DECIMAL  ]  ?DUP       WHILE 1 = IF AT RS IF RS 1- TO RS ABP @ DUP TO RS                 @ DUP RS TO !  ELSE 1 A" TOO MANY"  THEN  ELSE                  ABP @ AT 1- 2* 10 APUSH TO HERE HEADER 2 FRM W, W, W, DROP      C, ABP @ 2+ 2+ @ TO HERE  [',] IMMEDIATE THEN                 REPEAT 0 FRM ,  RS IF ABP @ @ NEGATE , ELSE                         ABP @ TO @ OVER NEGATE C, - C, THEN                             ABP @ 8 + @ TO CURRENT ASP @ 7 ; IMMEDIATE                                                                                F83                                                                                                                                                                                             ( MYSELF HANOJ-II )                                             ( VECTOR MYSELF)                                                                                                                : HANOJ TO MYSELF                                                         ARGS( S_PILON T_PILON D_PILON DISKS )                   ( S_PILON .  T_PILON . D_PILON . DISKS .    )                     AT DISKS AT 1-  (  DISKS--)                                     IF                                                                   S_PILON D_PILON T_PILON DISKS  MYSELF                           S_PILON T_PILON D_PILON 1      MYSELF                           T_PILON S_PILON D_PILON DISKS  MYSELF                      ELSE                                                                 CR ." Move Disk From Pilon  " S_PILON .                                  ."   To Pilon  "     D_PILON .                    THEN  /ARGS ;  ( ' HANOJ TO MYSELF  )                                                                                       ( ARGS /ARGS  ?END                                            ) FORTH TO HIDDEN  VALUE ABP FIRST <STACK ASP TO FORTH HIDDEN HEX : /ARGS 7 =?  ABP =?   1 FRM , HERE   forget  ABP AT ASP !         ASP TO ABP ASP TO CONTEXT  ASP TO CURRENT  ; IMMEDIATE       : ?END >IN PUSH BLWORD COUNT 1-  IF DROP -1 ELSE C@ THEN          SWAP COUNT ROT SCAN 1+ DUP  IF RDROP ELSE POP TO >IN THEN ;   : ARGS( CONTEXT TO ASP  CURRENT TO ASP  [TO] FORTH  ABP TO ASP    AT ASP @ TO ABP  0 TO ASP  0 TO ASP  1 TO RS  HERE TO ASP       BEGIN 0" /)" ?END DUP 2 < ( 0 WORDS  1 / )                      WHILE IF AT RS IF RS 1- TO RS ABP 2- DUP @                       SWAP 2- ! ELSE 1 A" / >1 ?"  THEN ELSE  ABP 2- 1-!@ 2*          HERE C@ 12 + NEGATE AT ASP @+! TO HERE HEADER 2 FRM W, W, W,    DROP  C, ABP 6 - @ TO HERE   [',] IMMEDIATE THEN               REPEAT DROP 0 FRM ,  ABP 2-                                     RS IF @ NEGATE , ELSE  2- 2@ DUP NEGATE C, SWAP - C, THEN       ABP 2+ @ TO CURRENT ABP 7 ; IMMEDIATE    F83                  (  FIBONACHI                                                 )  ( VECTOR FIBI   )                                               ( : FIB TO MYSELF ARGS PAR )  PAR 2 < IF PAR ELSE                 PAR 1- MYSELF   PAR 2- MYSELF  + THEN  /ARGS ;                ( ' FIB TO FIBI   )                                             : FIB2 -1 1 ARGS( N T1 T2 ) N 2+  BEGIN  T2 T1 OVER + DUP        TO T1 + TO T2  2- DUP 2 < UNTIL IF T2 ELSE T1 THEN  /ARGS ;                                                                                                                                    : PROBA 0 DO CR I . I FIB . LOOP ;                                                                                                                                                                                                                                                                                                                                                                                                                              ( INDEX                                                       ) F83                                                             : INDEX 1+ SWAP DO CR I BLOCK I .LINE LOOP ;                    : KEYSCAN BEGIN KEY CR DUP 7 .R DUP B>W  4 .R   DUP HI 4 .R        SPACE B>W DUP EMIT   CTRL M = UNTIL ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( MACRO DEFINITIONS ENABLED                                  )  TO FORTH                                                        : COPY C" | EMIT SWAP . . ; 1024 CONSTANT 1K                    : MLOAD ARGS( ADDR ) 1+ SWAP  ( STARTBLK ENDBLK ADDRESS )         DO I BLOCK 1K AT ADDR @+! 1K CMOVE LOOP /ARGS ;               : MSAVE ARGS( ADDR ) 1+ SWAP                                      DO 1K AT ADDR @+! I BLOCK 1K CMOVE UPDATE LOOP /ARGS ;        : COPYBLK ARGS( FROMBLK ENDBLK TOBLK / DISP CNT )                  TOBLK 1+ FROMBLK - TO CNT  FROMBLK TOBLK - TO DISP              DISP 0< IF CNT FOR FROMBLK I' + TOBLK I' + COPY NEXT              ELSE CNT 0 DO FROMBLK I + TOBLK I + COPY LOOP THEN           /ARGS ;                                                                                                                                                                                                                                                                                                                       (   /ARGS PUSH  ADROP NPUSH NPOP APUSH            )             31 LOAD   ( ?END)  FORTH TO HIDDEN  VALUE ABP                              FIRST   <STACK ASP                                   ( : ADROP 0 [TO] WORD DROP ;                                    : APUSH {WORD} 1- DUP IF B>W 2+ + NEGATE ASP @+!                                  ELSE 1+  A" END OF INPUT"    THEN ;   )       TO FORTH HIDDEN HEX                                             : /ARGS 7 =?  ABP =?   1 FRM , HERE   forget  ABP AT ASP !         ASP TO ABP ASP TO CONTEXT  ASP TO CURRENT  ; IMMEDIATE                                                                                                                                                  -->                                                                                                                                                                                                                                                                                                                  ( ARGS(  /   /ARGS     -1 0  0 W  1 /   2 ....               )  : ARGS( CONTEXT TO ASP  CURRENT TO ASP  [TO] FORTH  ABP TO ASP    AT ASP @ TO ABP  0 TO ASP  0 TO ASP  1 TO RS  HERE TO ASP       BEGIN 0" /)" ?END DUP 2 < ( 0 WORDS  1 / )                      WHILE IF AT RS IF RS 1- TO RS ABP 2- DUP @                       SWAP 2- ! ELSE 1 A" />1 ?"  THEN ELSE  ABP 2- 1-!@ 2*           HERE C@ 12 + NEGATE AT ASP @+! TO HERE HEADER 2 FRM W, W, W,    DROP  C, ABP 6 - @ TO HERE   [',] IMMEDIATE THEN               REPEAT DROP 0 FRM ,  ABP 2-                                     RS IF @ NEGATE , ELSE  2- 2@ DUP NEGATE C, SWAP - C, THEN       ABP 2+ @ TO CURRENT ABP 7 ; IMMEDIATE    F83                                                                                                                                                                                                                                                                                                                                                  ( ?END DELIMITTER                               HEX           ) ( : ?END >IN PUSH BLWORD POP TO >IN COUNT 1-                       IF 2DROP 0 EXIT ELSE C@ DUP 0= IF 2DROP -1 EXIT THEN            SWAP COUNT FOR 2DUP C@ = IF BLWORD 2DROP 0 LEAVE THEN                       1+ NEXT  IF DROP 0 THEN ;)                       : ?END >IN PUSH BLWORD COUNT 1-  IF DROP -1 ELSE C@ THEN          SWAP COUNT ROT SCAN 1+ DUP  IF RDROP ELSE POP TO >IN THEN ;   ( : 0"! 0 HERE 1- C! ; IMMEDIATE                                                                                                : CONST( 1- NEGATE   FOR 0" /"                                               ?END IF LEAVE THEN R@ NEGATE CONSTANT NEXT ;       9 CONST( R/M,R  A,IM  SEG B1 WR BR RG BJ STR NN              )                                                                                                                                                                                                                                                                  ( ARGS /ARGS  ?END                                            ) F83 : CONCUR CONTEXT CURRENT TO CONTEXT TO CURRENT ; IMMEDIATE  : 2BACK AT HERE 2-! ; IMMEDIATE   TO HIDDEN  66 LOAD 33 LOAD    : LOC, HEADER DUP 9 < IF COMPILE [ ' ?, 2+ @ 3 + , 7 FRM @ ]    LITERAL SWAP                                                       AT 2* - , ELSE 2 FRM 3 NW, 2* NEGATE C, IMMEDIATE THEN ;        CONCUR : /ARGS ?CSP 1 FRM , MAC! ; IMMEDIATE  : ?END >IN       PUSH BLWORD COUNT 1-  IF DROP -1 ELSE C@ THEN  SWAP COUNT       ROT SCAN 1+ DUP  IF RDROP ELSE POP TO >IN THEN ; CONCUR       : (ARGS MAC@ CSP! ['] /ARGS TO ON;   0 1 0 0 4 LOCALS/            BEGIN 0" /)" ?END DUP 2 < ( 0 WRD 1 /)                          WHILE IF L2@ IF 0 L2! ELSE 1 A" / >1 ?" THEN ELSE  L1@ 1+ DUP     L1! ['] LOC, EX'MAC L2@ IF L3 ELSE L4 THEN 1+!  THEN          REPEAT DROP  L3@ L4@ PACK  /LOCALS  ; CONCUR   66 LOAD        : LOCALS( (ARGS 0 FRM , , ; IMMEDIATE                           : PROC : ['] ( ' =? 2BACK (ARGS 5 FRM @ , , ;  F83              ( USE MACRO LOCALS                                            ) MAC: CADR 7 FRM @ SWAP 8 * -; MAC: SADR CADR 2+ , ];            MAC: LOC/ [ 6 FRM , ];        MAC: /LOC [ 1 FRM , ];            MAC: LADR CADR , ];           MAC: ^ADR CADR 4 + , ];           MAC: L1@ [ 1 LADR; MAC: L1! [ 1 SADR; MAC: L1 [ 1 ^ADR;         MAC: L2@ [ 2 LADR; MAC: L2! [ 2 SADR; MAC: L2 [ 2 ^ADR;         MAC: L3@ [ 3 LADR; MAC: L3! [ 3 SADR; MAC: L3 [ 3 ^ADR;         MAC: L4@ [ 4 LADR; MAC: L4! [ 4 SADR; MAC: L4 [ 4 ^ADR;         MAC: L5@ [ 5 LADR; MAC: L5! [ 5 SADR; MAC: L5 [ 5 ^ADR;         MAC: L6@ [ 6 LADR; MAC: L6! [ 6 SADR; MAC: L6 [ 6 ^ADR;         MAC: L7@ [ 7 LADR; MAC: L7! [ 7 SADR; MAC: L7 [ 7 ^ADR;         MAC: L8@ [ 8 LADR; MAC: L8! [ 8 SADR; MAC: L8 [ 8 ^ADR;                                                                                                                                                                                                                                                                         ( TEST MACRO LOCALS                                           )                                                                 66 LOAD  33 LOAD                                                : TESTM 3 2 PACK LOCALS/                                             CR CR L1@ . L2@ . L3@ . L4@ . L5@ .                                                                                             1 L1! 2 L2! 3 L3! 4 L4! 5 L5!                                   CR CR L1@ . L2@ . L3@ . L4@ . L5@ .                                                                                             10 L1 !  20 L2 ! 30 L3 ! 40 L4 ! 50 L5 !                        CR CR L1@  .  L2@ .  L3@ .  L4@ .  L5@ .                        CR CR L1 @ . L2 @ . L3 @ . L4 @ . L5 @ .                            /LOCALS                                                ;                                                               66 LOAD                                                                                                                         ( TEST LOCALS( PROC                                          )                                                                  FUNC: FAC ( N )  N 2 < IF 1 RETURN THEN N N 1- RECURCE * ;                                                                      FUNC: FIB ( N ) N 2 < IF N RETURN THEN N 2- RECURCE                  N 1- RECURCE + ;                                                                                                                                                                           FUNC: HANOJ ( P1 P2 P3 N ) AT N 1-!@ IF                               P1 P3 P2 N RECURCE                                              P1 P2 P3 1 RECURCE                                              P2 P1 P3 N RECURCE ELSE CR ." FROM "                        P1 .  ." PILON TO " P3 . ." PILON" THEN  ;                                                                                                                                                                                                                    ( 2MAKER 3MAKER TEST    NANO COMPILING WORDS                )   (                                                               : 2CREATE CREATE , , ;  : 2HEADER HEADER W, W, ;                : 2MAKER 2CREATE DOES> 2HEADER TO RS ;                          : 3MAKER 2CREATE , DOES> 2HEADER W, TO RS ;                     0 NM: ;M  1 NM: ! ;M  2 NM: @ ;M                                3MAKER QUAN ] , ;M                                              )                                                               0 NM: ;M  1 NM: ! ;M  2 NM: PERFORM ;M                          3MAKER VECT ] , ;M                                                                                                              : PROBA  [ LOAD 33 ] 4 LOC/ L1@ L4@ * L2@ + L4@ * L3@ + /LOC ;  PROC SUM ( A B / A B + ;                                        0 1 NM: LST+ ;M   0 NM: AT CURRENT N>C  OVER LNKL TO 0 ;M         HEADER RECURCE , , , IMMEDIATE  )                                                                                             ( TASKS TEST                                                  ) : MULTI ['] (PAUSE TO PAUSE ; : SINGLE ['] NOOP TO PAUSE ;      : WAIT FOR PAUSE NEXT ; : WAIT2 FOR R@ WAIT NEXT ;              FUNC: FTASK ( XX YY NN SS )  BEGIN  XX YY GOTOXY NN DUP H. SS +  TO NN  700 WAIT  AGAIN ;   RECOVER ( NEVER EXITS HERE )           ' (PAUSE  2+ @ HEADER WAKE ,    38 LOAD                         OPER TSTART                                                  : .TASK DUP OPER = IF DROP ." OPER " EXIT THEN 2- ?ID. ;        : .TE DUP H. DUP .TASK WCOUNT ?ID. WCOUNT .TASK @ .TASK ;       : TLIST 0 OPER DUP LOCALS( CNT TS TP )  BEGIN CR                  CNT 5 .R SPACE TP .TE TP 2+ @ DUP TO TP TS =  AT CNT 1+!        UNTIL CR CNT  5 .R ."  TASKS" /LOCALS ;                       80 180 TASK T1       70 03 1000 1 ' FTASK 5 T1 TINIT            80 180 TASK T2       70 05 -1  -1 ' FTASK 5 T2 TINIT            CR T1 +TASK  TLIST  CR T2 +TASK  TLIST                                                                                          ( CATCH THROW POINT                                           ) -128 VALUE OPER    LIKE (BR STOPPED                             ( CATCH SP >R  HDR >R  RP TO HDR  EXEC                                  HDR TO RP  R> TO HDR RDROP      0 ;                     : THROW ?DUP IF  HDR >R  RS TO HDR  RS  SWAP  TO RS                 TO SP DROP RS THEN ; ) : 2+D 2+ SWAP 2+ SWAP ;              : TSTART LIT WAKE SWAP! ;  : TSTOP LIT STOPPED SWAP! ;          : TINS ( T2 T1 T3 ) OVER 2+D 2+D VSWAP 2+D VSWAP ;              : TASK CREATE >MARK DUP TSTOP DUP , , >MARK >MARK DROP >MARK     LOCALS( RN DN ^1 ^2 ) 1K 16 * NEGATE , 10 , 8 ORIGIN+ 257 @ 2/  8 - NW, DN CLARY HERE DUP ^1 2! RN CLARY HERE ^2 ! /LOCALS ;   FUNC: ?TASK ( T / TP )                                            OPER  BEGIN 2+ @ DUP TO TP OPER - WHILE                           TP T = IF T RETURN THEN TP REPEAT 0 ;  -->                                                                                                                                                  (  TINIT ( P1 P2 .. PN N / TASK TFUNC -)                        ( ON WAKE  HERE TO START  |) CREATE INITP                          ]  S0 WCOUNT FLD@ F83 EXEC [                                                                                                 FUNC: -TASK ( T ) T ?TASK 0=  T DUP 2+ @ = OR IF RETURN THEN      T DUP 2+ A@ -ROT TINS ;                                       FUNC: +TASK ( T ) T ?TASK IF RETURN THEN                              OPER DUP 2+ @ T SWAP TINS ;                                                                                               FUNC: TINIT ( NP TSK / RSP DSP )   TSK -TASK  TSK TSTOP          TSK 8 + 2@ AT DSP 2! NP 2* TO NP  DSP 2+ NP FLD! NP DSP !       INITP AT RSP 2-!@ ! 0 AT RSP 2-!@ !  0 AT DSP 2-!@              RSP  AT DSP 2-!@ !  DSP TSK 6 + ! ; ( SET DATA STACK SP)                                                                                                                                                                                                       ( assembler              control words   )                      VOCABULARY  ASSEMBLER  TO ASSEMBLER                             HEX 0 VALUE DISP 0 QUAN FLAGS   ( xxxxxxccOMIAGSDW )            : ASM-RESET 2 TO FLAGS  0 TO DISP ;  : IF, C, HERE 0 C, ;       : WHILE, IF, SWAP ; : THEN, ( a -) HERE OVER 1+ - SWAP C!  ;    : ELSE, ( a - a') EB ( ie intra-seg dir short jmp) C,             HERE OVER - SWAP C!   HERE  0 C, ;                            : BEGIN, ( - a) HERE ; : UNTIL, ( a opc -) C, HERE 1+  -  C, ;  : ASM ASM-RESET CONTEXT [',] ASSEMBLER CSP! ;                   : END-CODE ?CSP TO CONTEXT ;                                    TO FORTH ASSEMBLER                                              : CODE HEAD HERE 2+ , ASM ;                                     : ;CODE  COMPILE ;code  [',] [ ASM ; IMMEDIATE                  TO ASSEMBLER FORTH                                                                                                              DECIMAL  41 60 THRU     F83 96 LOAD                             HEX  ( relative jumps   )                                       | : opc ( opcode -) ( - opcode) CREATE C, DOES> C@ ;                                                                            73 opc CS,  75 opc 0=,  79 opc 0<,  73 opc U<,  E3 opc CXNZ,    7D opc <,   7E opc >,   76 opc U>,  ( 71 opc OV, )              ( the rest can be made by following above with NOT, )           : LOOP,   ( a -) E2 UNTIL, ;                                    : LOOPZ,  ( a -) E1 UNTIL, ;                                    : LOOPNZ, ( a -) E0 UNTIL, ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    HEX  ( bit-flags and reg seg & r/m defining words )             ( VARIABLE DISP   VARIABLE FLAGS  ( xxxxxxccOMIAGSDW )          ( M=r/m; cc=reg count; I=immediate; A=accumulator; G=seg;)      ( S=imm.size; D=direction;  W=word or byte; O=disp only  )      | : F-SET ( mask -) FLAGS OR TO FLAGS ;                         | : F-CLR ( mask -) -1 XOR FLAGS AND TO FLAGS ;                 | : F-GET ( mask -) FLAGS AND ;                                 | : F-FLIP ( mask - ) FLAGS XOR TO FLAGS ;                      | : <reg> ( a -n) DUP 1+ C@ DUP 1 AND 1 XOR 2* 2* OR F-SET C@ ; | : reg ( 000a000w00rrr000 -) ( - 0000000000rrr000)  CREATE ,         DOES> <reg> 100 AT FLAGS +! ( count regs)  2 F-FLIP  ;    | : seg ( n -) ( -n) CREATE ,  DOES> <reg> 2 F-SET ;            | : r/m ( n -) ( disp - n) CREATE ,                                   DOES> <reg>  2 F-CLR ( D) SWAP TO DISP ;                  ( default D is on, r/m clears it, reg flips it, seg sets it)    ( D=0 when r/m field is destination )                           HEX ( R/M & REG are 16bit constants, but reg keeps count )      4000 r/m [BX+SI] 4001 r/m [BX+DI] 4002 r/m [BP+SI]              4003 r/m [BP+DI] 4004 r/m [SI]    4005 r/m [DI]                 4006 r/m [BP]    4007 r/m [BX]    C006 r/m )   ( chg this?)                                                                     ( bits 3-5=reg, bit 8=W, bit 9=D flg, bit 12=ACC flg )          1100 reg AX  0108 reg CX  0110 reg DX  0118 reg BX              0120 reg SP  0128 reg BP  0130 reg SI  0138 reg DI              1000 reg AL  0008 reg CL  0010 reg DL  0018 reg BL              0020 reg AH  0028 reg CH  0030 reg DH  0038 reg BH              0900 seg ES  0908 seg CS  0910 seg SS  0918 seg DS              | CREATE F$  4457 , 4753 , 4941 , 4F4D ,                        : .F ( -) FLAGS 8 FOR  R@ 2^ F-GET IF F$ R@ + C@                  ELSE 20 THEN EMIT NEXT  100 / 3 U.R ."  regs " ;                                                                                                                                              HEX ( REG>R/M  #,  orW  11mod  01mod  10mod  ,DISP BYTE )       ( | : R>M ( reg -r/m( 2/ 2/ 2/ ;)   | : 1REG? 100 F-GET ;       | : SHORT? ( n - f)  -80 80 WITHIN ;                              : #, ( n1 - n1) 20 OVER SHORT? 04 AND OR F-SET  ;             | : orW ( --opc---   -  --opc--w)  1 F-GET  OR ;                | : orDW ( --opc---  -  --opc-dw)  3 F-GET  OR ;                | : modDISP, ( 2nd - ) 40 F-GET ( ie M)                           IF 80 F-GET ( ie Only) IF C, DISP ,                               ELSE 8 F-GET ( ie G) DISP OR  OVER 7 AND 6 = OR ( ie[BP])       IF DISP SWAP OVER SHORT?                                          IF 40 OR C, C, ELSE 80 OR C,  , THEN                          ELSE ( zero & not seg) C, THEN  THEN ELSE C0 OR C,  THEN ;  | : IMM? ( -f) 20 F-GET  ;  : ACC? ( -f) 10 F-GET ;             | : ,IMM  ( n -) 5 F-GET 4 = IF ( S,-W)  C, ELSE  , THEN ;        : W-PTR ( -)  1 F-SET  ; ( the default is byte )              | : 2REGS? ( -f) 308 F-GET DUP 200 = SWAP 108 = OR ;            ( one byte opcodes with no variables )                          HEX                                                             | : M1 ( n -) ( -)  CREATE C, DOES> C@ C, ASM-RESET ;                                                                           98 M1 CBW,  F8 M1 CLC,  FC M1 CLD,  FA M1 CLI,  F5 M1 CMC,      99 M1 CWD,  CF M1 IRET, 90 M1 NOP,  C3 M1 RET,  CB M1 RETF,     F9 M1 STC,  FD M1 STD,  FB M1 STI,  D7 M1 XLAT,                 F3 M1 REP,  F3 M1 REPZ, F2 M1 REPNZ,                                                                                            9C M1 PUSHF,   9D M1 POPF,                                                                                                      26 M1 ES:   2E M1 CS:   36 M1 SS:   3E M1 DS:                                                                                                                                                                                                                                                                                   ( 2 operand instructions such as ADD,  )                        HEX                                                             | : M2 ( n -) ( various - ) CREATE ,                              DOES> @ PUSH  IMM?                                               IF ACC? IF     DROP  POP orW 4 OR C,                                    ELSE   1REG? IF R>M THEN  80 orW C,                                    POP 38 AND OR  modDISP,                                  THEN  ,IMM                                              ELSE  2REGS?  IF SWAP R>M THEN                                        POP orDW C, OR modDISP,                                   THEN  ASM-RESET  ;                                                                                                                                                                                                                                                                                                                                                                           HEX  ( use M2 to define ADD, like instructions )                                                                                10 M2 ADC,  00 M2 ADD,  20 M2 AND,  38 M2 CMP,   08 M2 OR,      18 M2 SBB,  28 M2 SUB,  30 M2 XOR,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              HEX  ( MOV,  )                                                  : MOV, IMM?                                                       IF  1REG?  IF   R>M B0 OR 1 F-GET AT 2*  OR C,                             ELSE C6 orW C, modDISP,                                         THEN  ,IMM                                           ELSE 90 F-GET 90 =                                              IF   2DROP A0 2 F-FLIP orDW C, DISP @ ,                         ELSE  2REGS? IF   2 F-GET ( ie D) IF SWAP THEN  R>M  THEN        8 F-GET ( ie G) IF 1 F-CLR 8C ELSE 88 THEN  orDW C,             OR  modDISP,                                                   THEN THEN  ASM-RESET ;                                                                                                                                                                                                                                                                                                                                                                        ( one byte instr w/ W  - the string instructions )              HEX                                                             | : M3 ( n -) ( reg -) CREATE C, DOES> C@                              orW C, DROP ASM-RESET   ;                                                                                                A6 M3 CMPS,  AC M3 LODS,  A4 M3 MOVS,                           AE M3 SCAS,  AA M3 STOS,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( mul, div, etc.    xxxxxxxW  mdNNNr/m )                        HEX                                                             | : M4 ( n -) ( -) CREATE ,                                         DOES> @ F6 orW C, SWAP 1REG? IF R>M THEN OR  modDISP,             ASM-RESET  ;                                                                                                              30 M4 DIV,  38 M4 IDIV,  28 M4 IMUL,                            20 M4 MUL,  18 M4 NEG,   10 M4 COM,                              (  NOT,  is the the Intel name for my  COM,  but it                would conflict w/ my flag inverter which I call  NOT,           ** be careful ** )                                                                                                                                                                                                                                                                                                                                                                          ( M5 for LDS, LEA, & LES, )                                     HEX                                                             | : M5 ( n -) ( -) CREATE , DOES> @ ,  OR modDISP, ASM-RESET  ;                                                                 C5 M5 LDS,  8D M5 LEA,  C4 M5 LES,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( M6 for the rotate & shift instructions )                      HEX                                                             | : M6 ( n -) ( n# r/m | r/m    - ) CREATE C,                      DOES> C@ IMM? 10 U/  2 XOR  1 F-GET ( ie W) OR D0 OR C,          1REG? IF SWAP R>M THEN OR modDISP,  IMM? IF DROP THEN                 ASM-RESET  ;                                                                                                          10 M6 RCL,   0 M6 ROL,   20 M6 SHL,   18 M6 RCR,                08 M6 ROR,  38 M6 SAR,   28 M6 SHR,                                                                                             ( examples to shift right 1 bit )                               ( 1 #, SI SHR,   1 #,  W-PTR  17 [BX] SHR,   1 #, AL SHR,  )                                                                    ( examples to shift right the # of bits in CL )                 ( SI SHR,  AL SHR,  1300 rt-par SHR,  3752 W-PTR rt-par SHR, )                                                                  ( INC, & DEC, instructions )                                    HEX                                                             | : M7 ( n -) ( r1 | r/m  -) CREATE C,                             DOES> C@ SWAP  1REG? IF  ( opc r1) R>M THEN                           1REG? 100 =  1 F-GET AND  ( ie it's a 2-byte register)          IF  ( opc rX)  OR 40 OR C,                                      ELSE  ( opc mem | opc rH | opc rL )                                FE orW C,  OR modDISP,                                       THEN  ASM-RESET  ;                                                                                                     08 M7 DEC,   00 M7 INC,                                                                                                                                                                                                                                                                                                                                                                         ( PUSH, & POP, instructions )                                   HEX                                                             | : M8 ( n -) ( reg | seg | r/m  -)  CREATE ,                      DOES> @  8 F-GET                                                  IF  ( seg opc ) 16/ 1 AND 1 XOR 6 OR OR C,                      ELSE 1REG?                                                      IF  ( reg opc ) 2/ 8 AND 8 XOR 50 OR SWAP R>M OR C,             ELSE ( r/m opc) DUP 100 U/ FF AND C,  OR modDISP,               THEN  THEN  ASM-RESET ;                                                                                                    FF30 M8 PUSH,  8F00 M8 POP,                                                                                                                                                                                                                                                                                                                                                                     ( IN, OUT, instr )                                              HEX                                                             | : M9 ( n -) ( n# r1 | r1  -) CREATE C,                          DOES> C@  orW NIP                                                  IMM? IF ( n# opc)  C, ( n#) ELSE ( opc) 8 OR THEN C,            ASM-RESET ;                                                                                                                E4 M9 IN,   E6 M9 OUT,                                                                                                          ( use   port #, AL IN,  or  port #, AX IN,  for 8 bit ports )   ( or    AL IN,  or  AX IN,   for port in the DX register  )     ( do not use AL DX IN, - the DX is implied                )                                                                                                                                                                                                                                                                     ( XCHG )                                                        HEX                                                             : XCHG,  ( reg mem | mem reg | reg1 reg2   -)                     211 F-GET 211 = ( 2 regs & one is AX)                           IF  ?DUP IF NIP THEN ( r1 ) R>M  90 OR C,                       ELSE  2REGS? IF  R>M  THEN  OR  86 orW C, modDISP,              THEN  ASM-RESET ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( TEST, instruction  - almost like ADD, etc. )                  HEX                                                             : TEST,  ( various - )                                             IMM?                                                            IF ACC? IF     DROP  A8 orW ( 4 OR) C,                                  ELSE   1REG? IF R>M THEN  F6 orW C,                                    ( OR)  modDISP,                                          THEN  ,IMM                                              ELSE  2REGS?  IF SWAP R>M THEN                                        84 orW C, OR modDISP,                                     THEN  ASM-RESET  ;                                                                                                                                                                                                                                                                                                                                                                           ( INT,  & segment override instructions )                       HEX                                                             : INT, ( #n -) CD C, C, ASM-RESET ; ( eg 21 #, INT, )                                                                           (                                                    : ES: ( -)  26 C, ;                                             : CS: ( -)  2E C, ;                                             : SS: ( -)  36 C, ;                                             : DS: ( -)  3E C, ;                                             )                                                                                                                                                                                                                                                                                                                                                                                                                                                               ( CALL, instr  )                                                HEX                                                             : CALL, ( various -) IMM?        ( intra-seg direct )             IF  ( n#)  HERE 3 + - ( make it relative)                           E8 C, , ( eg 2389 #, CALL, calls addr $2389)                ELSE                                                                ( mem | reg  -)  1REG?  IF R>M  THEN                            FF C,  10 OR modDISP, ( eg 0 [BX] CALL, or DX CALL, )       THEN  ASM-RESET ;         ( this is intra-seg indirect )                                                                      ( I am not implementing the inter-seg direct                      or indirect versions )                                                                                                                                                                                                                                                                                                        ( JMP, instr  &  NXT, )                                         HEX                                                             : JMP, ( various -) 140 F-GET ( ie R or M  intra-seg indirect )    IF ( mem | reg  -)  1REG?  IF R>M  THEN                            FF C,  20 OR modDISP, ( eg 0 [BX] JMP, DX JMP, )                                      ( or 3759 rt-paren JMP,  )             ELSE  ( a) HERE 3 + -                                            ( relative) DUP SHORT? IF 1+ EB C, C, ELSE  E9 C,  ,  THEN      ( disp is added to IP, so this is a relative jump )          THEN  ASM-RESET ;                                              : LJMP, ( a -)  E9 C,  HERE 2 + - ,  ;  ( lay down 3byte jump)  ( I am not implementing the inter-seg direct or indir. versions)                                                                : NEXT, ( -) [ ' ORIGIN+ 2+ 2+ @ ] LITERAL LJMP, ;              : SWITCH,  SP BP XCHG, ;                                        FORTH                                                           : ?CSP SP CSP - A" SP CHG!" TO CSP ; : LPOS BLOCK SWAP 1L * + ; : LMOV 1L * -ROT LPOS UPDATE 2SWAP LPOS SWAP ROT CMOVE ;        : GL >R 2DUP R@ SCR 1 LMOV SCR LIST SWAP 1+ DUP 16 - 0=           IF DROP 1+ 0 THEN SWAP R> 1+ DUP 16 - 0= IF DROP 0 THEN ;                                                                     : INSBLK 1+ OVER - FOR DUP R@ + DUP 1+ COPY NEXT                    BLOCK  1K  BLANK UPDATE FLUSH ;                             : S" C" " WORD DUP C@ 1+ ALLOT ;                                : BLONK BLOCK ( N - ) DUP 1K + SWAP  DO                            I C@ bl < IF bl I C! THEN LOOP UPDATE FLUSH ;                : WDS FOR CR WW NEXT ;  : SEE ' 2+  15 WDS ;                    : \ BLK 1 -1 WITHIN IF >IN 63 OR 1+ TO >IN                         ELSE -1 WORD DROP THEN ; IMMEDIATE                           : INDEX 1+ SWAP DO CR I BLOCK I .LINE LOOP ;                    : KEYSCAN BEGIN KEY CR DUP 7 .R DUP B>W  4 .R   DUP HI 4 .R        SPACE B>W DUP EMIT   CTRL M = UNTIL ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( PROBA                                                       )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -MAC F83                 MAC: >RESOLVE TO >MARK;                MAC: WCOUNT TO COUNT;    MAC: DABS TO ABS;                      MAC: SCIND TO SCLST;     MAC: SCANW TO SCANB;                   MAC: WBLK TO NBLK;       MAC: VBLK AT NBLK;                     MAC: OPEN TO FOPEN;      MAC: FCLOSE TO CLOSE;                  MAC: ?EXEC TO EXEC;      MAC: PERFORM AT EXEC;                  MAC: vUSER AT U0;        MAC: BLWORD TO WORD;                   MAC: C@W TO C@;          MAC: HOLD TO HLD;                      MAC: BYE AT EXIT;        MAC: BRANCH (BR;                       MAC: ?BRANCH TO (BR;     MAC: (OF AT (BR;                       MAC: DCOMPILE TO D,;     MAC: DLIT AT D,;                       MAC: COMPILE TO ,;       MAC: LIT AT ,;                         MAC: BCOMPILE TO C,;     MAC: BLIT AT C,;                       MAC: RP! TO RP;                                                                                                          -->                                                                    MAC: CNTDO AT (DO;       MAC: 4TH> TO LEAVE;                    MAC: BREAK. AT LEAVE;    MAC: CMOVE> TO CMOVE;                  MAC: MOVE AT CMOVE;      MAC: DNEGATE TO NEGATE;                MAC: 2DROP TO DROP;      MAC: RDROP AT DROP;                    MAC: 2DUP TO DUP;        MAC: TUCK AT DUP;                      MAC: ?KEY TO EMIT;       MAC: J TO I;                           MAC: K AT I;             MAC: HI TO B>W;                        MAC: 2OVER TO OVER;      MAC: PICK AT OVER;                     MAC: D+ TO +;            MAC: +! AT +;                          MAC: -ROT TO ROT;        MAC: ROLL AT ROT;                      MAC: 2! TO !;            MAC: 2@ TO @;                          MAC: A! AT !;            MAC: A@ AT @;                          MAC: 2SWAP TO SWAP;      MAC: FLIP ><;                          MAC: 1-! TO 1-;          MAC: 1-!@ AT 1-;                       MAC: 2-! TO 2-;          MAC: 2-!@ AT 2-;                -->                                                                    MAC: 1+! TO 1+;             MAC: @1+! AT 1+;                    MAC: 2+! TO 2+;             MAC: @2+! AT 2+;                    MAC: PC2+ TO PC1+;          MAC: (" AT PC1+;                    MAC: XOR! TO XOR;           MAC: 0MIN TO MIN;                   MAC: PACK TO UNPACK;        MAC: @UNPACK AT UNPACK;             MAC: UF2 TO U-FUNC;         MAC: UF4 AT U-FUNC;                 MAC: D- TO -;               MAC: CBAX TUCK * ROT + * +;         MAC: ROL4 4 ROLL;           MAC: ABCX ROL4 OVER * ROL4 + * +;   MAC: HEAD HEADER;           MAC: 2^ TO SHIFT;                   MAC: | 1 TO HEADER;         MAC: HEADERS 0 TO HEADER;           MAC: -HEADERS -1 TO HEADER; MAC: ON TO -1;                      MAC: OFF TO 0;              MAC: AT-XY GOTOXY;                  MAC: NOT, 1 XOR;            MAC: R>M AT 2/;                     MAC: NOT -1 XOR;                            -->                                                                                                                                                 MAC: FLD! TO C!;               MAC: FLD@ AT C!;                 MAC: 0. 0 0;                   MAC: -1. -1 -1;                  MAC: LATEST AT CURRENT N>C;    MAC: RUN LATEST EXEC;            MAC: SMUDGE AT IMMEDIATE;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( ;M NM: M: MAKER QUAN <STACK STACK> ON; USE: ; RECURCE )       TO FORTH : RECOVER -2 ALLOT ;  : ;M [TO] ; ; IMMEDIATE          : M: HERE AT , [ ' WORD @ 1+ DUP @ + 2+ , ] [AT] DOES> ] ;      : NM: NEGATE HERE SWAP [TO] DOES> HERE 2- AT + ] ;              : USE: HERE [TO] : ; : LIKE, HEADER NW, ;                       : MAKER CREATE DUP C, FOR , NEXT DOES> COUNT LIKE, , ;            ' IOV @   ' SCRH DUP 2+ @ 1-   SWAP @ 1-   3 MAKER QUAN         ' IOV @ 1 NM: AT 2- ! ;M 2 NM: AT 2+ @ ;M  3 MAKER <STACK       ' IOV @ 1 NM: AT 2+ ! ;M 2 NM: AT 2- @ ;M  3 MAKER STACK>     0 QUAN RECURCE IMMEDIATE 2 NM: TO RS HERE AT RS @ , RS ! ;M     ' RECURCE ! 1 NM: TO RS AT CURRENT N>C  BEGIN AT RS @ ?DUP       WHILE DUP @ AT RS !  OVER SWAP !  REPEAT RS DROP DROP ;M       ' RECURCE 2+ ! 256 <STACK ON;   : ; [',] ; [TO] RECURCE BEGIN    AT ON; @ 256 < WHILE  ON; EXEC REPEAT  ; IMMEDIATE             : ON> ON; TO RS ; : ;CONT> RS TO ON; AT , ON> TO ON; ;                                                                          ( SELF. 7890123456789012345678901234567890123456789012345678901)FORGET SELF.                                                    : SELF. CREATE DOES> 2- C>N DROP ID. ;                                                                                          : HANOJ (  TO MYSELF    )                                                (  S_PILON 0..2   D_PILON 0..2    DISKS 1..20 )          1- ?DUP IF TO RS  TO DUP OVER OR 3 XOR AT RS  RECURCE                          TO DUP 1                  RECURCE                          SWAP OVER OR 3 XOR SWAP  RS    RECURCE                        ELSE CR ." Move Disk From Pilon  " SWAP 1+ .                            ."   To Pilon  " 1+ .   THEN   ;                                                                              CLS 0 2 3 HANOJ                                                                                                                                                                                                                                                 (                                              )                ( MAKEIT ( N 0/ IF CREATE DUP C, ELSE HEADER THEN FOR , NEXT ;) ( ' IOV @  1 NM: 2! ;M  2 NM: 2@ ;M                             : 2QUAN HEADER TO , [ , ] TO , [ , ] TO , [ , ] D, ;   )                                                                        EXIT                                                            ' RECURCE 2+ !                                                  EXIT            : ; [',] ; ;CONT [TO] RECURCE ; IMMEDIATE       : FAC DUP 2 < IF DROP 1 EXIT THEN DUP 1- RECURCE * TRACE ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( MEMORY MAP FORTH                                            ) HIDDEN TO FORTH                                                 ( FORGET MEMORY-MAP    TO FORTH HIDDEN         )                : >-< CR 2DUP - -ROT 7 U.R 7 U.R 7 U.R 2 SPACES ;               : MEMORY-MAP CR  2 SPACES                                         ." START   END    SIZE   DESCRIPTION"                            CR 50 FOR C" - EMIT NEXT                                        HERE 256 >-<  ." CODE & HEAP"                                   S0 SP    >-<  ." DATA STACK"                                    MH R0    >-<  ." MACRO BUFFER"                                  R0 RP    >-<  ." RETURN STACK"                               FIRST AT MS @ >-< ." MACRO STACK"                               LIMIT FIRST >-<  ." BUFFER PULL"                                   SP PAD   >-<  ." FREE SPACE"                                 ;  MEMORY-MAP                                                                                                                   ( FOR NEXT CASE OF ENDOF ENDCASE CLARY QARY WARY              ) (                                                               : CLARY HERE OVER ALLOT SWAP ERASE ;                            : FOR ?C TO , (FOR >MARK 6 ;   IMMEDIATE                        : NEXT ?C 6 =? TO , TO (FOR TO >MARK ; IMMEDIATE  )             : CSP! CSP SP TO CSP ;   : CASE ?C CSP! 4 ;  IMMEDIATE          : OF 4 =? TO , AT (BR >MARK 2 5 ;  IMMEDIATE                    : ENDOF 5 =? [',] ELSE 4 ;     IMMEDIATE                        : ENDCASE 4 =? TO , DROP  BEGIN SP CSP -                          WHILE [',] THEN  REPEAT TO CSP ; IMMEDIATE   TO HIDDEN FORTH  : FSAVE 0 TO BLK 0 TO >IN [AT] MACROS TO 0  HERE 1K + 256        DO I DUP 256 - 1K / BLOCK 1K CMOVE UPDATE 1K +LOOP FLUSH        -USE QUIT ;  : 'INIT  EMPTY-BUFFERS  0" 4TH.SCR"                 1+ TO FOPEN TO SCRH  20 TO BLK  0 DUP TO >IN TO INITW             INTERPRET QUIT ;   ' 'INIT TO INITW                                                                                         ( FOR NEXT CASE OF ENDOF ENDCASE CLARY QARY WARY              )  ONLY  HIDDEN ALSO  FORTH DEFINITIONS HOME                        DECIMAL  74 LOAD       ( FOR , NEXT ...)                      ( DECIMAL  70 LOAD       ( MYSELF ...)                            DECIMAL  76 LOAD       ( NUMOUT , WORDS ...)                    DECIMAL  90 LOAD       ( -HEAD)      -HEAD                      DECIMAL  86 LOAD       ( MACRO  ENGINE)                         DECIMAL  66 LOAD       ( MACRO WORDS)                           DECIMAL  89 LOAD       ( FORGET )                               DECIMAL  12 LOAD       ( STRINGS)                               DECIMAL  15 LOAD       ( DOS CMD)                               DECIMAL  91 LOAD       ( EDITOR)                                DECIMAL  96 LOAD       ( PRUNE - IT DOES! )                     DECIMAL  61 LOAD       ( LMOV , BLONK...)                       DECIMAL  10 LOAD       ( DUMP)                                                                                                ( BARY PAD SPACES <# #> # #S SIGN D# D.R D. .R . U.           )                                                                 : BARY HEADER TO , [ ' ORIGIN+ 2+ @ 2+ 2+ , ] CLARY ;           : PAD HERE 260 + ;                                              : SPACES TO MAX FOR SPACE NEXT ;                                : <# PAD AT HLD ! ;                                             : #> TO DROP HLD PAD OVER - ;                                   : # BASE U/MOD >R  BASE TO U/MOD SWAP ALPHA TO HLD R> ;         : #S BEGIN # TO DUP OR 0= UNTIL ;                               : SIGN 0< IF C" - TO HLD THEN ;                                 : D# DUP >R TO ABS <# #S R> SIGN #> ;                           : D.R >R D# R>  OVER - SPACES TYPE ;                            : D. 0 D.R SPACE ;                                              : .R >R S>D R> D.R ;                                            : . S>D D. ;                                                    : U. 0 D. ;                                            -->      ( U.R UD. .H ? >= CTRL .LINE LIST TRACE WW EQU                ) : U.R  0 SWAP D.R ;  : UD. <# #S #> TYPE SPACE ;                : .H BASE SWAP 0 HEX <# # # # # #> TYPE TO BASE SPACE ;         : 'W DUP H. TO COUNT DUP H. ; : 'S DUP H. DUP ". COUNT + ;      : ? @ . ;    LIKE < >=   0 C,  -1 C, -1 C,                      : CTRL TO WORD 1+ C@ 31 AND [',] LITERAL ; IMMEDIATE            : .LINE 3 .R SPACE 1L TYPE ; : .BLOCK 0 0 GOTOXY CR ." Scr# "      SCR . 16 0 DO CR DUP I .LINE 1L + LOOP DROP ;                : LIST DUP TO SCR  HOME BLOCK .BLOCK ;                          : TRACE ' TR  EXEC -TR ;  IMMEDIATE        ( TRACE WORD)        : WW DUP H. DUP @ DUP H. ?ID. 2+ ;  ( DEBUG ONE ADDRESS)                                                                        : EQU >IN >R -FIND 0= IF                                             R> TO >IN CREATE , [ HERE 2+ TO CSP ] DOES> @ EXIT              ELSE AT DROP  AT , [ CSP , ]                                  OVER @ - A" !=EQU" 2+ ! THEN ;                      -->      ( WORDS                                                       ) : WORDS   CR 10 TO CSP 0 ( COUNTER ) CONTEXT                      BEGIN @  ?DUP                                                   WHILE >R  1+ R@ C@ 31 AND 6 + OUTC + 79 >=                        IF CR CSP ?DUP                                                    IF 1- TO CSP ELSE  10 TO CSP KEY B>W 27 =                         IF ." WORDS LISTED = " 1- . CR QUIT THEN                    THEN  THEN                                                      R> DUP .H DUP ID.  N>C 2-  OUTC 65 <                            IF 13 OUTC OVER MOD    ?DUP 0= IF DUP THEN - SPACES THEN      REPEAT CR ." TOTAL WORDS = " . ;                              : WITHIN OVER - >R - R> U< ;     : ," TO WORD ", ;              LIKE < >   0 C,  0 C, -1 C,                                     LIKE < <=  -1 C, -1 C, 0 C,                                     : U/ U/MOD NIP ; : UMOD U/MOD DROP ;                            : COPY SWAP BLOCK SWAP BLOCK 1K CMOVE UPDATE FLUSH ;            ( WITHIN ," > <= EDITOR POSXY WIPE RELOAD SAVEBLK LB N B ARROW) : WITHIN OVER - TO RS - RS U< ;     : ," TO WORD ", ;           LIKE < >   0 C,  0 C, -1 C,   LIKE < <=  -1 C, -1 C, 0 C,       : U/ U/MOD NIP ; : UMOD U/MOD DROP ;                            : COPY SWAP BLOCK SWAP BLOCK 1K CMOVE UPDATE ;                  VOCABULARY EDITOR TO EDITOR  EDITOR                                                                     VALUE CHG VALUE XY       VALUE LC  VALUE INS  : ~CHANGE 0 TO CHG ; :  CHANGE 1 TO CHG ; : POSXY 1L U/MOD 4 2 TO + GOTOXY ; : RDR PAD .BLOCK ; ( REDRAW) : WIPE PAD 1K BLANK CHANGE RDR ;                                : RLD SCR BLOCK PAD 1K CMOVE ~CHANGE RDR ;                      : SAVEBLK CHG IF PAD SCR BLOCK 1K CMOVE UPDATE ~CHANGE THEN ;   : LB SAVEBLK SCR + TO MAX TO SCR ;                              : N 1 LB RLD ;   : B -1 LB RLD ;  : XY! 1K 1- AND TO XY ;       : L_UP XY 1L - XY! ; : L_DN XY 1L + XY! ;                       : L_END XY 1L 1- OR XY! ;  : L_BEG XY 1L NEGATE AND XY! ;  -->  ( COPY POS^ LINE/ /LINE LDRAW EL INSC DELC OVTC INSL DELL LL  ) : -> XY 1+ XY! ; : <- XY 1- XY! ; : TAB> XY 7 OR 1+ XY! ;       : <TAB XY 1- -8 AND XY! ; : POS^ PAD XY + ; : <_| L_DN L_BEG ;  : LINE/ PAD XY 960 AND + ; : L2 1K  XY - 1L - TO MAX ;          : LDRAW 13 EMIT LINE/ XY 1L / .LINE ;                                                                                           : /LINE PAD XY 63 OR + ;    : P2 POS^ DUP DUP 1L + ;            : EL 1K L2 - 1L MIN BLANK ;                                     : DELL P2 SWAP L2 CMOVE L2 +  EL RDR CHANGE ;                   : OVTC POS^ C! CHANGE ;  : INSL P2 L2 TO CMOVE EL RDR CHANGE ;  : POSC POS^ DUP 1+ ;     : LL /LINE POS^ - ;                    : INSC POSC LL TO CMOVE bl OVTC ;                               : DELC POSC SWAP LL CMOVE bl /LINE C! LDRAW CHANGE ;            : _INS INS 0= TO INS 75 2 GOTOXY INS                               IF ." INS" ELSE ." OVT" THEN ; : BS <- DELC ;       -->                                                                      ( /EDIT L E                                                   ) : /EDIT SAVEBLK FLUSH ; : /ED /EDIT 0 18 GOTOXY QUIT ;          : L 960 XY <= IF 1 LB 0 TO XY THEN                                  XY 1L < IF WIPE THEN <_|                                        0 WORD COUNT 1L MIN LINE/ SWAP CMOVE ;                      CREATE CTRLS   25 C,  CTRL [ C,  CTRL S C,  CTRL E C,  bs C,     CTRL D C, CTRL N C,  CTRL B C,  CTRL L C,  CTRL I C,            CTRL M C, CTRL J C,  CTRL K C,  CTRL W C,  CTRL X C,  80 C,     77 C, 75 C, 72 C, 83 C, 79 C, 71 C, 73 C, 81 C, 82 C, 15 C,    CREATE OPER1 ] /ED   INSL  DELL  BS    DELC  N     B     RLD       TAB>  <_|   <-    ->    WIPE  _INS  L_DN  ->    <-    L_UP      DELC  L_END L_BEG B     N     _INS  <TAB  [  : XKBD TO RS    CTRLS COUNT RS SCAN DUP 1+ IF 2* OPER1 + AT EXEC  0 THEN ;      EDITOR TO FORTH                                                 : E RLD _INS _INS  BEGIN  XY POSXY KEY DUP TO LC B>W   -->                                                                      ( EDITOR                                                      )   IF LC B>W CASE                                                    CTRL [ OF /ED ENDOF     CTRL S OF INSL ENDOF                    CTRL E OF DELL ENDOF        bs OF BS   ENDOF                    CTRL D OF DELC ENDOF    CTRL N OF  N   ENDOF                    CTRL B OF  B   ENDOF    CTRL L OF RLD  ENDOF                    CTRL I OF TAB> ENDOF    CTRL M OF <_|  ENDOF                    CTRL J OF <-   ENDOF    CTRL K OF ->   ENDOF                    CTRL W OF WIPE ENDOF    CTRL X OF _INS ENDOF                          DUP 31 >                                                        IF  INS IF INSC THEN DUP OVTC                                       INS IF LDRAW ELSE DUP EMIT THEN  ->                         THEN                                                                 ENDCASE                                              ELSE LC TO B>W CASE                                                ( DN 20480)  80 OF L_DN  ENDOF              -->          ( EDITOR E                                                    )        ( RT 19712)   77 OF ->    ENDOF                                 ( LFT 19200)  75 OF <-    ENDOF                                 ( UP 18432)   72 OF L_UP  ENDOF                                 ( DEL 21248)  83 OF DELC  ENDOF                                 ( END 20224)  79 OF L_END ENDOF                                 ( HOM 18176)  71 OF L_BEG ENDOF                                 ( PU 18688)   73 OF     B ENDOF                                 ( PD 20736)   81 OF     N ENDOF                                 ( INS 20992)  82 OF  _INS ENDOF                                 ( STB  3840)  15 OF <TAB  ENDOF                                    ENDCASE                                                   THEN                                                          AGAIN ;                                                       : EDIT LIST E ;                                                                                                                 ( MACRO ENGINE                                                ) TO HIDDEN FORTH DECIMAL VALUE MH : SWAPH HERE MH TO HERE TO MH ; VARIABLE MS : MPUSH MS AT 2+ ! ; : MPOP MS AT 2- @ ; VALUE MCH : -MAC R0 DUP MS ! 100 + TO MH 0 [AT] MACROS ! ;                : DO_MAC  CREATE MCH WORD DUP COUNT TO RS                           SWAP AT RS CMOVE RS ALLOT 0 C, DOES> AT DROP                    BLK MPUSH >IN MPUSH 0 TO BLK TIB - TO >IN  TO INTERPRET ;   ' WORD @ 1+ DUP @ + 2+ MS !  ( TRICK)                           TO FORTH HIDDEN    : X AT DROP MS @ R0 -                           IF MPOP TO >IN MPOP TO BLK TO INTERPRET THEN ; IMMEDIATE     HERE TO MH MS @ AT DOES> ] SWAPH CURRENT TO RS  [TO] MACROS       DO_MAC [',] IMMEDIATE RS TO CURRENT SWAPH TO ;                HERE MS @ AT DOES> ] [',] C" TO MCH [ HERE 0 , TO MCH ] TO ;    HEADER MAC: HERE MCH ! MH , ,  C" ; TO MCH                      : ?MAC ' 2+ BEGIN COUNT ?DUP WHILE EMIT REPEAT DROP ;           -MAC FORTH  0 ' X 3 - C!  ( INIT MACRO ENGINE)                  ( FACTORIEL                                                   ) FORGET IT : IT ;                                                LIKE 0>= 0<= -1 C, -1 C, 0 C,                                                                                                   : FACT TO MYSELF ARGS( ARG )                                        ARG 0<= IF  1  ELSE  ARG DUP 1- MYSELF * THEN /ARGS ;       : FACT2 ARGS( ARG )  1 ARG 0<= IF EXIT THEN                        ARG 1+ 1 DO I * LOOP /ARGS ;                                 : FACT3 TO MYSELF DUP 0<= IF DROP 1 EXIT THEN DUP 1- MYSELF * ; : FACT4 DUP 0<= IF 1 NIP EXIT THEN 1 SWAP 1+ 1 DO I * LOOP ;    : FACT5 1 SWAP DUP 0<= IF DROP EXIT THEN FOR R@ 1+ * NEXT ;                                                                                                                                                                                                                                                                                                                                     ( MACRO ENGINE  LAST                                          ) TO FORTH   C" ; STACK> MAC:    TO HIDDEN                           0 QUAN MH  FIRST <STACK MS                                   : SWAPH HERE MH TO HERE TO MH ; : IN>MS >IN TO MS BLK TO MS ;   : TEXT>IN 0 TO BLK TIB - TO >IN ; : MS>IN MS TO BLK MS TO >IN ; : MAC@ [AT] MACROS @ MH ;  : MAC! TO MH [AT] MACROS ! ;         : <MAC> CREATE AT MAC: @  WORD COUNT AT (DO DO I C@ C, LOOP      0 C, IMMEDIATE DOES> AT DROP IN>MS TEXT>IN TO INTERPRET ;      : EX'MAC SWAPH CURRENT >R [TO] MACROS  EXEC R> TO CURRENT        SWAPH ; M: ['] <MAC> EX'MAC ;M  TO FORTH     ' MAC: !          : X AT DROP AT MS @ FIRST - IF MS>IN TO INTERPRET THEN ;        IMMEDIATE  M: AT MAC: @ [',] C" AT MAC: ! MAC: AT MAC: ! ;M     ' MAC: 2+ !  : Z". BEGIN COUNT ?DUP WHILE EMIT REPEAT DROP ;    : ?MAC ' 2+ Z". ;  : -MAC FIRST AT MS ! 0 R0 MAC! ;               -MAC   0 ' X 3 - C! ( INIT)                                                                                                   ( MACRO ENGINE                                                ) F83   QUAN MAC: 0 , : ?MAC ' 2+ BEGIN COUNT                      ?DUP WHILE EMIT REPEAT DROP ; TO HIDDEN  VALUE MH  STACK> MS   : SWAPH HERE MH TO HERE TO MH ; : -MAC R0 DUP AT MS ! 100 +      TO MH [AT] MACROS OFF ; MF: CREATE AT MAC: @ WORD COUNT         FOR COUNT C, NEXT DROP 0 C, [',] IMMEDIATE DOES> AT DROP BLK    TO MS >IN TO MS 0 TO BLK TIB - TO >IN TO INTERPRET [           AT MAC: 2+ !     TO FORTH HIDDEN    : X AT DROP AT MS @ R0 -       IF MS TO >IN MS TO BLK TO INTERPRET THEN ; IMMEDIATE         MF: SWAPH CURRENT TO RS  [TO] MACROS [ AT MAC: 2+ , ] ( DO_MAC)   RS TO CURRENT SWAPH ;MF  ' MAC: !                             MF: [',] C" AT MAC: ! MAC: ;MF  ' MAC: 2+ !   C" ; AT MAC: !    -MAC FORTH  0 ' X 3 - C!  ( INIT MACRO ENGINE)                                                                                                                                                                                                                  (  conditional compilation)                                     : ?LOAD ( scr flg -) IF LOAD ELSE DROP THEN ; ( conditional)    : MATCH? ( a a - f)  ( end of input stream counts as a match)     OVER C@ IF DUP C@ 1+ -TEXT 0= ELSE DROP THEN  ;                                                                               0 NM: 6 - C>N DROP ;M   M: ;M DUP  3 MAKER .COND                                                                                .COND .THEN   .COND .IF   .COND .ELSE      ( TO .IF)            MF: TO WORD  AT .IF MATCH? IF TO .THEN THEN HERE ;MF ' .IF 2+ ! MF: BEGIN TO .IF AT .THEN MATCH? UNTIL ;MF  ( .ELSE  TO .THEN)      DUP  ' .ELSE !  ' .THEN 2+ !                                MF: ( .IF  f -) 0= IF BEGIN TO .IF DUP  AT .ELSE MATCH? SWAP        AT .THEN MATCH? OR UNTIL THEN ;MF  ' .IF !                                                                                                                                                                                                                  ( FORGET <FORGET> REMEMBER                                   )  TO HIDDEN                                                       (         : {WORD} >IN TO RS TO WORD RS TO >IN @ ;               : ?EXIST {WORD} 1- DUP IF DROP HERE FIND SWAP DROP THEN ;      ) VALUE FENCE    ' FENCE TO FENCE                               : forget   DUP FENCE U< A" fence !" >R  [AT] FORTH 2+              BEGIN @ DUP R@ U< 0= WHILE  N>C 8 +                             REPEAT [AT] FORTH 2+ !  [ ' FORTH C>N DROP ] LITERAL            BEGIN N>C 8 + DUP 2-                                              BEGIN @ DUP R@ U< 0=                                            WHILE N>C 2- REPEAT OVER 2- ! @ DUP                           UNTIL DROP [',] FORTH [TO] FORTH  R> TO HERE ;               TO FORTH                                                        : FORGET ' C>N DROP forget ;                                                                                                                                                                    ( NONAMED HEADERLESS | -HEADERS +HEADERS                      )                                                                                                                                 : -HEAD AT HERE SP 1K AT 2* - AT VSWAP TO ! 0 TO HEADER ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( WITHIN ," > <= EDITOR POSXY WIPE RELOAD SAVEBLK LB N B ARROW)                                                                 VOCABULARY EDITOR  EDITOR DEFINITIONS                            0 VALUE >BLK  0 VALUE >XY 0 VALUE >LEN                          0 VALUE XY    -HEADERS    0 VALUE CHG  0 VALUE INS             : ~CHANGE 0 TO CHG ; :  CHANGE 1 TO CHG ;                       : POSXY 1L U/MOD 4 2 TO + GOTOXY ; : RDR PAD .BLOCK ; ( REDRAW) : WIPE PAD 1K BLANK CHANGE RDR ;                                : RLD SCR BLOCK PAD 1K CMOVE ~CHANGE RDR ;                      : SAVEBLK CHG IF PAD SCR BLOCK 1K CMOVE UPDATE ~CHANGE THEN ;   : LB SAVEBLK SCR + TO MAX TO SCR ;                              : N 1 LB RLD ;   : B -1 LB RLD ;  : XY! 1K 1- AND TO XY ;       : L_UP XY 1L - XY! ; : L_DN XY 1L + XY! ;                       : L_END XY 1L 1- OR XY! ;  : L_BEG XY 1L NEGATE AND XY! ;  -->                                                                                                                                  ( COPY POS^ LINE/ /LINE LDRAW EL INSC DELC OVTC INSL DELL LL  ) : -> XY 1+ XY! ; : <- XY 1- XY! ; : TAB> XY 7 OR 1+ XY! ;       : <TAB XY 1- -8 AND XY! ; : POS^ PAD XY + ; : <_| L_DN L_BEG ;  : LINE/ PAD XY 960 AND + ; : L2 1K  XY - 1L - TO MAX ;          : LDRAW 13 EMIT LINE/ XY 1L / .LINE ;                                                                                           : /LINE PAD XY 63 OR + ;    : P2 POS^ DUP DUP 1L + ;            : EL 1K L2 - 1L MIN BLANK ;                                     : DELL P2 SWAP L2 CMOVE L2 +  EL RDR CHANGE ;                   : OVTC POS^ C! CHANGE ;  : INSL P2 L2 TO CMOVE EL RDR CHANGE ;  : POSC POS^ DUP 1+ ;     : LL /LINE POS^ - ;                    : INSC INS IF POSC LL TO CMOVE THEN OVTC ;                      : DELC POSC SWAP LL CMOVE bl /LINE C! LDRAW CHANGE ;            : _INS INS 0= TO INS 75 2 GOTOXY INS                               IF ." INS" ELSE ." OVT" THEN ; | : BS <- DELC ;       -->                                                                    ( /EDIT L E EDIT                                              ) : /EDIT SAVEBLK FLUSH ;  | : /ED /EDIT 0 18 GOTOXY QUIT ;       : L 960 XY <= IF 1 LB 0 TO XY THEN  XY 1L < IF WIPE THEN <_|        0 WORD COUNT 1L MIN LINE/ SWAP CMOVE ;                      | CREATE CTRLS   25 C,  CTRL [ C,  CTRL S C,  CTRL E C,  bs C,   CTRL D C, CTRL N C,  CTRL B C,  CTRL L C,  CTRL I C,            CTRL M C, CTRL J C,  CTRL K C,  CTRL W C,  CTRL X C,  80 C,     77 C, 75 C, 72 C, 83 C, 79 C, 71 C, 73 C, 81 C, 82 C, 15 C,    | CREATE OPER1 ] /ED   INSL  DELL  BS    DELC  N     B     RLD     TAB>  <_|   <-    ->    WIPE  _INS  L_DN  ->    <-    L_UP      DELC  L_END L_BEG B     N     _INS  <TAB  [  | : XKBD >R     CTRLS COUNT R> SCAN 1+ ?DUP IF 1- 2* OPER1 + AT EXEC THEN ;       TO FORTH                                                      : E RLD _INS _INS BEGIN XY 1L U/MOD 4 2 TO + GOTOXY KEY DUP B>W   IF B>W DUP 31 > IF  INSC  LDRAW ->  ELSE  XKBD THEN             ELSE TO B>W XKBD THEN  AGAIN ;     : EDIT LIST E ;            ( PRUNE                                   )                     : CHK DUP HERE U< ;  : LOOK DUP H. DUP ID. ;                    FUNC: LPOP ( LST / P1 )  LST @ TO P1                              P1 IF P1 N>LINK @ LST ! THEN P1 ;                             FUNC: LPUSH ( P1 LST ) LST @ P1 N>LINK !  P1 LST ! ;            FUNC: PRUNE ( LST / LST2 P1 P2 )  AT P2  TO LST2                 BEGIN LST LPOP  TO P1  P1 WHILE  P1 LST2 LPUSH REPEAT           BEGIN LST2 LPOP  TO P1 P1 WHILE  P1 CHK IF P1 LST LPUSH THEN    REPEAT                                                         ;                                                                                                                                                                                                                                                                                                                                                                                                                                                               ( PRUNE                                   )                     FORGET P1  F83    VALUE P1  VALUE P2  VALUE P3                  : CHK DUP HERE U< ;  : LOOK DUP H. DUP ID. ;                    : PRUNE     [ ' FORTH C>N DROP ] LITERAL                         BEGIN DUP CR ID. N>C 8 + DUP TO P1                                BEGIN 2- @ CHK 0= WHILE LOOK N>C REPEAT                         DUP TO P2 DUP P1 2- ! ?DUP                                      IF  BEGIN N>C 2- @ ?DUP                                             WHILE LOOK CHK                                                    IF DUP P2 N>C 2- ! DUP TO P2 THEN                             REPEAT                                                      THEN                                                            P1 @ ?DUP                                                     WHILE KEY DROP REPEAT [',] FORTH [TO] FORTH ;                                                                                                                                                  ( PRUNE                                   )                     F83                                                             : PRUNE     [ ' FORTH C>N DROP ] LITERAL                         BEGIN N>C 8 + DUP                                                 BEGIN 2- @ DUP HERE U< 0= WHILE N>C REPEAT                      DUP >R OVER 2- ! R@ ?DUP                                        IF  BEGIN N>C 2- @ ?DUP                                             WHILE DUP HERE U<                                                 IF DUP R> N>C 2- ! DUP >R THEN                                REPEAT 0 R> N>C 2- !                                        THEN                                                            @ ?DUP                                                        WHILE REPEAT ;                                                  PRUNE                                                          FORGET PRUNE                                                                                                                    ( TARGET ADDRESSING                            )                   VALUE T_O   VALUE T_B  VALUE T_L  VARIABLE T_H               : TADRS ( A - A F) DUP TO T_L T_O -                                 1K U/MOD T_B + BLOCK OVER +  SWAP 1K 1- - ;                 : TC! TADRS DROP C! UPDATE ; : TC@ TADRS DROP C@ ;              : T! TADRS UPDATE IF ! ELSE OVER SWAP C! FLIP T_L 1+ TC! THEN ; : T@ TADRS IF @ ELSE C@ T_L 1+ TC@ FLIP OR THEN ;               : TC, T_H AT 1+ TC! ;  : T, T_H AT 2+ T! ;                      : TALLOT DUP 0< IF T_H +! EXIT THEN FOR bl TC, NEXT ;           : THERE T_H @ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( DISASM MAIN SCREEN                                          ) VOCABULARY DISASM   TO DISASM   HIDDEN  VARIABLE IP  VALUE OPW  : WARY CREATE 2* CLARY DOES> SWAP 2* + ; VALUE OPTBL VALUE SF   32 WARY REGNAMES                                                 =" ALCLDLBLAHCHDHBHAXCXDXBXSPBPSIDIESCSSSDSG?F?S?S?"            COUNT 0 REGNAMES SWAP CMOVE : 7AND 7 AND ; : H2-@ HERE 2- @ ;  : <REG> CREATE C, DOES> C@ SWAP 7AND + REGNAMES 2 TYPE ;        0 <REG> .BREG    8 <REG> .WREG   16 <REG> .SREG : 1AND 1 AND ;  VALUE OPNAMES  VALUE OPC  : IND? OPNAMES COUNT ROT SCLST ;      : .OP OPNAMES 1+ SWAP TO SCLST ". ; : @IP1+ IP AT 1+ ;          : @BYTE @IP1+ C@ ; : @WORD IP AT 2+ @ ; : @SBYTE @IP1+ TO C@ ;  : @OP @IP1+ @ DUP TO OPC B>W 2* OPTBL + @ TO OPW ;              : OP, TO WORD IND? 1+ ?DUP IF 1- C, C, EXIT THEN 1 ?? ;         : N1+, FOR H2-@ 256 + , NEXT ; : N, FOR H2-@ , NEXT ;           HERE TO OPNAMES 255 ,   ( SPECIAL 0-LEN WORD FIRST)    -->                                                                      ( ASM MNEMONICS                                             )   ," ADD  ," ADC ," AND ," XOR  ," INC ," DEC  ," PUSH ," POP     ," XCHG ," MOV ," OR  ," SUB  ," SBB ," CMP  ," CBW  ," CWD     ," ROL  ," ROR ," RCL ," RCR  ," RAR ," SHL  ," SHR  ," NOP     ," NOT  ," NEG ," MUL ," IMUL ," DIV ," IDIV ," TEST ," XLAT    ," JO ," JNO ," JB ," JNB ," JE ," JNE ," JBE ," JNBE ," SJMP   ," JS ," JNS ," JP ," JNP ," JL ," JNL ," JLE ," JNLE           ," JCXZ ," LOOP ," LOOPE ," LOOPNE ," CALL ," FCALL ," JMP      ," INT  ," INTO ," INT3  ," RET    ," RETF ," IRET  ," FJMP     ," ENTER ," LEAVE ," POPA  ," PUSHA ," POPF  ," PUSHF ," BOUND  ," MOVSB ," MOVSW ," CMPSB ," CMPSW ," SCASB ," SCASW ," IN     ," LODSB ," LODSW ," STOSB ," STOSW ," INSB ," INSW   ," OUT    ," OUTSB ," OUTSW ," LES  ," LDS  ," SEG ," LEA  ," ESC         ," LOCK ," REP ," REPZ ," HALT ," WAIT ," LAHF ," SAHF          ," CLI  ," STI ," CLD  ," STD  ," CMC  ," CLC  ," STC           ," AAA  ," DAA ," AAM  ," AAD  ," DAS ," AAS ," ??? -->         ( DISASM TABLE SCR 1                                         )  =" ???" IND? 1+  OPNAMES C!                                     HERE TO OPTBL                                        ( HEX)     1 OP, ADD  5 N1+,       7 OP, PUSH      7   OP, POP  ( 08)      1 OP, OR   5 N1+,       7 OP, PUSH      7   OP, POP  ( 10)      1 OP, ADC  5 N1+,       7 OP, PUSH      7   OP, POP  ( 18)      1 OP, SBB  5 N1+,       7 OP, PUSH      7   OP, POP  ( 20)      1 OP, AND  5 N1+,       7 OP, SEG       0   OP, DAA  ( 28)      1 OP, SUB  5 N1+,       7 OP, SEG       0   OP, DAS  ( 30)      1 OP, XOR  5 N1+,       7 OP, SEG       0   OP, AAA  ( 38)      1 OP, CMP  5 N1+,       7 OP, SEG       0   OP, AAS  ( 40)      8 OP, INC  7 N,         8 OP, DEC  7 N,              ( 50)      8 OP, PUSH 7 N,         8 OP, POP  7 N,              ( 60)      0 OP, PUSHA  0 OP, POPA  0 OP, BOUND  0 OP, ??? 4 N, ( 68)      0 OP, PUSH   0 OP, IMUL  0 OP, PUSH   0 OP, IMUL     ( 6C)      0 OP, INSB   0 OP, INSW  0 OP, OUTSB  0 OP, OUTSW    ( 70) -->                                                                  10 OP, JO   10 OP, JNO   10 OP, JB   10 OP, JNB      ( 74)      10 OP, JE   10 OP, JNE   10 OP, JBE  10 OP, JNBE     ( 78)      10 OP, JS   10 OP, JNS   10 OP, JP   10 OP, JNP      ( 7C)      10 OP, JL   10 OP, JNL   10 OP, JLE  10 OP, JNLE     ( 80)      0 C, 12 C,  1 N,         0 C, 13 C,  1 N,            ( 84)       1 OP, TEST 1 N,         1 OP, XCHG  1 N,            ( 88)       1 OP, MOV 3 N1+,        20 OP, MOV  21 OP, LEA      ( 8E)      20 OP, MOV               22 OP, POP                  ( 90)       0 OP, NOP               23 OP, XCHG  6 N1+,         ( 98)       0 OP, CBW  0 OP, CWD  24 OP, FCALL  0 OP, WAIT      ( 9C)       0 OP, PUSHF 0 OP, POPF  0 OP, SAHF  0 OP, LAHF      ( A0)      26 OP, MOV 1 N,          25 OP, MOV  1 N,            ( A4)       0 OP, MOVSB 0 OP, MOVSW 0 OP, CMPSB 0 OP, CMPSW     ( A8)                                                    -->                                                                                                                                               26 OP, TEST  1 N,   0 OP, STOSB 0 OP, STOSW          ( AC)       0 OP, LODSB  0 OP, LODSW  0 OP, SCASB  0 OP, SCASW  ( B0)       9 OP, MOV  7 N,    27 OP, MOV 7 N,                  ( C0)      14, 0 C,    1 N,   28 OP, RET      0 OP, RET        ( C4)       21 OP, LES  21 OP, LDS    29 OP, MOV 1 N1+,          ( C8)      30 OP, ENTER 0 OP, LEAVE   28 OP, RET  0 OP, RET     ( CC)       0 OP, INT3  31 OP, INT  0 OP, INTO 0 OP, IRET       ( D0)       0 C, 15 C,  1 N,        0 C, 16 C, 1 N,             ( D4)       0 OP, AAM   0 OP, AAD   0 OP, ???  0 OP, XLAT       ( D8)      32 OP, ESC  7 N1+,  10 OP, LOOPNE  10 OP, LOOPE      ( E2)      10 OP, LOOP 10 OP, JCXZ  33 OP, IN  1 N1+,           ( E6)                               33 OP, OUT 1 N1+,           ( E8)      11 OP, CALL 11 OP, JMP   24 OP, FJMP  10 OP, SJMP    ( EC)      34 OP, IN  1 N1+,        34 OP, OUT 1 N1+,           ( F0)                                                             -->                                                                       0 OP, LOCK   0 OP, ???   0 OP, REP   0 OP, REPZ        ( F4)    0 OP, HALT   0 OP, CMC   17 C, 0 C,  1 N,              ( F8)    0 OP, CLC    0 OP, STC   0 OP, CLI   0 OP, STI         ( FC)    0 OP, CLD    0 OP, STD   18 C, 0 C, 19 C, 0 C,        ( 100)   HERE OPTBL - .                                                                                                                                                                                                                                                                                                      -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                         : GNAME CREATE 8 FOR 0 OP, -1 ALLOT NEXT DOES>                    OPC TO B>W AT 2/ 7AND + C@ .OP ;                                                                                              GNAME  G1  ADD  OR   ADC  SBB  AND  SUB  XOR  CMP                                                                               GNAME  G2  ADD  ???  ADC  SBB  ???  SUB  ???  CMP                                                                               GNAME  G3  ROL  ROR  RCL  RCR  SHL  SHR  ???  RAR                                                                               GNAME  G4  TEST ???  NOT  NEG  MUL  IMUL DIV  IDIV                                                                              GNAME  G5  INC  DEC CALL FCALL JMP  FJMP PUSH ???                                                                               GNAME  G6  INC  DEC  ???  ???  ???  ???  ???  ???                                                     -->                       ( ADRESSING DISPLAY PROCEDURES                               )  : C. [',] C" CREATE C, DOES> C@ EMIT ; C. , ,.  C. + +. C. : :. : "0. BEGIN COUNT ?DUP WHILE EMIT REPEAT DROP ; C. [ [. C. ] ]. : NH# BASE TO RS HEX PAD AT HLD ! 0 TO HLD FOR BASE U/MOD SWAP  ALPHA TO HLD NEXT DROP RS TO BASE ; : SN 0< IF C" - ELSE C" +     THEN ; : NHEX. CREATE C, DOES> C@ NH# HLD "0. ; 2 NHEX. .BYTE : .SNH OVER ABS SWAP NH# SN TO HLD HLD "0. ;      4 NHEX. .WORD : IMM8 @BYTE .BYTE ; : IMM16 @WORD .WORD ;                      : I16I8 IMM16 ,. IMM8 ; : FADR @WORD IMM16 :. .WORD ;           CREATE ATBL  30 C, 31 C, 46 C, 47 C, 6 C, 7 C, 5 C, 3 C,        : MEM 7AND ATBL + C@ 8 U/MOD ?DUP IF .WREG +. THEN .WREG ;      : [M] [. 199 AND DUP 6 = IF DROP IMM16 ELSE DUP MEM AT 16/       ?DUP IF 1- IF @WORD 4 ELSE @SBYTE 2 THEN .SNH THEN THEN ]. ;   : ?REG. 1AND IF SF IF .SREG ELSE .WREG THEN ELSE .BREG THEN ;   : [M]/R DUP 192 < IF [M] ELSE OVER ?REG. DROP ;       -->                                                                                                                                       : BREL @SBYTE IP @ + .WORD ;   : WREL @WORD IP @ + .WORD ;      : [MEM] 6 [M] ; : A? 0 OPC ?REG. ; : A?,MEM A? ,. [MEM] ;       : MEM,A? [MEM] ,. A? ; : AX, 0 .WREG ,. ; : AL, 0 .BREG ,. ;    : AX,R AX, OPC .WREG ;  : AL,R AL, OPC .BREG ;                  : ?RM,R? OVER 2 AND IF AT 2/ SWAP ?REG. ELSE [M]/R THEN ;       : RM,R? OPC @BYTE ?RM,R? ,. OPC 2 XOR UNPACK ?RM,R? ;           : REG, CREATE C, DOES> C@ ?REG. ,. ;  : AL,#8 AL, IMM8 ;          0 REG, BREG,      1 REG, WREG,      : AX,#6 AX, IMM16 ;       : BR,#8 OPC BREG, IMM8 ;       : ESC_N OPC 7AND . ;             : WR,#6 OPC WREG, IMM16 ; : SREG OPC 31 AND AT 2/ .SREG ;       : WREG OPC .WREG ; : SGMOV -1 TO SF RM,R? 0 TO SF ;             : R6,MEM OPC 2 XOR TO OPC RM,R? ; : <MEM OPC @BYTE [M]/R ;      : IM? OPC 1AND IF IMM16 ELSE IMM8 THEN ; : M,#? <MEM ,. IM? ;   : A?,#8 A? ,. IMM8 ;                                                                             -->                            (                        )  ( R/M,R8   1  RM,R? ( R/M,R16  2  RM,R?  ( R8,R/M   3  RM,R? )  ( R16,R/M  4  RM,R? ( AL,IM8   5  AL,#8  ( AX,IM16  6  AX,#6 )  ( SEGREG   7  SREG  ( WREG     8  WREG   ( BREG,IM8 9  BR,#8 )  ( SJMP/JE 10  BREL  ( CAL/JMP 11  WREL   ( AROP1   12  AROP1 )  ( AROP2   13  AROP2 ( SH,#8   14  SH,#8  ( SH,1    15  SH,1  )  ( SH,CL   16  SH,CL ( GRP1    17  GRP1   ( GRP2    18  GRP2  )  ( GRP3    19  GRP3  ( RM,SEG  20  SGMOV  ( R6,MEM  21  R6,MEM)  ( <MEM    22  <MEM  ( AX,R    23  AX,R   ( FARCAL  24  FADR  )  ( MEM,A?  25        ( A?,MEM  26         ( R16,I16 27  WR,#6 )  ( IMM16   28        ( M,#?    29         ( I16I8   30        )  ( IMM8    31        ( ESC_N   32         ( A?,#8   33        )  ( A?      34        )                                                                                                                                                                                                                                           ( INSBLOCKS HOWMENI  STARTBLK ENDBLK                          ) : INSBLOCK 1+ OVER - FOR DUP R@ + DUP 1+ COPY NEXT                  BLOCK  1K  BLANK UPDATE FLUSH ;                             : BLCOPY  ( START ENDBL NEWSTART -)  PUSH 1+ OVER - POP SWAP      FOR OVER R@ + OVER R@ + COPY NEXT  2DROP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( 286 MNEM) ," A  ," B  ," C  ," D  ," E  ," F  ," G  ," H  ," I ," ADD  ," ADC ," AND ," XOR  ," INC ," DEC  ," PUSH ," POP     ," XCHG ," MOV ," OR  ," SUB  ," SBB ," CMP  ," CBW  ," CWD     ," ROL  ," ROR ," RCL ," RCR  ," RAR ," SHL  ," SHR  ," NOP     ," NOT  ," NEG ," MUL ," IMUL ," DIV ," IDIV ," TEST ," XLAT    ," JO ," JNO ," JB ," JNB ," JE ," JNE ," JBE ," JNBE ," SJMP   ," JS ," JNS ," JP ," JNP ," JL ," JNL ," JLE ," JNLE           ," JCXZ ," LOOP ," LOOPE ," LOOPNE ," CALL ," FCALL ," JMP      ," INT  ," INTO ," INT3  ," RET    ," RETF ," IRET  ," FJMP     ," ENTER ," LEAVE ," POPA  ," PUSHA ," POPF  ," PUSHF ," BOUND  ," MOVS  ," CMPS ," SCAS ," IN                                  ," LODS ," STOS ," INS   ," OUT                                 ," OUTS ," LES  ," LDS  ," SEG ," LEA  ," ESC                   ," LOCK ," REP ," REPZ ," HALT ," WAIT ," LAHF ," SAHF          ," CLI  ," STI ," CLD  ," STD  ," CMC  ," CLC  ," STC           ," AAA  ," DAA ," AAM  ," AAD  ," DAS ," AAS ," ???            ( DISASM MAIN SCREEN                                          ) VOCABULARY DISASM   TO DISASM   HIDDEN                                                                                          VARIABLE IP  VALUE OPW                                          : WARY CREATE 2* CLARY DOES> SWAP 2* + ;                                                                                        VALUE OPTBL VALUE SF     24 WARY REGNAMES                        =" ALCLDLBLAHCHDHBHAXCXDXBXSPBPSIDIESCSSSDSG?F?S?S?"            COUNT 0 REGNAMES SWAP CMOVE                                    40 WARY DFUNS  ( DISPLAY FUNCTIONS)                                                                                             : 7AND 7 AND ;  : 1AND 1 AND ;     : H2-@ HERE 2- @ ;           : <REG> CREATE C, DOES> C@ SWAP 7AND + REGNAMES 2 TYPE ;                                                                        0 <REG> .BREG    8 <REG> .WREG   16 <REG> .SREG                                                                                 ( DISASM                                                      ) : F-GET SF AND                                                                                                                  VALUE OPNAMES  VALUE OPC                                        : IND? OPNAMES COUNT ROT SCLST ;                                : OP_NAM. OPNAMES 1+ SWAP TO SCLST ". ;                         : @IP1+ IP AT 1+ ;                                              : @BYTE @IP1+ C@ ; : @WORD IP AT 2+ @ ; : @SBYTE @IP1+ TO C@ ;  : @OP @IP1+ @ DUP TO OPC B>W 2* OPTBL + @ TO OPW ;              : OP. @OP                                                       : OP, TO WORD IND? 1+ ?DUP IF 1- C, C, EXIT THEN 1 ?? ;         : N,   FOR HERE 2- @ , NEXT ;                                                                                                   HERE TO OPNAMES 0 C,   ( SPECIAL 0 COUNT OF WORDS FIRST)          109 LOAD ( OPNAMES)  =" ???" IND?  1+ OPNAMES C!                                                                              ( DISASM TABLE SCR 1                                   HEX      : ?END >IN PUSH BLWORD POP TO >IN COUNT 1-                         IF 2DROP 0 EXIT ELSE C@ DUP 0= IF 2DROP -1 EXIT THEN            SWAP COUNT FOR 2DUP C@ = IF BLWORD 2DROP 0 LEAVE THEN                       1+ NEXT  IF DROP 0 THEN ;)                       : ?END >IN PUSH BLWORD COUNT 1-  IF DROP -1 ELSE C@ THEN          SWAP COUNT ROT SCAN 1+ DUP  IF RDROP ELSE POP TO >IN THEN ;   ( : 0"! 0 HERE 1- C! ; IMMEDIATE)                                                                                               : CONST( 1- NEGATE   FOR 0" )"                                               ?END IF LEAVE THEN R@ NEGATE CONSTANT NEXT ;       9 CONST( R/M,R  A,IM  SEG B1 WR BR RG BJ STR NN                                                                                                                                                                                                                                                                                 ( DISASM TABLE SCR 1                                   HEX   )  : ARITH, R/M,R >IN PUSH OP, POP TO >IN 3 N,                              A,IM OP, 1 N, ;                                        : STRNG, STR  OP, 1 N, ;                                                                                                        HERE TO OPTBL                                                       ARITH,  ADD       SEG OP, PUSH     SEG  OP, POP  ( 08)          ARITH,  OR        SEG OP, PUSH     SEG  OP, POP  ( 10)          ARITH,  ADC       SEG OP, PUSH     SEG  OP, POP  ( 18)          ARITH,  SBB       SEG OP, PUSH     SEG  OP, POP  ( 20)          ARITH,  AND       SEG OP, SEG       B1  OP, DAA  ( 28)          ARITH,  SUB       SEG OP, SEG       B1  OP, DAS  ( 30)          ARITH,  XOR       SEG OP, SEG       B1  OP, AAA  ( 38)          ARITH,  CMP       SEG OP, SEG       B1  OP, AAS  ( 40)        WR OP, INC  7 N,     WR OP, DEC  7 N,              ( 50)        WR OP, PUSH 7 N,     WR OP, POP  7 N,              ( 60)      ( DISASM TABLE SCR 2                                   HEX   )                                                                  B1 OP, PUSHA  B1 OP, POPA  B1 OP, BOUND  B1 OP, ??? 4 N, ( 68)  0 OP, PUSH   0 OP, IMUL  (                                                               0 OP, PUSH   0 OP, IMUL                                                                         ( 6C)  B1 OP, INSB   B1 OP, INSW  B1 OP, OUTSB  B1 OP, OUTSW    ( 70)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( BJ BYTE JUMP)                                       BJ OP, JO   BJ OP, JNO   BJ OP, JB   BJ OP, JNB    ( 74)        BJ OP, JE   BJ OP, JNE   BJ OP, JBE  BJ OP, JNBE   ( 78)        BJ OP, JS   BJ OP, JNS   BJ OP, JP   BJ OP, JNP    ( 7C)        BJ OP, JL   BJ OP, JNL   BJ OP, JLE  BJ OP, JNLE   ( 80)        0 C, 12 C,  1 N,         0 C, 13 C,  1 N,            ( 84)       1 OP, TEST 1 N,         1 OP, XCHG  1 N,            ( 88)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1 OP, MOV 3 N1+,        20 OP, MOV  21 OP, LEA      ( 8E)      20 OP, MOV               22 OP, POP                  ( 90)      B1 OP, NOP               WR OP, XCHG  6 N1+,         ( 98)      B1 OP, CBW  B1 OP, CWD  24 OP, FCALL B1 OP, WAIT     ( 9C)      B1 OP, PUSHF   B1 OP, POPF                                                       B1 OP, SAHF        B1 OP, LAHF      ( A0)      26 OP, MOV 1 N,          25 OP, MOV  1 N,            ( A4)         STRNG, MOVS                       STRNG, CMPS     ( A8)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      26 OP, TEST  1 N,                                                      STRNG,  STOS   STRNG, LODS    STRNG, SCAS    ( B0)        9 OP, MOV  7 N,    27 OP, MOV 7 N,                  ( C0)      14, 0 C,    1 N,   28 OP, RET      B1 OP, RET       ( C4)       21 OP, LES  21 OP, LDS    29 OP, MOV 1 N1+,          ( C8)      30 OP, ENTER 0 OP, LEAVE   28 OP, RET  B1 OP, RET    ( CC)      B1 OP, INT3  31 OP, INT  B1 OP, INTO  B1 OP, IRET    ( D0)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( NN = ESC 6)                                            0 C, 15 C,  1 N,        0 C, 16 C, 1 N,             ( D4)      B1 OP, AAM   B1 OP, AAD   B1 OP, ???   B1 OP, XLAT   ( D8)      NN OP, ESC  7 N1+,  10 OP, LOOPNE  10 OP, LOOPE      ( E2)      10 OP, LOOP 10 OP, JCXZ  33 OP, IN  1 N1+,           ( E6)                               33 OP, OUT 1 N1+,           ( E8)      11 OP, CALL 11 OP, JMP   24 OP, FJMP  10 OP, SJMP    ( EC)      34 OP, IN  1 N1+,        34 OP, OUT 1 N1+,           ( F0)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      B1 OP, LOCK  B1 OP, ???  B1 OP, REP  B1 OP, REPZ        ( F4)   B1 OP, HALT  B1 OP, CMC   17 C, 0 C,  1 N,              ( F8)   B1 OP, CLC   B1 OP, STC  B1 OP, CLI  B1 OP, STI         ( FC)   B1 OP, CLD   B1 OP, STD   18 C, 0 C, 19 C, 0 C,        ( 100)   HERE OPTBL - .                                                                                                                                                                                                                                                                                                                  ( Mini-OOF                         12apr98py)                                                                                   : METHOD ( m v -- m' v ) CREATE  OVER , SWAP 2+ SWAP              DOES> ( ... o -- ... ) @ OVER @ + PERFORM ;                   : VAR ( m v size -- m v' ) CREATE  OVER , +                       DOES> ( o -- addr ) @ + ;                                     : CLASS ( class -- class methods vars ) DUP 2@ ;                : END-CLASS  ( class methods vars -- )                            CREATE  HERE >R , DUP , 4 ?DO ['] NOOP , 2 +LOOP                2+ DUP 2+ R> ROT @ 4 /STRING MOVE ;                           : DEFINES ( xt class -- ) ' 2+ @ + ! ;                          : NEW ( class -- o )  HERE OVER @ ALLOT SWAP OVER ! ;           : :: ( class "name" -- ) ' 2+ @ + @ , ;                         CREATE OBJECT  2 , 4 ,                                                                                                                                                                          ( TEST OOF                                                  )   HEADER OOF   F83                                                : /STRING ( C-ADDR1 N1 N -- C-ADR2 N2)                            ROT OVER + -ROT - ; (      PUSH R@ - SWAP POP + SWAP ;)                                                                                                                                                                                                       ( 122     LOAD ( /STRING S" )                                     120     LOAD ( OOF)                                           ( 124 126 THRU  )                                                                                                                                                                                                                                                                                                                                                                                                                                               ( ASSENBLER /STRING                                           )                                                                 CODE /STRING  AX POP, CX POP,  AX BX XCHG,                        AX CX ADD,  AX BX SUB,  CX PUSH, NEXT, END-CODE                                                                               ( CODE + AX POP, AX BX ADD, NEXT, END-CODE      )                                                                               : S" C" " WORD DUP C@ 1+ ALLOT ;                                                                                                2 CONSTANT CELL                                                 1 CONSTANT CHAR                                                 4 CONSTANT LONG                                                 : CELLS 2* ;                                                    : CHARS ;                                                       : LONGS CELLS CELLS ;                                                                                                           (     BRAINF*CK IN FORTH, 2003, CARSTEN STROTMANN             ) CR .( BrainF*ck )  QUAN IP : IP+ AT IP 1+! ; : IP- AT IP 1-! ;  : IP@ IP C@ ; : BDEF CREATE , DOES> @ >R 2DUP C@ R> + SWAP C! ; 1 BDEF BF+  -1 BDEF BF- : BF. DUP C@ EMIT ;                     : BF, DUP KEY SWAP C! ; : BF> 1+ ; : BF< 1- ;                   : BF[ DUP C@ 0= IF BEGIN IP+ IP@ 93 = UNTIL THEN ;              : BF] BEGIN IP- IP@ 91 = UNTIL ;                                : BFI ( ADDR) TO IP BEGIN                                         IP@ 93 = IF BF] THEN  IP@ 91 = IF BF[ THEN                      IP@ 62 = IF BF> THEN  IP@ 60 = IF BF< THEN                      IP@ 46 = IF BF. THEN  IP@ 44 = IF BF, THEN                      IP@ 45 = IF BF- THEN  IP@ 43 = IF BF+ THEN IP+ IP@ 0= UNTIL ;                                                                 : BF HERE 3000 ERASE HERE BLWORD 1+ BFI ;                                                                                                                                                                                                                       : P-N CREATE C, DOES> C@ ?CS: AT APP  ROT  UF4 TO ARES ;           0 P-N PREVDEM   1 P-N PREVDOM  2 P-N NEXTDEM  3 P-N NEXTDOM     4 P-N PREVEMP   5 P-N PREVELM  6 P-N NEXTEMP  7 P-N NEXTELM  MAC: 1# ?CS: AT APP 2SWAP ;     MAC: 2# ?CS: -ROT 0 SWAP ;      MAC: 3# 0. 2SWAP ;  : READEL  1#  2#  5  A-FUNC TO ARES ;       : WRITEL  2#  1#  6  A-FUNC TO ARES ;                           : INSELM  2#  1# 12  A-FUNC TO ARES ;                           : DEFDOM S>D SWAP 3# 1# 10  A-FUNC TO ARES ;                    : MOVELM  1#  SWAP 0.   20  A-FUNC TO ARES ;                    : SETLEN  1# 3# SWAP    15  A-FUNC TO ARES ;                    : GETLEN  -1. SETLEN ;    : DELEM 0. SETLEN ;                   : DELDOM  0 DEFDOM ;      : GETDOM -1 DEFDOM ;                                                                                                                                                                                                                  ( POSTPONE TEST                                               )                                                                 : 'IF POSTPONE IF ; IMMEDIATE : 'ELSE POSTPONE ELSE ; IMMEDIATE : 'THEN POSTPONE THEN ; IMMEDIATE                                                                                               : PROBA 'IF 5 'ELSE 6 'THEN ;                                   : 'SWAP! POSTPONE SWAP POSTPONE ! ; IMMEDIATE                   : := 'SWAP! ;                                                   : 2>R POSTPONE SWAP POSTPONE >R POSTPONE >R ; IMMEDIATE         : N>R 1+ 2* RS SWAP RP OVER - DUP TO RP SWAP FLD! ;             : NR> 2+ 2* RP 2- 2DUP + TO RS SWAP FLD@ TO RP TO RS ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( RECORDS  SHEMA                                              ) OFST    MEANING  129 130 BLOCK                                                                                                     0    SIZE OF VARIABLES IN OBJECT / RECORD    ( 2 FIRST)         2    OFFSET OF LAST METHOD      IF = 0 THIS IS RECORD           4    LINK FIELD / DICT 33 32                                    6    ROOT OF THE LIST OF FIELDS / METHODS  DICTIONARY                                                                        131 - 132 BLOCK                                                   -4    MASTER OBJECT ( PARENT)                                   -2    OFFSET OF LAST METHOD                                      0    SIZE OF VARIABLES IN OBJECT                                2    ROOT OF THE NAMES IN CLASS                                                                                                                                                                                                                                                                                              F83  0 QUAN THIS 0. D, CREATE OBJECT 18 CLARY =" ! " 1+ @       TO HIDDEN                             OBJECT 4 + ! ( LINK)      0 NM: @ THIS + ! ;M  ( :NONAME TO METHOD) ' THIS 10 +  !        1 NM: @ THIS + PERFORM ;M ( EXECUTE)      ' THIS  8 + !          VALUE THAT 0. D, 0 ,   HIDDEN TO FORTH  139 LOAD               0 NM: C@ THAT +  ;M ( VAR ADDRESS)            ' THAT  10 + !    1 NM: COUNT THAT + SWAP C@ FLD! ;M ( VAR !)   ' THAT   8 + !    2 NM: COUNT THAT + SWAP C@ FLD@ ;M ( VAR @)   ' THAT   6 + !    : CLASS: THIS CURRENT CSP! THIS { OBJECT 10 + DUP TO THIS        6 + TO CURRENT THAT THIS 8 MOVE THAT 2+ 2+ CURRENT ! } ;           M: THAT THIS @ ;M ' THIS 2+ 2+ !                            : METHOD -2 THIS 2+ @+! [ ' THIS 8 + ] LITERAL 2 LIKE, , ;      : VAR  DUP THIS @+! [ ' THAT 6 + ] LITERAL 3 LIKE, C, C, ; -->                                                                                                                                                                                                  : /STRING ROT OVER + -ROT - ; : DEFS CONTEXT TO CURRENT ;       : ;CLASS ?CSP TO CURRENT DUP { 2+ @ THIS 2+ @ ?DO COMPILE NOOP    2 +LOOP THAT DUP 2+ @ 0 SWAP /STRING 2/ NW, THIS 4 NW, HERE     2- DUP TO CONTEXT 6 - DUP TO THIS } CONSTANT DOES> @ DUP         TO THIS  6 + TO CONTEXT ;                                    : :: { ' EXEC ' 2+ 2+ @ THIS + @ , } ; IMMEDIATE                OBJECT TO THIS CLASS: METHOD INIT  METHOD PUT  METHOD GET       ;CLASS OBJECTS   USE: AT THIS FLD! ;M DUP TO GET  TO INIT       USE: AT THIS FLD@ ;M TO PUT                                     : OBJ THIS CONSTANT HERE THIS @ ALLOT { INIT } DOES> DUP DUP 2+   HIDDEN TO THAT @ DUP TO THIS 6 + TO CONTEXT ;                                                                                 ' IOV @  1 NM: 2! ;M  2 NM: 2@ ;M                               : 2QUAN HEADER TO , [ , ] TO , [ , ] TO , [ , ] D, ;    F83                                                                                                                                     0 QUAN THIS 0. D, CREATE OBJECT 0 , -4 , 76 CLARY ' OBJECT 2-!  TO HIDDEN  HERE <STACK OSTK                                     0 NM: @ THIS + ! ;M  ( :NONAME TO METHOD) ' THIS 10 +  !        1 NM: @ THIS + PERFORM ;M ( EXECUTE)      ' THIS  8 + !          VALUE THAT 0. D, 0 ,   HIDDEN TO FORTH                         0 NM: C@ THAT +  ;M ( VAR ADDRESS)            ' THAT  10 + !    1 NM: COUNT THAT + SWAP C@ FLD! ;M ( VAR !)   ' THAT   8 + !    2 NM: COUNT THAT + SWAP C@ FLD@ ;M ( VAR @)   ' THAT   6 + !    : { CONTEXT TO OSTK THIS TO OSTK THAT TO OSTK ;                 : } OSTK TO THAT OSTK TO THIS OSTK TO CONTEXT ;                 : CLASS: TO THAT CURRENT TO OSTK OBJECT DUP 8 + DUP TO THIS     2+ TO CURRENT  THAT 4 - THIS 4 - DUP PUSH 8 MOVE THAT POP !         AT OSTK @ TO OSTK ; M: THAT THIS @ ;M ' THIS 2+ 2+ !        : METHOD -2 THIS 2- @+! [ ' THIS 8 + ] LITERAL 2 LIKE, , ;      : VAR  DUP THIS @+! [ ' THAT 6 + ] LITERAL 3 LIKE, C, C, ; -->  (  ROT OVER + -ROT - ; (      PUSH R@ - SWAP POP + SWAP ;)      : ;CLASS OSTK AT OSTK @ - 0 =? OSTK TO CURRENT                           THAT 2- @ THIS 2- @ ?DO COMPILE NOOP 2 +LOOP             THAT DUP 2- @ +  -4 THAT 2- @ - 2/ NW,                          THIS 2- 2- 4 NW, HERE 2- DUP TO CONTEXT 2- TO THIS ;          : :: { ' EXEC ' 2+ 2+ @ THIS + @ , } ; IMMEDIATE                : >INST  ( ADDR CLASS) DUP TO THIS 2+ TO CONTEXT TO THAT ;      : INSTANCE DUP ( CLASS  ADDRESS)   CONSTANT  @ CLARY                       DOES> WCOUNT >INST ;                                 { OBJECT CLASS: METHOD INIT  METHOD PUT  METHOD GET ;CLASS      USE: AT THIS FLD! ;M DUP TO GET  USE: AT THIS FLD@ ;M TO PUT    : OBJ THIS INSTANCE RUN INIT DOES> WCOUNT >INST PUT ;             TO INIT    THIS } CONSTANT OBJECTS                            ' IOV @  1 NM: 2! ;M  2 NM: 2@ ;M                               : 2QUAN HEADER TO , [ , ] TO , [ , ] TO , [ , ] D, ;    F83                                                                     F83                                                             OBJECTS CLASS:                                                      CELL VAR TEXT                                                   CELL VAR X                                                      CELL VAR Y                                                        METHOD DRAW                                               ;CLASS BUTTON                                                    USE: X Y AT-XY TEXT ".    ;M   TO DRAW                          USE: TO TEXT  TO Y  TO X  ;M   TO INIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( DSC OBJECT                                                  ) F83                                                             OBJECTS CLASS:  CELL VAR APP   CELL VAR ELAPP  LONG VAR DOMAIN   LONG VAR ELEMENT  LONG VAR OFFSET METHOD INITN                  METHOD SHOW  METHOD CLEAR  METHOD NIX                                  124 LOAD                                                ;CLASS DSC          USE: PUT . . 3 FOR SWAP D. NEXT ;M TO SHOW   USE: AT THIS ERASE ;M TO CLEAR USE: AT THIS -1 FILL ;M TO NIX   USE: 3 AND PUSH  TO APP  TO ELAPP  AT DOMAIN POP  TO 2*  CNTDO       ?DO I A! LONG +LOOP ;M TO INITN  USE: 3 INITN ;M TO INIT                                                                                                                                                                                                                                                                                                                                                                                                  ( DEM - DOMAIN EMPTY  EMP - EMPTY ELEMENT  ELM - ELEMENT      ) 129 LOAD                                                                                                                        0. 2QUAN ARES : UOPEN ROT ?CS: SWAP 2SWAP 18 UF4 TO ARES ;      : ?-AUTO  0= SWAP 0= OR ; : UCLOSE <# 0 HOLD HLD -ROT UOPEN ;   : ?ARCH 0. 0. 22  A-FUNC DROP ; : ?NEL ARES AND 1+ 0= ;         : XDSC -ROT PUSH PUSH S>D 0 POP 0 POP 0. ;                      : +ARCH 2DUP ?-AUTO A" AUTO?" 2DUP ?ARCH IF 2DUP UCLOSE THEN TO  ARES COUNT PUSH ?CS: SWAP ARES -1 XDSC 0 POP 38 UF4 TO ARES ;  : SYSARCH " ARM_FILE.000" 0. UOPEN ;                                                                                              RELINK  SYSARCH   0. ?ARCH .                                                                                                  134 LOAD                                                                                                                                                                                        ( ARM OBJECT 1                                                ) { OBJECT CLASS:                                                    DSC @ VAR sDSC     DSC @ VAR dDSC   DSC @ VAR eDSC               LONG VAR sADR      LONG VAR dADR    LONG VAR eADR               CELL VAR LENLO     CELL VAR LENHI   CHAR VAR FN                 CHAR VAR NEXTFN    CELL VAR RESLO   CELL VAR RESHI              CELL VAR ADRLO     CELL VAR ADRHI                                 METHOD INIT        METHOD READEL    METHOD WRITEL               METHOD INSEL       METHOD COPYEL    METHOD DELEMENT             METHOD DELDOM      METHOD AOPEN     METHOD ANEXT          ;CLASS                                                           :NONAME ?CS: AT sDSC TO sADR  ?CS: AT dDSC TO dADR                      ?CS: AT eDSC TO eADR  0 TO LENHI ;M       TO INIT             THIS } CONSTANT ARM_C                                                                                                                                                                    ( ARM OBJECT                                                  ) { OBJECT CLASS:                                                    DSC @ VAR sDSC     DSC @ VAR dDSC   DSC @ VAR eDSC               LONG VAR sADR      LONG VAR dADR    LONG VAR eADR               CELL VAR LENLO     CELL VAR LENHI   CHAR VAR FN                 CHAR VAR NEXTFN    CELL VAR RESLO   CELL VAR RESHI              CELL VAR ADRLO     CELL VAR ADRHI                                 METHOD INIT        METHOD READEL    METHOD WRITEL               METHOD INSEL       METHOD COPYEL    METHOD DELEMENT             METHOD DELDOM      METHOD AOPEN     METHOD ANEXT          ;CLASS THIS } CONSTANT ARM_C                                    ARM_C INSTANCE ARM1                                                                                                                                                                                                                                                                                                             ( RECURCE       TEST  OK                               )                                                                        : FAC DUP 2 < IF DROP 1 EXIT THEN DUP 1- RECURCE * ;                                                                            : FIB DUP 2 < IF EXIT THEN 1- DUP 1- RECURCE SWAP RECURCE + ;                                                                   : HANOJ ( 0 2 N) 1- ?DUP IF >R                                         2DUP OVER + 3 XOR       R@   RECURCE                            2DUP                    1    RECURCE                            SWAP OVER + 3 XOR SWAP  R>   RECURCE ELSE                       SWAP CR ." FROM " . ."  TO " .  THEN ;                                                                                                                                                                                                                                                                                                                                                   ( ?STACK  -WCOUNT S. R.                                   )                                                                     : -WCOUNT 2- DUP @ ; : ?ITEMS 2DUP - NIP 2 / 1- ;               : ?STACK DUP 0< A" STACK UNDERFLOW" ;                           ( : #S. 2- OVER MAX ?DO I @ . -2 +LOOP ;)                       : #S. CR EMIT C" [ EMIT bl EMIT  ?ITEMS ?STACK FOR                   -WCOUNT . NEXT DROP C" ] EMIT ;                            : S. S0 SP C" S #S. ;  : R. R0 RP C" R #S. ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( OBJECT MAN                                                  )  2 10 10 14 14 12  \ SIZES OF THE FIELDS                        CLASS: PERSON  F: AGE    ;F  ALLOT  F: MOBILE ;F  ALLOT                        F: EGN    ;F  ALLOT  F: FAMILY ;F  ALLOT                        F: SNAME  ;F  ALLOT  F: NAME   ;F  ALLOT         ;CLASS                                                          METHOD: PERSON                                                  : SHOW CR ."      : " NAME 12 TYPE  CR ."  : " SNAME   14 TYPE  CR ."  : " FAMILY 14 TYPE  CR ."     EGN : "     EGN 10 TYPE  CR  ."     GSM : "                                MOBILE 10 TYPE CR ."  : " AGE 2 TYPE ;                  ;METHOD                                                         : PERS 160 BLOCK 256 + [SEND] PERSON SHOW ;                                                                                                                                                                                                                     (                                                             )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( NUMBERS                                                     ) { OBJECTS CLASS:                                                   METHOD ADD   METHOD SUB      METHOD MUL      METHOD DIV         METHOD PRINT  ;CLASS THIS } CONSTANT NUMBERS                                                                                 { NUMBERS CLASS:  CELL VAR NUM   METHOD MOD  ;CLASS               USE: + ;M TO ADD   USE: NEGATE + ;M TO SUB                      USE: * ;M TO MUL   USE: / ;M TO DIV                             USE: /MOD DROP ;M TO MOD  USE: . ;M TO PRINT                  THIS } CONSTANT INTEGERS                                        : GCD BEGIN 2DUP - WHILE 2DUP > IF SWAP THEN                      OVER - REPEAT DROP ;                                                                                                                                                        -->                                                                                                                                                (  CONTINUE NUMBERS                                          )                                                                 0 NUMBERS >INST DEFINITIONS                                     : + ADD ;  : - SUB ;  : * MUL ;  : . PRINT ;  : / DIV ;         F83                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             : LIT, ( x) POSTPONE LITERAL ;  (           ) : >SIZE ( ta - n) CELL+ @ ;     (           )                                (   .   )  : SELF+ ( n - a) SELF + ;       (   .   ) : SEND ( a xt) SELF >R  SWAP    (       )   TO SELF EXEC R> TO SELF ;  (         )    0  VALUE ACLS     ( CLS)       ( contains ta     )  : SIZE^ ( - aa) ACLS ?DUP 0=   (      )     A" scope?" CELL+ ;       (     0              )     : MFIND ( ta ca u - xt n) 2>R   (                             )  BEGIN DUP WHILE DUP @ 2R@ ROT  (                             )    SEARCH-WORDLIST ?DUP IF ROT  (                             )    DROP 2R> 2DROP EXIT THEN     (                             )    CELL+ CELL+ @ REPEAT         (                             )         -1 A" can't?" ;     (                             )                                                                     : SEND' ( a ta "m ") BL WORD    (                             )   COUNT MFIND 0< STATE @ AND    (                             )    IF SWAP LIT, LIT, POSTPONE   (                             )         SEND ELSE SEND THEN ;   (                             ) : SUPER ( "m ") SIZE^ CELL+ @   (                             )         BL WORD COUNT MFIND 0>  (                             )    IF EXECUTE ELSE COMPILE,     (                             )    THEN ; IMMEDIATE             (                             ) : DEFS ( n "f ") CREATE SIZE^   (                             )    @ , SIZE^ +! IMMEDIATE       (                             )    DOES> @ STATE @ IF LIT,      (                             )    POSTPONE SELF+ ELSE SELF+    (                             )    THEN ;                       (                             ) : METHODS ( ta) DUP TO ACLS @  (                             )    DUP TO CURRENT      (                             )                                                                              >R GET-ORDER R> SWAP 1+      (                             ) SET-ORDER ; ( ALSO CONTEXT !)   (                             ) : CLASS ( "c ") CREATE HERE     (                             )    0 , 0 , 0 ,                  (                             )    WORDLIST OVER ! METHODS ;    (                             ) : SUBCLASS ( ta "c ") CLASS     (                             )    SIZE^ OVER >SIZE OVER !      (                             )    CELL+ ! ;                    (                             ) : END ( ) SIZE^ DROP PREVIOUS   (                             )    DEFINITIONS 0 TO ACLS ;    (                             )   : NEW ( ta "name ") CREATE DUP  (                             )    , >SIZE ALLOT IMMEDIATE      (                             )    DOES> DUP CELL+ SWAP @ SEND' ;                               : VAR 1 CELLS DEFS ;   ( would be a nice add-on. But there's)                            ( more. We may nest objects within )                                                                                                   ( others: )                     : IV ( TA "NAME ") DUP >SIZE DEFS ,   (                     )      DOES> 2@ SELF+ SWAP SEND' ;  (                           )   CLASS FOO ( IT IS USED THUSLY: )                                   BUTTON IV BTN1                                                  BUTTON IV BTN2                                               END                                                             ( WE COULD ALSO EMBED REFERENCES TO OTHER OBJECTS,WITH)         : REF ( TA "NAME ") VAR ,                                          DOES> 2@ SELF+ @ SWAP SEND' ;                                ( THIS ALLOWS US TO SAY )                                       CLASS LINK                                                         0 DEFS 'NEXT                                                    LINK REF NEXT                                                END                                                                                                                             ( where the 'next definition is used as a way to store          addresses into the reference field. Arrayed instance            variables are left as an exercise for the reader                I always wanted to say that sometime).                          ( Also, for cases, one might want to factor NEW into )          : INSTANCE ( ta) DUP , >SIZE ALLOT                                 DOES> DUP CELL+ SWAP @ SEND' ;                               : NEW ( ta "name ") CREATE INSTANCE IMMEDIATE ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 : SELLS 2* ;                                                    1 CELLS CONSTANT CELL                                                                                                           CLASS BUTTON                                                       CELL DEFS TEXT                                               (   CELL DEFS LEN  )                                               CELL DEFS X                                                     CELL DEFS Y                                                  : DRAW ( )   X @ Y @ AT-XY  TEXT @ ( LEN @) COUNT TYPE ;        : INIT ( CA U)   0 X ! 0 Y ! ( LEN !)  TEXT ! ;                 END                                                                                                                                                                                                                                                                                                                                                                                             : BOLD   27 EMIT ." [1M" ;                                      : NORMAL 27 EMIT ." [0M" ;                                                                                                      BUTTON SUBCLASS BOLD-BUTTON                                     : DRAW ( )   BOLD SUPER DRAW NORMAL ;                           END                                                                                                                             BUTTON NEW FOO                                                  S" THIN FOO" FOO INIT                                                                                                           FOO DRAW                                                        BOLD-BUTTON NEW BAR                                             S" FAT BAR" BAR INIT                                            1 BAR Y !                                                       BAR DRAW                                                                                                                        ( This comprises the basic definitions I can't do without.      Some quick explanations regarding the stack comments:           ta  the address of a class  /formerly "type"/,                  ta -> | wid | size | super-ta |                                 oa  the address of an object instance)                                                                                                                                                                                                                                                                                          (  oa -> | ta | ... |  "c "   a class name follows the word     "f "  a field name /instance variable name/ follows the word    "m "   an existing method name /selector/  follows the word )                                                                                                                                                                                                   ( LIT, >SIZE  SELF SELF+ SEND CLS@                            )                                                                                                                                   0 QUAN ACLS                                                   : LIT, ( x) POSTPONE LITERAL ;  (           ) : >SIZE ( ta - n) 2+ @ ;        (           ) : SELF+ SELF + ; ( SELF+ N - A   .   )                                     (   .   ): SEND ( a xt) SELF >R  SWAP    (       )   TO SELF EXEC R> TO SELF ;  (         )                                    ( contains ta     )                                                                                                                                     -->                                                                                                                                                                                                                                                                                                                                                                                         : SIZE^ ( - aa) ACLS ?DUP 0=    (      )    A" scope?" 2+ ;              (     0              ) : (FIND >R -1 SWAP @ R> TO FIND ;                               : MFIND ( ta ca   - xt n) >R    (                             )  BEGIN DUP WHILE DUP @ R@ (FIND (                             )   ?DUP IF ROT RS 2DROP EXIT THEN  (                           )    DROP CELL+ CELL+ @ REPEAT    (                             )         -1 A" can't?" ;     (                             )                                                                                                                                                   -->                                                                                                                                                                                                                                               : SEND' ( a ta "m ") TO WORD    (                                       MFIND 0< STATE   AND    (                             )    IF SWAP LIT, LIT, COMPILE    (                             )      COMPILE THEN SEND ;   (                             )      : SUPER ( "m ") SIZE^ >SIZE     (                             )   TO WORD MFIND 0< IF EXEC      (                             )   ELSE , THEN ; IMMEDIATE       (                             )                                                                                                                                                                                                                                                                                                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            : DEFS ( n "f ") CREATE SIZE^   (                             )    @ , SIZE^ +! IMMEDIATE       (                             )    DOES> @ STATE IF LIT,        (                             )    COMPILE THEN AT SELF ;       (                             )                                 (                             ) : METHODS ( ta) DUP TO ACLS @   (                             )   DUP CURRENT  TO CSTK          (                             )     TO CURRENT ;                                                                    -->                                                                                                                                                                                                                                         : CLASS ( "c ") CREATE >MARK    (                             )        0 , 0 ,                  (                             )   >MARK     OVER ! METHODS ;    (                             ) : SUBCLASS ( ta "c ") CLASS     (                             )    SIZE^ OVER >SIZE OVER !      (                             )    2+    ! ;                    ( WORDLIST HERE 1 C, bl C, 0 ,)                                                                 : INSTANCE DUP , >SIZE ALLOT                                      DOES> WCOUNT SEND' ;                                                                                                          : NEW CREATE INSTANCE IMMEDIATE ;                                                                                                                      -->                                                                                                                                                                                                                                      : END ( ) SIZE^ DROP            (                             )    CSTK TO CURRENT 0 TO ACLS ;  (                             ) ( NEW ( ta "name "( CREATE DUP  (                                  , >SIZE ALLOT IMMEDIATE      (                                  DOES> DUP CELL+ SWAP @ SEND' ;                             ) : VAR 1 CELLS DEFS ;   ( would be a nice add-on. But there's)                            ( more. We may nest objects within )                                                                                                                                                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( others: )                     : IV ( TA "NAME ") DUP >SIZE DEFS ,   (                     )      DOES> 2@ AT SELF SWAP SEND' ;  (                           ) ( CLASS FOO ( IT IS USED THUSLY: (                                 BUTTON IV BTN1                                                  BUTTON IV BTN2                                               END )                                                                                                                                                                                                                      -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( WE COULD ALSO EMBED REFERENCES TO OTHER OBJECTS,WITH)         : REF ( TA "NAME ") VAR ,                                          DOES> 2@ AT SELF @ SWAP SEND' ;                              ( THIS ALLOWS US TO SAY )                                       CLASS LINK                                                         0 DEFS 'NEXT                                                    LINK REF NEXT                                                END                                                                                                                                                                                                                                                                                                                             ( F: ;F  CLASS: ;CLASS )                                        : %D, SWAP D, ;  : %? 2@ SWAP D. ;  EXIT                        12 14 14 10 10 2 (                                              0      ;8      ;16     ;24     ;32     ;40     ;48     ;56    ]                   6106227249088334033147                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (  OUTBLKS                                                    )                                                                 : OUTBLKS 1+ SWAP ?DO I LIST LOOP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( ANS GET-ORDER  SET-ORDER  )                                                                                                   : GET-ORDER ORDER# WCOUNT 2* CNTDO ?DO I @ 2 +LOOP                          CONTEXT ORDER# @ 1+ ;                               : SET-ORDER 1- DUP ORDER# ! SWAP TO CONTEXT                              FOR R@ 2* ORDER# + ! NEXT ;                                                                                            : SEARCH-WORDLIST >R "MAKE -1 SWAP R> FIND                         NEGATE DUP 0= IF NIP THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( MYSELF HANOJ-II )                                             ( VECTOR MYSELF)                                                : \\ [',] \ ; IMMEDIATE                                         FUNC: HANOJ ( S_PILON T_PILON D_PILON DISKS )                   \  ( S_PILON .  T_PILON . D_PILON . DISKS .    )                \\ PROBA COMENTAR LI E ILI SHE GRAMNE                               AT DISKS AT 1-  (  DISKS--)                                     IF                                                                   S_PILON D_PILON T_PILON DISKS  RECURCE                          S_PILON T_PILON D_PILON 1      RECURCE                          T_PILON S_PILON D_PILON DISKS  RECURCE                     ELSE                                                                 CR ." Move Disk From Pilon  " S_PILON .                                  ."   To Pilon  "     D_PILON .                    THEN  ;  ( ' HANOJ TO MYSELF  )                                                                                             ( REUSE 'DROP  ?EXIST POSTPONE                              )   : REUSE >IN TO RS BLWORD RS TO >IN ;  : 'DROP WORD DROP ;       : ?EXIST REUSE FIND NIP ;                                       : POSTPONE -FIND DUP 0= ?? 1+ IF COMPILE COMPILE THEN , ;          IMMEDIATE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (                                               RECURCE )       F83     (  ROOTLINK-ADR WITH-ADR)                                                                                               \ : FIX-LINX BEGIN OVER TO >< ?DUP 0= UNTIL DROP ;              \ : NODE+ ( WITH-ADR ROOTLINK-ADR) TO >< , ;                    \ 0 NM: AT CURRENT N>C OVER FIX-LINX TO 0 ;M                    \ 1 NM: HERE NODE+ ;M HEADER RECURCE , , 0 , IMMEDIATE                                                                          : FAC DUP 2 < IF DROP 1 EXIT THEN DUP 1- RECURCE * ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (  ARM PROBA                                                  ) ( FORGET %D,    )                                                123456. 456789. 345678. 2 1    160 LOAD                        CLASS: DESCR                                                      F: OFFS ;F  %D,  F: ELEM ;F  %D,  F: DOMN ;F  %D,               F: APPE ;F  ,    F: APPL ;F  ,                                ;CLASS                                                          METHOD: DESCR                                                   : SHOW APPL ? APPE ? DOMN %? ELEM %? OFFS %? ;                  ;METHOD                                                                                                                            CLASS: MYCONST  F: C1 @ ;F NOOP ;CLASS                       0  CLASS: MYVALUE                                                     INHERIT MYCONST                                                 F: C1! ! ;F ,                                               ;CLASS                                                        ( F: ;F  CLASS: ;CLASS : ?SIZE 0 SWAP FOR R@ 1+ PICK + NEXT ; ) : '? ' DUP @ [ ' AT @ ] LITERAL = IF 2+ C@ ' + THEN ;           : ;F [',] ;M '? TO ON; ; IMMEDIATE  0 NM: TO CONTEXT ;M          0 QUAN MHP 2Z, , 2Z, : ;METHOD   PREVIOUS DEFINITIONS ;        : METHOD: ALSO [',] AT DEFINITIONS ; : INHERIT CONTEXT METHOD:   CURRENT DUP [ AT MHP 6 + ] LITERAL ! @ SWAP! ;METHOD ;         : F: HEADER COMPILE [ 9 FRM @ , ] USE: TO ON; ;                 : CLASS: HEADER COMPILE [ ' DOES> 2+ @ , ] >MARK AT MHP 2+ !      ALSO COMPILE [ AT MHP 4 + @ , ] 2Z,  COMPILE CREATE AT MHP 2+   @ , [',] DOES> COMPILE TO SELF AT MHP 2+ @ 2+ DUP , EXEC             DEFINITIONS  COMPILE EXIT  MH TO ON; ;                   : ;CLASS  M: AT MHP 2+ @ ! 254 @ ?DUP IF 2- TO ON; THEN                                    BEGIN AT ON; @ 254 - WHILE ON; DUP ,   MH TO MHP EX'MAC MH MHP = IF RECOVER THEN MHP 254 @ - ON;       !  REPEAT [',] ;M  ON; TO MH  ;METHOD ;                                                                                       